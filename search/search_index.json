{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>PreFab is a virtual nanofabrication environment that leverages deep learning to model fabrication-induced structural variations in integrated photonic devices. Our mission is to bridge the gap between design and fabrication in photonic integrated circuits.</p>"},{"location":"#what-prefab-does","title":"What PreFab does","text":""},{"location":"#prediction-of-fabrication","title":"Prediction of fabrication","text":"<p>Anticipate how your designs will be affected by real fabrication processes. PreFab predicts process-induced structural variations: corner rounding, loss of small features, filling of narrow gaps, sidewall angle variations, and stochastic effects.</p> <p></p>"},{"location":"#correction-of-fabrication","title":"Correction of fabrication","text":"<p>Automatically optimize your designs to ensure fabricated results match your specifications. Our correction algorithms help minimize structural variations and reduce performance discrepancies between simulations and fabricated devices.</p> <p></p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Quick links</p> <ol> <li>Setup guide</li> <li>Learn about fabrication-aware design</li> <li>Explore example notebooks</li> </ol> <p>Try Rosette (beta)</p> <p>Want a more visual experience? Try the Rosette beta - our new layout tool with PreFab models built in, designed for rapid chip design.</p>"},{"location":"#get-in-touch","title":"Get in touch","text":"<p>PreFab is continuously evolving to serve the photonics community better. We welcome your feedback and contributions. Share your thoughts via email, report issues on GitHub, or follow our updates on LinkedIn.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#120-2025-03-19","title":"1.2.0 - 2025-03-19","text":"<ul> <li>Added <code>Device.segment</code> method to segment an SEM image into a binary mask. Some more testing to be done.</li> <li>Added <code>predict.predict_gdstk</code> to predict directly on a <code>gdstk.Cell</code>. This is useful for predicting very large devices that won't fit into memory.</li> </ul>"},{"location":"CHANGELOG/#119-2025-01-22","title":"1.1.9 - 2025-01-22","text":"<ul> <li>Fix cropping issue with <code>device.to_ndarray</code>.</li> <li>Add example of sidewall angle simulation and correction to docs.</li> </ul>"},{"location":"CHANGELOG/#118-2025-01-16","title":"1.1.8 - 2025-01-16","text":"<ul> <li>Added <code>prefab</code> command to the <code>pyproject.toml</code> file so that <code>prefab</code> can be run from the command line (e.g., <code>prefab setup</code>).</li> <li>Change to callback address for successful authentication.</li> </ul>"},{"location":"CHANGELOG/#117-2025-01-14","title":"1.1.7 - 2025-01-14","text":"<ul> <li>Added <code>autograd</code> and <code>pydantic</code> (version requirement) dependencies in <code>pyproject.toml</code>.</li> <li>Server-side improvements (update endpoint version number to 2).</li> </ul>"},{"location":"CHANGELOG/#116-2024-12-30","title":"1.1.6 - 2024-12-30","text":"<ul> <li>Added Tidy3D fabrication-aware inverse design (FAID) example notebook.</li> <li>Remove buffer from <code>Device</code> created with <code>read.from_sem</code> method.</li> <li>Handling of extended bounds in <code>read.from_sem</code> method.</li> <li>Use OpenCV for morphological operations in <code>geometry.enforce_feature_size</code>.</li> <li>Add handling for <code>None</code> casee for <code>BufferSpec</code> in <code>Device</code> constructor.</li> </ul>"},{"location":"CHANGELOG/#115-2024-11-05","title":"1.1.5 - 2024-11-05","text":"<ul> <li>Fix alignment issue in <code>Device._device_to_gdstk</code> method, which is used in <code>Device.to_gdstk</code> and <code>Device.to_gds</code>.</li> <li>Minor linting fixes.</li> </ul>"},{"location":"CHANGELOG/#114-2024-11-01","title":"1.1.4 - 2024-11-01","text":"<ul> <li>Added custom vector-Jacobian product (VJP) for the <code>predict.predict_array_with_grad</code> function.</li> <li>Changed some of the docstrings in <code>prefab.predict</code> to be more consistent and clear.</li> </ul>"},{"location":"CHANGELOG/#113-2024-10-26","title":"1.1.3 - 2024-10-26","text":"<ul> <li>Moved prediction logic to <code>prefab.predict</code> module.</li> <li>First version of <code>predict.predict_array_with_grad</code>, which returns both the predicted array and its gradient. This is useful to fabrication-aware inverse design (FAID). More to come.</li> <li>Added <code>origin</code> parameter to GDS-related export methods.</li> <li>Small docstring fixes.</li> </ul>"},{"location":"CHANGELOG/#112-2024-10-10","title":"1.1.2 - 2024-10-10","text":"<ul> <li>User warning if <code>compare.intersection_over_union</code>, <code>compare.hamming_distance</code>, or <code>compare.dice_coefficient</code> are called with non-binarized devices.</li> <li>Added <code>height</code> parameter to many shape constructors in <code>prefab.shapes</code> to give more flexibility.</li> <li>Updates to the <code>README.md</code> to keep current.</li> <li><code>Device.is_binary</code> is now a property.</li> <li>Moved <code>Device.enforce_feature_size</code> logic to <code>prefab.geometry</code> module.</li> <li>Added required version of <code>gdstk</code> to <code>pyproject.toml</code>.</li> <li>Removed leftover return statement in <code>geometry.rotate</code>.</li> </ul>"},{"location":"CHANGELOG/#111-2024-09-24","title":"1.1.1 - 2024-09-24","text":"<ul> <li>Manually adding small random noise to the \"SEMulated\" images to better match the real data. This is ideally included in the model training, but for now this is a quick fix.</li> <li>Added z-padding to the device array before exporting to STL with <code>Device.to_stl</code> to ensure that the exported device is closed.</li> <li>Removed buffer from <code>Device.device_array</code> before exporting to with <code>Device.to_gdsfactory</code>.</li> <li>The additions from <code>1.0.3</code> and <code>1.0.4</code> releases, which should be considered part of this release. Release planning a work in progress.</li> <li>Import and export from/to Tidy3D simulations with <code>Device.to_tidy3d</code> and <code>read.from_tidy3d</code>.</li> <li>Import and export from/to gdsfactory components with <code>Device.to_gdsfactory</code> and <code>read.from_gdsfactory</code>.</li> <li>Convert 2D device structures into 3D arrays or STL files with <code>Device.to_3d</code> and <code>Device.to_stl</code>. This is useful for simulating processes with angled sidewalls.</li> <li>Check and visualize the effect of enforcing a minimum feature size on the device geometry with <code>Device.check_feature_size</code> and <code>Device.enforce_feature_size</code>.</li> </ul>"},{"location":"CHANGELOG/#104-2024-09-19","title":"1.0.4 - 2024-09-19","text":"<ul> <li>Option to specify GPU or CPU in <code>predict</code>, <code>correct</code>, and <code>semulate</code> functions. GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</li> <li>Improve clarity of messaging for authentication errors.</li> </ul>"},{"location":"CHANGELOG/#103-2024-09-14","title":"1.0.3 - 2024-09-14","text":"<ul> <li>Added this <code>CHANGELOG.md</code> file.</li> <li>Added <code>prefab.shapes</code> module to replace the now removed <code>devices</code> directory. This module contains helpful device constructors for testing PreFab models on.</li> <li>Added <code>__version__</code> class attribute to <code>prefab</code> package.</li> <li>Added <code>ANT_NanoSOI_ANF1-d8</code> and <code>ANT_NanoSOI_ANF1-d10</code> models (see <code>prefab.models</code> and <code>docs/models.md</code>).</li> <li>Updated notebook examples to use <code>prefab.shapes</code> module and newest models.</li> <li>Updated dependencies in <code>pyproject.toml</code>.</li> <li>Simplified <code>.gitignore</code> and <code>.gitattributes</code> files.</li> <li>Docstring improvements to <code>prefab.compare</code> module.</li> <li>Ability to specify thickness to all four sides of buffer thickness in <code>prefab.device.BufferSpec</code>.</li> <li>Changed some of the array resizing logic in <code>prefab.read</code> module to be more robust.</li> <li>Minor fixes to <code>prefab.device</code> module.</li> <li>Minor fixes to <code>prefab.geometry</code> module.</li> <li>Removed <code>devices</code> directory from the repository. Effectively replaced with <code>prefab.shapes</code> module.</li> <li>Remove <code>requirements.txt</code> file as <code>pyproject.toml</code> contains all dependencies.</li> </ul>"},{"location":"fab_aware_design/","title":"Fab-aware design","text":"<p>PreFab bridges the gap between photonic design and fabrication by incorporating real fabrication effects directly into the design process. Deep learning and computer vision are used to predict and compensate for manufacturing variations that traditional approaches often ignore due to lack of useful data. This enables accurate prediction, verification, and optimization of designs with fabrication effects in mind to create manufacturable designs that are as close to the theoretical limit as possible, while also reducing the need for manual design iteration and costly repeated fabrication runs.</p> <p>Note</p> <p>While our general documentation focuses on planar geometric variations, the same principles extend to other critical fabrication effects. PreFab supports or is developing support for other effects such as sidewall angle, material thickness variations, and surface roughness - all of which significantly impact photonic device performance.</p> <p>In this document, we'll explore four key aspects of fabrication-aware design:</p> <ol> <li>Modelling fabrication awareness</li> <li>Design verification</li> <li>Design correction</li> <li>Fabrication-aware inverse design</li> </ol>"},{"location":"fab_aware_design/#modelling-fabrication-awareness","title":"Modelling fabrication awareness","text":"<pre><code>flowchart LR\n    A[GDS&lt;br&gt;Cells] --&gt; B[Prediction&lt;br&gt;Model]\n    A --&gt; F[Nanofabrication&lt;br&gt;and Imaging]\n    F --&gt; E\n    B --&gt; C[Predicted&lt;br&gt;Cells]\n    C --&gt; D[Calculate&lt;br&gt;Differences]\n    D --&gt; |Training| B\n    E[SEM&lt;br&gt;Images] --&gt; D\n    style A fill:none,color:white,stroke:white\n    style B fill:none,color:white,stroke:lightgreen\n    style C fill:none,color:white,stroke:white\n    style D fill:none,color:white,stroke:white\n    style E fill:none,color:white,stroke:white\n    style F fill:none,color:white,stroke:lightblue\n    linkStyle default stroke:white</code></pre> <p>The foundation of fabrication-aware design lies in building a model that accurately predicts how designs will manifest on the chip. Our modeling system achieves this through a pipeline that combines deep learning with real nanofabrication data, as shown in the diagram above.</p> <p>Models</p> <p>PreFab handles this part of the process. See our models documentation for more details. Reach out to us if you'd like to see support for a new fabrication process.</p> <p>A nanofabrication process transforms designs into physical devices through multiple steps, each with unique parameters and inherent variability across fabrication runs and wafer locations. Our approach simplifies this complexity by directly modeling the relationship between design inputs and fabricated outcomes, without modeling intermediate steps.</p> <p>The foundation of this system is our training data generation. GDS layout cells with varying features and distributions are fabricated, followed by high-resolution SEM imaging to capture the results. This creates paired design-outcome datasets that represent the complete process behavior.</p> <p>At the heart of the system, a neural network model processes GDS layouts to predict post-fabrication structures. The model continuously refines its predictions by comparing against SEM images and updating its understanding through iterative training. Through this process, we train separate models for each fabrication process, enabling accurate predictions of manufacturing outcomes.</p> <p>For a simple look at how the prediction model works for a single process, see our prediction notebook.</p>"},{"location":"fab_aware_design/#design-verification","title":"Design verification","text":"<pre><code>flowchart LR\n    A[Device&lt;br&gt;Design] --&gt; B[Prediction&lt;br&gt;Model]\n    B --&gt; C[Predicted&lt;br&gt;Design]\n    C --&gt; D[EM&lt;br&gt;Simulation]\n    D --&gt; E[Compare&lt;br&gt;Results]\n    A --&gt; D\n    E -.-&gt; |Manual Design Iteration| A\n    style A fill:none,color:white,stroke:white\n    style B fill:none,color:white,stroke:lightgreen\n    style C fill:none,color:white,stroke:white\n    style D fill:none,color:white,stroke:yellow\n    style E fill:none,color:white,stroke:white\n    linkStyle default stroke:white</code></pre> <p>Once we can predict fabrication outcomes with a prediction model, the next step is verifying how they'll affect device performance. The verification workflow combines these predictions with electromagnetic simulations like FDTD to provide a better picture of real-world behavior.</p> <p>The process begins with a prediction of how the device design will appear after fabrication. The original and predicted structures are simulated to understand how fabrication effects will impact performance. Especially for complex devices that push the limits of fabrication, this comparison provides valuable insights for design iteration, enabling data-driven decisions about necessary adjustments.</p> <p>This approach eliminates much of the guesswork in photonic circuit development. Rather than relying on intuition or empirical rules of thumb, designers can make informed choices based on accurate predictions of fabricated performance. By PreFab being written in Python, we can easily integrate with other simulation and layout tools.</p> <p>For a practical example of this workflow, see our prediction and simulation tutorial.</p>"},{"location":"fab_aware_design/#design-correction","title":"Design correction","text":"<pre><code>flowchart LR\n    A[Device&lt;br&gt;Design] --&gt; B[Correction&lt;br&gt;Model]\n    B --&gt; C[Corrected&lt;br&gt;Design]\n    C -.-&gt; D[Design&lt;br&gt;Verification]\n    style A fill:none,color:white,stroke:white\n    style B fill:none,color:white,stroke:lightgreen\n    style C fill:none,color:white,stroke:white\n    style D fill:none,color:white\n    linkStyle default stroke:white</code></pre> <p>While verification helps identify potential issues, design correction takes this a step further by automatically compensating for fabrication effects. The correction model works similarly to the prediction model but in reverse\u2014instead of predicting fabricated shapes from designs, it generates designs that will fabricate into desired shapes.</p> <p>The correction model generates a corrected design with precise geometric adjustments\u2014adding material where erosion is expected, removing it where dilation is anticipated, and adjusting corners to account for rounding effects. This corrected design can be sent directly to fabrication or, optionally, through the verification workflow for additional confidence. As many designs\u2014even simple ones\u2014can create impossible-to-replicate structures (e.g., a 90\u00b0 corner), the correction process will never be able to create a perfect design (we are still bound to fundamental physical limits), but we find that corrections always offer a significant degree of useful improvement.</p> <p>This approach transforms fabrication effects from an unavoidable source of error into a controllable variable. Instead of using conservative design margins, we enable targeted corrections that push designs closer to their theoretical limits while maintaining manufacturability.</p> <p>For existing designs, this correction workflow is a great way to improve performance without having to start from scratch.</p> <p>For a simplified example of design correction, see our correction notebook.</p>"},{"location":"fab_aware_design/#fabrication-aware-inverse-design","title":"Fabrication-aware inverse design","text":"<pre><code>flowchart LR\n    A[Device&lt;br&gt;Design] --&gt; B[Prediction&lt;br&gt;Model]\n    B --&gt; C[Predicted&lt;br&gt;Design]\n    C --&gt; D[EM&lt;br&gt;Simulation]\n    D --&gt; E[Gradient&lt;br&gt;Calculation]\n    E --&gt; |Optimization| A\n    style A fill:none,color:white,stroke:white\n    style B fill:none,color:white,stroke:lightgreen\n    style C fill:none,color:white,stroke:white\n    style D fill:none,color:white,stroke:yellow\n    style E fill:none,color:white,stroke:white\n    linkStyle default stroke:white</code></pre> <p>The ultimate integration of fabrication awareness comes in the form of fabrication-aware inverse design or FAID, where fabrication effects are incorporated directly into the optimization process itself. Rather than appending fabrication awareness as a post-processing step, here it is incorporated into the optimization loop itself to create designs that are inherently manufacturable.</p> <p>This is especially useful in designing around aspects of the fabrication process (e.g., etching and stochastic effects) that cannot be corrected with design parameter tuning. In other words, FAID produces the best possible design given the limits of fabrication.</p> <p>The optimization loop begins with an initial design and uses the prediction model to anticipate its fabricated form. This predicted structure is then simulated, from which we calculate gradients that guide design updates (depending on the optimization algorithm). The process repeats, continuously refining the design while accounting for both performance targets and fabrication constraints. The result is designs that are inherently manufacturable while meeting performance requirements.</p> <p>For a detailed example of this advanced workflow, see our fabrication-aware inverse design tutorial.</p>"},{"location":"models/","title":"Models","text":"Foundry Process Latest Version Latest Dataset Model Name Model Tag ANT NanoSOI ANF1 (May 6 2024) d10 (Jun 8 2024) ANT_NanoSOI ANF1-d10 ANT SiN ANF1 (May 6 2024) d1 (Jan 31 2024) ANT_SiN ANF1-d1 <p>For additional foundry and process models, feel free to contact us.</p>"},{"location":"setup/","title":"Setup","text":"<p>Follow the steps below to install and authenticate the PreFab Python package.</p> <p>Python</p> <p>If you are new to Python, we recommend starting with the Python for Photonics blog post.</p>"},{"location":"setup/#install-prefab","title":"Install PreFab","text":""},{"location":"setup/#from-pypi","title":"From PyPI","text":"<p>You can easily install PreFab using pip, which is the Python package installer. This method is suitable for most users.</p> <pre><code>pip install prefab\n</code></pre>"},{"location":"setup/#from-github","title":"From GitHub","text":"<p>For those who wish to make changes to the source code for their own development purposes, PreFab can also be installed directly from GitHub.</p> <pre><code>git clone https://github.com/PreFab-Photonics/PreFab.git\ncd PreFab\npip install -e .\n</code></pre>"},{"location":"setup/#sign-up","title":"Sign up","text":"<p>Before you can make PreFab requests, you will need to create an account. Sign up here. PreFab models are currently available for all registered users.</p>"},{"location":"setup/#authenticate-prefab-token","title":"Authenticate PreFab token","text":"<p>To link your PreFab account to the API, you will need to create an authentication token. You can do this by running the following command in your terminal. This will open a browser window where you can log in and generate a token.</p> <pre><code>prefab setup\n</code></pre>"},{"location":"setup/#verify-installation","title":"Verify installation","text":"<p>To verify that PreFab is setup correctly, you can run the following Python code.</p> <pre><code>import prefab as pf\n\ndevice = pf.shapes.target()\nprediction = device.predict(model=pf.models[\"ANT_NanoSOI\"])\n</code></pre> <p>If the code runs without errors, you have successfully installed and authenticated PreFab. If not, please reach out to us at support@prefabphotonics.com.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/prefab-v1.1.0/","title":"PreFab v1.1.0","text":"In\u00a0[1]: Copied! <pre>import prefab as pf\n\ntarget = pf.shapes.target(width=500, arm_width=60)\ntarget.plot()\n\ngrating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=10)\ngrating.plot()\n\nradial_grating = pf.shapes.radial_grating(width=500, num_gratings=10)\nradial_grating.plot()\n</pre> import prefab as pf  target = pf.shapes.target(width=500, arm_width=60) target.plot()  grating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=10) grating.plot()  radial_grating = pf.shapes.radial_grating(width=500, num_gratings=10) radial_grating.plot() Out[1]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> In\u00a0[2]: Copied! <pre>import time\n\nimport prefab as pf\n\ngrating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=200)\n\n# Timing the CPU correction\nstart_time = time.time()\ngrating_c_cpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=False)\ncpu_duration = time.time() - start_time\nprint(f\"CPU correction time: {cpu_duration:.2f} seconds\")\n\n# Timing the first GPU correction (cold start)\nstart_time = time.time()\ngrating_c_gpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True)\ngpu_duration = time.time() - start_time\nprint(f\"Cold GPU correction time: {gpu_duration:.2f} seconds\")\n\n# Timing the second GPU correction (hot start)\nstart_time = time.time()\ngrating_c_gpu2 = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True)\ngpu_duration2 = time.time() - start_time\nprint(f\"Hot GPU correction time: {gpu_duration2:.2f} seconds\")\n</pre> import time  import prefab as pf  grating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=200)  # Timing the CPU correction start_time = time.time() grating_c_cpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=False) cpu_duration = time.time() - start_time print(f\"CPU correction time: {cpu_duration:.2f} seconds\")  # Timing the first GPU correction (cold start) start_time = time.time() grating_c_gpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True) gpu_duration = time.time() - start_time print(f\"Cold GPU correction time: {gpu_duration:.2f} seconds\")  # Timing the second GPU correction (hot start) start_time = time.time() grating_c_gpu2 = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True) gpu_duration2 = time.time() - start_time print(f\"Hot GPU correction time: {gpu_duration2:.2f} seconds\") <pre>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:17&lt;00:00,  5.75%/s]\n</pre> <pre>CPU correction time: 17.68 seconds\n</pre> <pre>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:08&lt;00:00, 12.39%/s]\n</pre> <pre>Cold GPU correction time: 27.42 seconds\n</pre> <pre>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 44.18%/s]</pre> <pre>Hot GPU correction time: 2.47 seconds\n</pre> <pre>\n</pre> In\u00a0[11]: Copied! <pre>import prefab as pf\n\nstar = pf.shapes.star(width=500, num_points=4)\nstar.plot()\n\nstar.check_feature_size(min_feature_size=30, strel=\"disk\")\nstar_e = star.enforce_feature_size(min_feature_size=30, strel=\"disk\")\nstar_e.plot()\n</pre> import prefab as pf  star = pf.shapes.star(width=500, num_points=4) star.plot()  star.check_feature_size(min_feature_size=30, strel=\"disk\") star_e = star.enforce_feature_size(min_feature_size=30, strel=\"disk\") star_e.plot() <pre>Feature size check with minimum size 30 using 'disk' structuring element resulted in a Hamming distance of: 702\n</pre> Out[11]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> In\u00a0[1]: Copied! <pre>import prefab as pf\n\ntarget = pf.shapes.target(width=1000, arm_width=200)\ntarget_p = target.predict(model=pf.models[\"ANT_SiN_ANF1_d1\"], binarize=True)\ntarget_p.plot()\n\ntarget_p_3d = target_p.to_3d(thickness_nm=400)  # visualizer to come soon\ntarget_p.to_stl(thickness_nm=400)  # this will create a 3D STL file you can inspect\n</pre> import prefab as pf  target = pf.shapes.target(width=1000, arm_width=200) target_p = target.predict(model=pf.models[\"ANT_SiN_ANF1_d1\"], binarize=True) target_p.plot()  target_p_3d = target_p.to_3d(thickness_nm=400)  # visualizer to come soon target_p.to_stl(thickness_nm=400)  # this will create a 3D STL file you can inspect <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:04&lt;00:00, 22.84%/s]\n</pre> <pre>Saved Device to 'prefab_device.stl'\n</pre> In\u00a0[16]: Copied! <pre>import gdsfactory as gf\nimport prefab as pf\n\ncomponent = gf.components.triangle(x=1, xtop=0, y=2, ybot=0, layer=\"WG\")\ncomponent.plot()\ndevice = pf.read.from_gdsfactory(component)\n\ndevice_c = device.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True)\ncomponent_c = device_c.to_gdsfactory()\ncomponent_c.plot()\n</pre> import gdsfactory as gf import prefab as pf  component = gf.components.triangle(x=1, xtop=0, y=2, ybot=0, layer=\"WG\") component.plot() device = pf.read.from_gdsfactory(component)  device_c = device.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True) component_c = device_c.to_gdsfactory() component_c.plot() <pre>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 46.44%/s]\n</pre> <p>This second example shows how to read a Tidy3D simulation, correct the structure using PreFab, and then send it back to a Tidy3D simulation.</p> In\u00a0[20]: Copied! <pre>import prefab as pf\nimport tidy3d as td\n\nfreq0 = td.C_0 / 0.75\narm1 = td.Structure(\n    geometry=td.Box(center=(0, 0, 0), size=(0.1, 0.75, 0.22)),\n    medium=td.Medium(permittivity=2.0),\n)\narm2 = td.Structure(\n    geometry=td.Box(center=(0, 0, 0), size=(0.75, 0.1, 0.22)),\n    medium=td.Medium(permittivity=2.0),\n)\nsource = td.PointDipole(\n    center=(-0.75, 0, 0),\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=freq0 / 10.0),\n    polarization=\"Ey\",\n)\nmonitor = td.FieldMonitor(\n    size=(td.inf, td.inf, 0),\n    freqs=[freq0],\n    name=\"fields\",\n    colocate=True,\n)\nsim = td.Simulation(\n    size=(2, 2, 3),\n    grid_spec=td.GridSpec.auto(min_steps_per_wvl=100),\n    structures=[arm1, arm2],\n    sources=[source],\n    monitors=[monitor],\n    run_time=120 / freq0,\n)\n\nsim.plot_eps(z=0)\n\ndevice = pf.read.from_tidy3d(tidy3d_sim=sim, eps_threshold=1.5, z=0)\ndevice.plot()\n\ndevice_p = device.predict(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True)\nstructure_p = device_p.to_tidy3d(eps0=2.0, thickness=1.5)\n\nsim_p = sim.updated_copy(structures=[structure_p])\nsim_p.plot_eps(z=0)\n</pre> import prefab as pf import tidy3d as td  freq0 = td.C_0 / 0.75 arm1 = td.Structure(     geometry=td.Box(center=(0, 0, 0), size=(0.1, 0.75, 0.22)),     medium=td.Medium(permittivity=2.0), ) arm2 = td.Structure(     geometry=td.Box(center=(0, 0, 0), size=(0.75, 0.1, 0.22)),     medium=td.Medium(permittivity=2.0), ) source = td.PointDipole(     center=(-0.75, 0, 0),     source_time=td.GaussianPulse(freq0=freq0, fwidth=freq0 / 10.0),     polarization=\"Ey\", ) monitor = td.FieldMonitor(     size=(td.inf, td.inf, 0),     freqs=[freq0],     name=\"fields\",     colocate=True, ) sim = td.Simulation(     size=(2, 2, 3),     grid_spec=td.GridSpec.auto(min_steps_per_wvl=100),     structures=[arm1, arm2],     sources=[source],     monitors=[monitor],     run_time=120 / freq0, )  sim.plot_eps(z=0)  device = pf.read.from_tidy3d(tidy3d_sim=sim, eps_threshold=1.5, z=0) device.plot()  device_p = device.predict(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True) structure_p = device_p.to_tidy3d(eps0=2.0, thickness=1.5)  sim_p = sim.updated_copy(structures=[structure_p]) sim_p.plot_eps(z=0) <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:10&lt;00:00,  9.26%/s]\n</pre> Out[20]: <pre>&lt;Axes: title={'center': 'cross section at z=0.00'}, xlabel='x', ylabel='y'&gt;</pre>"},{"location":"blog/prefab-v1.1.0/#prefab-v110","title":"PreFab v1.1.0\u00b6","text":"<p>PreFab v1.1.0 is now available! Install it via PyPI with the following command:</p> <pre>pip install --upgrade prefab\n</pre> <p>PreFab is a Python library designed to predict and correct nanofabrication variations in integrated photonic devices using advanced computer vision models. It helps enhance fabrication awareness and boosts efficiency in the design, fabrication, and testing of photonic circuits.</p>"},{"location":"blog/prefab-v1.1.0/#whats-new-with-us","title":"What's new with us\u00b6","text":"<p>PreFab is a new startup originating from McGill University in Montreal, Canada. As we continue to grow, we are eager to learn about your needs and how we can enhance our platform. Our team is small, so we appreciate your patience as we work on these improvements. Reach out to us at hi@prefabphotonics.com to work together.</p> <ul> <li><p>We have launched a new LinkedIn page here where we will announce new features and updates. Follow us to stay informed.</p> </li> <li><p>We've updated our logo to be less busy while retaining its original charm and essence. We hope you like the new design!</p> </li> </ul> <p></p>"},{"location":"blog/prefab-v1.1.0/#features","title":"Features\u00b6","text":"<p>This release brings a host of new features and enhancements to elevate your experience with PreFab. While our core functionality of predicting and correcting nanofabrication variations remains unchanged, we've added several valuable tools for working with nanostructure geometries.</p>"},{"location":"blog/prefab-v1.1.0/#shapes","title":"Shapes!\u00b6","text":"<p>While <code>read.from_gds</code> is used to import your GDS cells, the new <code>shapes</code> module allows you to create basic nanostructure devices directly. This feature is not only beneficial for our internal testing but also provides a convenient way for you to test PreFab models on simple geometries. Below are some examples.</p>"},{"location":"blog/prefab-v1.1.0/#gpu-acceleration","title":"GPU acceleration\u00b6","text":"<p>We've introduced GPU acceleration to the backend of PreFab by specifying <code>gpu=True</code> in <code>Device.predict</code> and <code>Device.correct</code>. This enhancement should speed up predictions for larger devices. As PreFab is a free service, CPU inference remains the default to keep the service readily available (\"hot\") for users. For now, the GPU will be in a \"cold\" state, requiring additional time to start up. Consequently, the first GPU prediction will be slower due to this overhead. We kindly ask that you use the GPU feature modestly (scouts' honor).</p>"},{"location":"blog/prefab-v1.1.0/#minimum-feature-size","title":"Minimum feature size\u00b6","text":"<p>We've added tools to check and enforce minimum feature sizes of devices you are working with. The <code>Device.check_feature_size</code> and <code>Device.enforce_feature_size</code> methods help ensure your designs meet sizing requirements. While these tools are not full design rule checking (DRC) solutions, we believe they can be useful early in the design process.</p>"},{"location":"blog/prefab-v1.1.0/#3d-structures","title":"3D structures\u00b6","text":"<p>We have introduced the <code>Device.to_3d</code> and <code>Device.to_stl</code> methods to convert your 2D device structures into 3D arrays or STL files. These features are particularly useful for simulating processes with angled sidewalls. For more details on working with angled sidewalls, refer to this notebook.</p> <p>The <code>Device.plot</code> method displays the upper and lower edges of the sidewall-angled device structure. These two new methods use the edges as boundaries for the 3D extrusion.</p>"},{"location":"blog/prefab-v1.1.0/#3rd-party-libraries","title":"3rd-party libraries\u00b6","text":"<p>PreFab should seamlessly fit into your existing design flow. As such, we're adding tools to read and write from/to common libraries such as Tidy3D and gdsfactory.</p> <p>This first example shows how to read a gdsfactory component, correct it using PreFab, and then convert it back to a gdsfactory component.</p>"},{"location":"blog/prefab-v1.1.0/#whats-next","title":"What's next\u00b6","text":"<p>We're excited about the future of PreFab and how we can help you gain more control over your nanofabrication process. Here are our key focus areas for the upcoming months:</p> <ul> <li>Performance Enhancements: We are implementing several improvements to accelerate predictions, particularly for larger devices.</li> <li>Expanding Model Library: We are adding more models to our platform. If you have a specific nanofabrication process in mind, please reach out to us!</li> <li>Innovative Usage Methods: We have exciting ideas to make PreFab even more powerful, particularly within the design optimization process. Look out for more updates on this front.</li> <li>Code Quality: We are working on improving the code quality of PreFab to make it more robust and easier to maintain. This will lay the foundation for future development and collaboration.</li> <li>Community Engagement: We value your input and are eager to hear your ideas and suggestions. Please reach out to us at support@prefabphotonics.com with your feedback.</li> </ul> <p>Thank you for your support, and happy designing!</p>"},{"location":"blog/2024/09/23/prefab-v110/","title":"PreFab v1.1.0","text":"<p>PreFab v1.1.0 is now available! Install it via PyPI with the following command:</p> <pre><code>pip install --upgrade prefab\n</code></pre> <p>PreFab is a Python library designed to predict and correct nanofabrication variations in integrated photonic devices using advanced computer vision models. It helps enhance fabrication awareness and boosts efficiency in the design, fabrication, and testing of photonic circuits.</p>"},{"location":"blog/2024/09/23/prefab-v110/#whats-new-with-us","title":"What's new with us","text":"<p>PreFab is a new startup originating from McGill University in Montreal, Canada. As we continue to grow, we are eager to learn about your needs and how we can enhance our platform. Our team is small, so we appreciate your patience as we work on these improvements. Reach out to us at hi@prefabphotonics.com to work together.</p> <ul> <li> <p>We have launched a new LinkedIn page here where we will announce new features and updates. Follow us to stay informed.</p> </li> <li> <p>We've updated our logo to be less busy while retaining its original charm and essence. We hope you like the new design!</p> </li> </ul> <p></p>"},{"location":"blog/2024/09/23/prefab-v110/#features","title":"Features","text":"<p>This release brings a host of new features and enhancements to elevate your experience with PreFab. While our core functionality of predicting and correcting nanofabrication variations remains unchanged, we've added several valuable tools for working with nanostructure geometries.</p>"},{"location":"blog/2024/09/23/prefab-v110/#shapes","title":"Shapes","text":"<p>While <code>read.from_gds</code> is used to import your GDS cells, the new <code>shapes</code> module allows you to create basic nanostructure devices directly. This feature is not only beneficial for our internal testing but also provides a convenient way for you to test PreFab models on simple geometries. Below are some examples.</p> <pre><code>import prefab as pf\n\ntarget = pf.shapes.target(width=500, arm_width=60)\ntarget.plot()\n\ngrating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=10)\ngrating.plot()\n\nradial_grating = pf.shapes.radial_grating(width=500, num_gratings=10)\nradial_grating.plot()\n</code></pre> <pre><code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"blog/2024/09/23/prefab-v110/#gpu-acceleration","title":"GPU acceleration","text":"<p>We've introduced GPU acceleration to the backend of PreFab by specifying <code>gpu=True</code> in <code>Device.predict</code> and <code>Device.correct</code>. This enhancement should speed up predictions for larger devices. As PreFab is a free service, CPU inference remains the default to keep the service readily available (\"hot\") for users. For now, the GPU will be in a \"cold\" state, requiring additional time to start up. Consequently, the first GPU prediction will be slower due to this overhead. We kindly ask that you use the GPU feature modestly (scouts' honor).</p> <pre><code>import time\n\nimport prefab as pf\n\ngrating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=200)\n\n# Timing the CPU correction\nstart_time = time.time()\ngrating_c_cpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=False)\ncpu_duration = time.time() - start_time\nprint(f\"CPU correction time: {cpu_duration:.2f} seconds\")\n\n# Timing the first GPU correction (cold start)\nstart_time = time.time()\ngrating_c_gpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True)\ngpu_duration = time.time() - start_time\nprint(f\"Cold GPU correction time: {gpu_duration:.2f} seconds\")\n\n# Timing the second GPU correction (hot start)\nstart_time = time.time()\ngrating_c_gpu2 = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True)\ngpu_duration2 = time.time() - start_time\nprint(f\"Hot GPU correction time: {gpu_duration2:.2f} seconds\")\n</code></pre> <pre><code>Correction: 100%|\u001b[32m\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u001b[0m| 100/100 [00:17&lt;00:00,  5.75%/s]\u001b[32m\u001b[0m\n\n\nCPU correction time: 17.68 seconds\n\n\nCorrection: 100%|\u001b[32m\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u001b[0m| 100/100 [00:08&lt;00:00, 12.39%/s]\u001b[32m\u001b[0m\n\n\nCold GPU correction time: 27.42 seconds\n\n\nCorrection: 100%|\u001b[32m\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u001b[0m| 100/100 [00:02&lt;00:00, 44.18%/s]\u001b[32m\u001b[0m\n\nHot GPU correction time: 2.47 seconds\n</code></pre>"},{"location":"blog/2024/09/23/prefab-v110/#minimum-feature-size","title":"Minimum feature size","text":"<p>We've added tools to check and enforce minimum feature sizes of devices you are working with. The <code>Device.check_feature_size</code> and <code>Device.enforce_feature_size</code> methods help ensure your designs meet sizing requirements. While these tools are not full design rule checking (DRC) solutions, we believe they can be useful early in the design process.</p> <pre><code>import prefab as pf\n\nstar = pf.shapes.star(width=500, num_points=4)\nstar.plot()\n\nstar.check_feature_size(min_feature_size=30, strel=\"disk\")\nstar_e = star.enforce_feature_size(min_feature_size=30, strel=\"disk\")\nstar_e.plot()\n</code></pre> <pre><code>Feature size check with minimum size 30 using 'disk' structuring element resulted in a Hamming distance of: 702\n\n\n\n\n\n&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"blog/2024/09/23/prefab-v110/#3d-structures","title":"3D structures","text":"<p>We have introduced the <code>Device.to_3d</code> and <code>Device.to_stl</code> methods to convert your 2D device structures into 3D arrays or STL files. These features are particularly useful for simulating processes with angled sidewalls. For more details on working with angled sidewalls, refer to this notebook.</p> <p>The <code>Device.plot</code> method displays the upper and lower edges of the sidewall-angled device structure. These two new methods use the edges as boundaries for the 3D extrusion.</p> <pre><code>import prefab as pf\n\ntarget = pf.shapes.target(width=1000, arm_width=200)\ntarget_p = target.predict(model=pf.models[\"ANT_SiN_ANF1_d1\"], binarize=True)\ntarget_p.plot()\n\ntarget_p_3d = target_p.to_3d(thickness_nm=400)  # visualizer to come soon\ntarget_p.to_stl(thickness_nm=400)  # this will create a 3D STL file you can inspect\n</code></pre> <pre><code>Prediction: 100%|\u001b[32m\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u001b[0m| 100/100 [00:04&lt;00:00, 22.84%/s]\u001b[32m\u001b[0m\n\n\nSaved Device to 'prefab_device.stl'\n</code></pre> <p></p>"},{"location":"blog/2024/09/23/prefab-v110/#3rd-party-libraries","title":"3rd-party libraries","text":"<p>PreFab should seamlessly fit into your existing design flow. As such, we're adding tools to read and write from/to common libraries such as Tidy3D and gdsfactory.</p> <p>This first example shows how to read a gdsfactory component, correct it using PreFab, and then convert it back to a gdsfactory component.</p> <pre><code>import gdsfactory as gf\nimport prefab as pf\n\ncomponent = gf.components.triangle(x=1, xtop=0, y=2, ybot=0, layer=\"WG\")\ncomponent.plot()\ndevice = pf.read.from_gdsfactory(component)\n\ndevice_c = device.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True)\ncomponent_c = device_c.to_gdsfactory()\ncomponent_c.plot()\n</code></pre> <pre><code>Correction: 100%|\u001b[32m\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u001b[0m| 100/100 [00:02&lt;00:00, 46.44%/s]\u001b[32m\u001b[0m\n</code></pre> <p></p> <p></p> <p>This second example shows how to read a Tidy3D simulation, correct the structure using PreFab, and then send it back to a Tidy3D simulation.</p> <pre><code>import prefab as pf\nimport tidy3d as td\n\nfreq0 = td.C_0 / 0.75\narm1 = td.Structure(\n    geometry=td.Box(center=(0, 0, 0), size=(0.1, 0.75, 0.22)),\n    medium=td.Medium(permittivity=2.0),\n)\narm2 = td.Structure(\n    geometry=td.Box(center=(0, 0, 0), size=(0.75, 0.1, 0.22)),\n    medium=td.Medium(permittivity=2.0),\n)\nsource = td.PointDipole(\n    center=(-0.75, 0, 0),\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=freq0 / 10.0),\n    polarization=\"Ey\",\n)\nmonitor = td.FieldMonitor(\n    size=(td.inf, td.inf, 0),\n    freqs=[freq0],\n    name=\"fields\",\n    colocate=True,\n)\nsim = td.Simulation(\n    size=(2, 2, 3),\n    grid_spec=td.GridSpec.auto(min_steps_per_wvl=100),\n    structures=[arm1, arm2],\n    sources=[source],\n    monitors=[monitor],\n    run_time=120 / freq0,\n)\n\nsim.plot_eps(z=0)\n\ndevice = pf.read.from_tidy3d(tidy3d_sim=sim, eps_threshold=1.5, z=0)\ndevice.plot()\n\ndevice_p = device.predict(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True)\nstructure_p = device_p.to_tidy3d(eps0=2.0, thickness=1.5)\n\nsim_p = sim.updated_copy(structures=[structure_p])\nsim_p.plot_eps(z=0)\n</code></pre> <pre><code>Prediction: 100%|\u001b[32m\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u001b[0m| 100/100 [00:10&lt;00:00,  9.26%/s]\u001b[32m\u001b[0m\n\n\n\n\n\n&lt;Axes: title={'center': 'cross section at z=0.00'}, xlabel='x', ylabel='y'&gt;\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"blog/2024/09/23/prefab-v110/#whats-next","title":"What's next","text":"<p>We're excited about the future of PreFab and how we can help you gain more control over your nanofabrication process. Here are our key focus areas for the upcoming months:</p> <ul> <li>Performance Enhancements: We are implementing several improvements to accelerate predictions, particularly for larger devices.</li> <li>Expanding Model Library: We are adding more models to our platform. If you have a specific nanofabrication process in mind, please reach out to us!</li> <li>Innovative Usage Methods: We have exciting ideas to make PreFab even more powerful, particularly within the design optimization process. Look out for more updates on this front.</li> <li>Code Quality: We are working on improving the code quality of PreFab to make it more robust and easier to maintain. This will lay the foundation for future development and collaboration.</li> <li>Community Engagement: We value your input and are eager to hear your ideas and suggestions. Please reach out to us at support@prefabphotonics.com with your feedback.</li> </ul> <p>Thank you for your support, and happy designing!</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/","title":"Python for Photonics Development","text":"<p>Python has become an indispensable tool in many technical fields, including ours. It gives researchers and engineers a versatile platform for simulating, modeling, and analyzing photonic systems, effectively streamlining the entire development workflow. With its extensive ecosystem of libraries and tools, Python enables efficient and innovative solutions in photonics that we think are worth exploring.</p> <p>In this guide, we'll walk you through setting up your Python development environment, introduce essential libraries, explore cloud and remote tools to leverage computational resources, share valuable settings for an enhanced coding experience, and provide additional tips to elevate your photonics projects using Python.</p> <p>Note</p> <p>PreFab is developed using Python, and we leverage many Python packages to enhance our development process. This guide is a compilation of resources and insights that have been beneficial in our work. While it's not exhaustive, we hope it proves useful to you in your photonics development endeavors.</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#essential-python-libraries-for-photonics","title":"Essential Python Libraries for Photonics","text":"<p>The Python ecosystem offers a variety of powerful tools specifically designed for photonics design and development. Here are some of the most notable ones:</p> <ul> <li> <p>Tidy3D: A commercial cloud-based FDTD solver for simulating electromagnetic fields in photonic structures, offering ultrahigh-speed simulations, an intuitive Python API, and incredible documentation and tutorials.</p> </li> <li> <p>Meep: An open-source software package for simulating electromagnetic systems using FDTD, with extensive Python bindings for scripting and automation. Meep also has fantastic documentation and tutorials to help you learn not just how to use the software, but also fundamentals of photonics and electromagnetics.</p> </li> <li> <p>gdsfactory: An industry-leading, open-source Python library for designing and automating photonic integrated circuits, facilitating layout generation, verification, and integration with simulation tools. If you are designing photonic integrated circuits with Python, this is a fantastic starting point.</p> </li> <li> <p>KLayout: KLayout is a versatile 2D viewer and editor for mask layouts in chip manufacturing. The KLayout Python module extends its functionality, allowing for scripting and automation within the KLayout system.</p> </li> <li> <p>gdstk: A Python library for creating and manipulating GDS files, supporting complex geometric operations essential for photonic design.</p> </li> <li> <p>Awesome Photonics: A curated GitHub repository compiling a comprehensive list of photonics tools and resources, many of which are Python-based or compatible with a Python-based workflow. This repository is an excellent starting point to discover new libraries, frameworks, and tools in the photonics domain.</p> </li> </ul>"},{"location":"blog/2024/10/10/python-for-photonics-development/#setting-up-your-integrated-development-environment-ide","title":"Setting up Your Integrated Development Environment (IDE)","text":"<p>Choosing the right Integrated Development Environment (IDE) is crucial for an efficient and productive workflow in photonics development. Here are three excellent options to consider:</p> <ul> <li> <p>Visual Studio Code (VS Code): Visual Studio Code is a free, open-source IDE developed by Microsoft. It's highly popular due to its versatility (much like Python) and extensive extension marketplace. VS Code offers powerful features like IntelliSense (smart code completion), debugging tools, Git integration, and customizable workspaces, making it an excellent choice for Python development.</p> </li> <li> <p>Cursor: Cursor is an enhanced version (fork) of VS Code, augmented with thoughtful AI tools that assist in code development. With integrated AI capabilities, Cursor can help you write, debug, and optimize your code more efficiently. It provides features like code autocompletion, intelligent code analysis, and automated code refactoring, making it a powerful tool for both beginners and experienced developers.</p> </li> <li> <p>Zed: Zed is a new, ultra-fast IDE that focuses on performance and a responsive coding experience. While it is still under active development and may have limited functionality and operating system support, Zed aims to provide a sleek and efficient environment for developers. Its emphasis on speed and minimalism could make it a strong contender as it matures. We recommend keeping a close eye on this IDE as it evolves.</p> </li> </ul> <p>For the rest of this guide, we will use VS Code (and therefore Cursor).</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#essential-vs-code-extensions-for-python-development","title":"Essential VS Code Extensions for Python Development","text":"<p>To further enhance your development experience in VS Code (or Cursor), add these essential extensions (see below for how to install them):</p> <ul> <li> <p>Python: The Python extension for VS Code provides rich support for the Python language, including features like IntelliSense, linting, debugging, code navigation, code formatting, and testing. It is maintained by Microsoft and is one of the most installed extensions for Python development.</p> </li> <li> <p>Jupyter: The Jupyter extension for VS Code allows you to work with Jupyter Notebooks directly within VS Code, offering an interactive environment for data analysis, visualization, and computational experimentation. We love Jupyter for rapidly prototyping and exploring new ideas, and this extension makes working with them in VS Code a pleasure.</p> </li> <li> <p>Ruff: The Ruff extension for VS Code is a fast, highly configurable linter (code quality check) and formatter for Python, designed to help you maintain code quality and adhere to coding standards. It is so fast that it can run in the background while you code, and it will notify you of any issues in your code as you save your file (which we will configure later in this guide). We also love Ruff because it is opinionated and enforces a consistent style guide, which can help you focus on what really matters and not waste precious development time on style choices.</p> </li> <li> <p>GitHub Theme: The GitHub Theme (Dark) for VS Code is a visually appealing theme that enhances the appearance of your editor, making it easier on the eyes (especially in the evening) and more enjoyable to work with. Even if you don't like this theme, we think it's a good idea to browse the marketplace and find a theme that you do like, making for a more pleasant coding experience under long hours of work.</p> </li> </ul>"},{"location":"blog/2024/10/10/python-for-photonics-development/#how-to-install-extensions","title":"How to Install Extensions","text":"<ol> <li> <p>Open VS Code: Launch Visual Studio Code on your computer.</p> </li> <li> <p>Access the Extensions View: Click on the Extensions icon in the Activity Bar on the side of the window or press <code>Ctrl+Shift+X</code> (<code>Cmd+Shift+X</code> on macOS).</p> </li> <li> <p>Search for Extensions: In the Extensions view, type the name of the extension you want to install (e.g., \"Python\", \"Jupyter\", \"Ruff\") in the search bar.</p> </li> <li> <p>Install the Extension: Click the <code>Install</code> button next to the extension in the search results.</p> </li> <li> <p>Reload if Necessary: Some extensions may require you to reload VS Code to activate them. If prompted, click the <code>Reload</code> button.</p> </li> </ol>"},{"location":"blog/2024/10/10/python-for-photonics-development/#useful-vs-code-settings","title":"Useful VS Code Settings","text":"<p>Optimizing your VS Code settings can enhance your coding efficiency and code quality. Below are some recommended settings tailored for Python development:</p> <p>Enable Format on Save for Python Files and Notebooks: Automatically format your code every time you save a file, both in Python scripts and Jupyter Notebooks.</p> <ul> <li>Go to <code>File</code> &gt; <code>Preferences</code> &gt; <code>Settings</code> (or press <code>Ctrl+,</code> on Windows/Linux or <code>Cmd+,</code> on macOS).</li> <li>Search for <code>Format On Save</code>.</li> <li>Check the box for <code>Editor: Format On Save</code>.</li> <li>Search for <code>Notebook: Format On Save</code>.</li> <li>Check the box for <code>Notebook: Format On Save</code>.</li> </ul> <p>Set Ruff as the Default Formatter for Python and Notebooks:</p> <ul> <li>Open your settings and search for <code>Editor: Default Formatter</code>.</li> <li>Select <code>Ruff</code> from the dropdown menu.</li> <li>Search for <code>Notebook: Default Formatter</code>.</li> <li>Set it to use <code>Ruff</code> for formatting code cells in Jupyter Notebooks.</li> </ul> <p>Success</p> <p>Now, with just a click of the save button, Ruff will automatically enhance the appearance and readability of your code.</p> <p>Configure Jupyter Startup Commands:</p> <ul> <li>These commands ensure that your notebook automatically reloads modules before executing code, which is helpful during development. This one has saved us many headaches in the early days of working with Python.</li> <li>Add the following setting to your <code>settings.json</code> file:</li> </ul> <pre><code>\"jupyter.runStartupCommands\": [\n  \"%load_ext autoreload\",\n  \"%autoreload 2\"\n],\n</code></pre> <p>Accessing the <code>settings.json</code> File:</p> <ul> <li>To open the <code>settings.json</code> file in VS Code:</li> <li>Go to <code>File</code> &gt; <code>Preferences</code> &gt; <code>Settings</code> (or press <code>Ctrl+,</code> on Windows/Linux or <code>Cmd+,</code> on macOS).</li> <li>In the Settings page, click on the Open Settings (JSON) icon (a document with a small arrow) in the upper-right corner. This will open the <code>settings.json</code> file where you can edit your settings directly.</li> <li>Alternatively, you can use the Command Palette:<ul> <li>Press <code>Ctrl+Shift+P</code> (<code>Cmd+Shift+P</code> on macOS) to open the Command Palette.</li> <li>Type <code>**Open User Settings (JSON)**</code> and select it from the list.</li> </ul> </li> </ul> <p>Example <code>settings.json</code> Entries:</p> <p>Replace or update your <code>settings.json</code> with the following entries:</p> <pre><code>{\n    \"editor\": {\n        \"formatOnSave\": true,\n        \"codeActionsOnSave\": {\n            \"source.fixAll\": \"explicit\",\n            \"source.organizeImports\": \"explicit\"\n        },\n        \"defaultFormatter\": \"charliermarsh.ruff\"\n    },\n    \"notebook\": {\n        \"formatOnSave\": {\n            \"enabled\": true\n        },\n        \"codeActionsOnSave\": {\n            \"notebook.source.fixAll\": true,\n            \"notebook.source.organizeImports\": true\n        },\n        \"defaultFormatter\": \"charliermarsh.ruff\"\n    },\n    \"jupyter.runStartupCommands\": [\n        \"%load_ext autoreload\",\n        \"%autoreload 2\"\n    ],\n}\n</code></pre> <p>Thought</p> <p>Customizing your IDE to suit your workflow\u2014including setting up keyboard shortcuts that work best for you\u2014can significantly improve your productivity and make your coding experience more enjoyable.</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#setting-up-your-python-virtual-environment","title":"Setting Up Your Python Virtual Environment","text":"<p>Creating a Python virtual environment is essential for managing dependencies and ensuring a clean development setup. It allows you to isolate your project's packages and Python version from other projects and the system-wide Python installation.</p> <p>We think it's a good idea to use a virtual environment manager to keep your global Python installation clean and to avoid conflicts between different projects.</p> <p>Here are three popular options for managing virtual environments:</p> <ul> <li> <p>Conda: Conda is a cross-platform package and environment manager that can handle both Python and non-Python dependencies, making it ideal for complex projects in scientific computing and data science. It supports creating isolated environments and includes its own package repositories.</p> </li> <li> <p>venv: The venv module is the built-in tool for creating virtual environments in Python 3. It's simple to use and comes pre-installed with Python, making it a convenient choice for managing environments with different packages or Python versions.</p> </li> <li> <p>uv: uv is a high-performance virtual environment manager created by Astral (the creators of Ruff). It offers rapid environment creation and management, aiming to be a minimalistic and efficient alternative to existing tools. Although still in its early stages, uv is designed to push the boundaries of performance and development ergonomics. We get inspired just by using it, and we think you will too.</p> </li> </ul> <p>For the rest of this tutorial, we will use Conda due to its popularity and robust feature set.</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#setting-up-conda","title":"Setting Up Conda","text":"<p>To set up a Python virtual environment using Conda, follow these steps:</p> <p>1. Install Conda</p> <p>If you don't have Conda installed, you can install either Anaconda or Miniconda. Miniconda is a minimal installer for Conda that includes only Conda and its dependencies.</p> <ul> <li> <p>Download Miniconda from the official website suitable for your operating system.</p> </li> <li> <p>Install Miniconda by running the installer and following the on-screen instructions.</p> </li> </ul> <p>2. Create a New Environment</p> <p>Open the integrated terminal in VS Code by going to <code>View</code> &gt; <code>Terminal</code> (or pressing <code>Ctrl+`</code> on Windows/Linux or <code>Cmd+`</code> on macOS). Use the following command to create a new Conda environment. Replace <code>myenv</code> with your desired environment name and <code>3.11</code> with the Python version you need.</p> <pre><code>conda create -n myenv python=3.11\n</code></pre> <p>3. Activate the Environment</p> <p>Activate your new environment with the following command:</p> <pre><code>conda activate myenv\n</code></pre> <p>4. Install Necessary Packages</p> <p>You can now install any packages you need using Conda or <code>pip</code>. For example, to install NumPy and SciPy, use:</p> <pre><code>conda install numpy scipy\n</code></pre> <p>Or, to install a package via <code>pip</code>:</p> <pre><code>pip install prefab\n</code></pre>"},{"location":"blog/2024/10/10/python-for-photonics-development/#selecting-the-conda-environment-in-vs-code","title":"Selecting the Conda Environment in VS Code","text":"<p>After setting up your Conda environment, you'll want to ensure that VS Code uses this environment for running and debugging your Python code and Jupyter Notebooks.</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#choosing-the-python-interpreter","title":"Choosing the Python Interpreter","text":"<p>1. Open a Python File:</p> <ul> <li>Open any Python file in VS Code or create a new one with the <code>.py</code> extension.</li> </ul> <p>2. Select the Interpreter:</p> <ul> <li> <p>Click on the Python version displayed in the bottom-right corner of the VS Code status bar. It might say something like <code>Python 3.x.x</code>.</p> </li> <li> <p>A list of available Python interpreters will appear. Look for your Conda environment in the list. It should be listed with the name you gave it (e.g., <code>myenv</code>) and the path to the Python executable.</p> </li> <li> <p>Select your Conda environment from the list.</p> </li> </ul> <p>3. Verify the Interpreter:</p> <ul> <li>Once selected, the status bar should update to reflect the interpreter from your Conda environment.</li> </ul>"},{"location":"blog/2024/10/10/python-for-photonics-development/#choosing-the-jupyter-kernel","title":"Choosing the Jupyter Kernel","text":"<p>When working with Jupyter Notebooks in VS Code, you need to select the appropriate kernel associated with your Conda environment.</p> <p>1. Open a Jupyter Notebook:</p> <ul> <li>Open an existing <code>.ipynb</code> file or create a new one in VS Code.</li> </ul> <p>2. Select the Kernel:</p> <ul> <li> <p>At the top-right corner of the notebook editor, you will see the kernel name (e.g., <code>Python 3</code>). Click on it to change the kernel.</p> </li> <li> <p>In the kernel selection dialog, you should see a list of available kernels. Your Conda environment should be listed, often with the name of the environment and the Python version.</p> </li> <li> <p>Select the kernel corresponding to your Conda environment.</p> </li> </ul> <p>3. Verify the Kernel:</p> <ul> <li>The kernel name should update to reflect the selected Conda environment.</li> </ul> <p>Troubleshooting:</p> <p>If your Conda environment's kernel doesn't appear in the list, you may need to install the <code>ipykernel</code> package in your environment:</p> <pre><code>conda activate myenv  # or the name of your environment\nconda install ipykernel\n</code></pre> <p>Alternatively, you can register the environment's kernel manually:</p> <pre><code>python -m ipykernel install --user --name=myenv\n</code></pre> <p>After installing the kernel, restart VS Code, and it should recognize the new kernel associated with your Conda environment.</p> <p>By selecting the correct Python interpreter and Jupyter kernel, you ensure that your code runs in the intended environment, using the packages and dependencies you've installed.</p> <p>Info</p> <p>And that's it! The rest of this guide will focus on additional tools and resources that can help you take your Python-based photonics development to the next level.</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#leveraging-cloud-and-remote-tools-for-computational-resources","title":"Leveraging Cloud and Remote Tools for Computational Resources","text":"<p>Photonics simulations and computations can be resource-intensive, often requiring significant computational power and specialized hardware. Leveraging cloud and remote tools allows you to access powerful computational resources without the need for expensive local hardware. Here are some platforms and tools that can help you take advantage of cloud computing:</p> <ul> <li> <p>Google Colab is a free cloud service (with some paid options) provided by Google that enables you to write and execute Python code through a web browser. It offers free access to GPUs and TPUs, allowing you to accelerate your simulations and computations using powerful hardware.</p> </li> <li> <p>GitHub Codespaces provides a full-fledged cloud-based development environment directly within GitHub. It allows you to develop in the cloud using a cloud-hosted VS Code environment that's configured for your project.</p> </li> <li> <p>Modal is a platform that allows you to run your code in the cloud with minimal setup. It provides serverless computing, enabling you to run functions and scripts without managing servers. We love Modal for how easy it is to leverage powerful compute without having to leave the local Python environment.</p> </li> <li> <p>Lambda Labs provides cloud GPU workstations and servers for deep learning and computational tasks. They offer powerful NVIDIA GPUs (though sometimes limited based on usage) and pre-configured environments with popular frameworks, saving setup time.</p> </li> <li> <p>SSH VS Code Extension allows you to develop remotely by connecting to remote servers in your organization or cloud instances (e.g., AWS, GCP, Lambda Labs) directly from your local VS Code editor.</p> </li> </ul>"},{"location":"blog/2024/10/10/python-for-photonics-development/#terminal-tools","title":"Terminal Tools","text":"<p>In addition to a good IDE, having the right terminal tools can offer nice benefits. Here are some useful command-line tools you may want to install:</p> <ul> <li> <p>Git is a distributed version control system that allows you to track changes in your code, collaborate with others, and manage different versions of your project. It's an indispensable tool for any developer, and we think it is an underrated tool for photonics development too. Although VS Code has a built-in Git client, using Git in the terminal can be more flexible. We recommend this video for a quick introduction on using Git.</p> </li> <li> <p>htop is an interactive process viewer for Linux and macOS systems. It provides a real-time view of system processes, CPU, and memory usage, making it especially easy to monitor remote compute instances.</p> </li> <li> <p>nvtop is like <code>htop</code> for NVIDIA GPUs. There are also many other <code>top</code>-like tools out there, so pick the one that best fits your system and workflow.</p> </li> <li> <p>Oh My Zsh is a popular shell framework that enhances the capabilities of the Zsh shell (which we also recommend using). It provides a rich set of plugins that make using the terminal much more powerful. If you find yourself using the terminal even just a little bit, this is a great tool to have.</p> </li> </ul>"},{"location":"blog/2024/10/10/python-for-photonics-development/#ai-coding-assistants","title":"AI Coding Assistants","text":"<p>AI-powered coding assistants have become invaluable tools for developers, whether you're just starting with Python or exploring new concepts in any field. These assistants offer real-time help, explanations, and code suggestions, making them excellent learning aids and productivity boosters.</p> <ul> <li> <p>ChatGPT: Developed by OpenAI, ChatGPT is the widely recognized (large) language model. They make improvements to their models and user interface regularly, so we recommend staying updated with its latest features to ensure you're utilizing the most advanced tools available.</p> </li> <li> <p>Claude: Claude, developed by Anthropic, is a competitor to ChatGPT. While benchmarking language models can be challenging (many believe Claude offers superior capabilities at least in some contexts), using multiple models from different providers (there are many others!) can help you obtain the best possible answers.</p> </li> <li> <p>Cursor: As previously mentioned, Cursor is an AI-enhanced IDE based on VS Code. One of its unique features is the ability to choose from multiple language models, helping you get the most accurate and helpful responses at any given time.</p> </li> <li> <p>GitHub Copilot: GitHub Copilot integrates seamlessly into VS Code, providing AI-assisted code completion and suggestions. While we believe Cursor offers superior features as an AI coding assistant, Copilot is a strong option if you prefer VS Code as your IDE.</p> </li> </ul> <p>There has been considerable discussion surrounding AI assistants, with both positive and negative viewpoints. However, when used pragmatically, these tools can enhance productivity. If you're not already using these tools, we strongly encourage you to consider doing so.</p>"},{"location":"blog/2024/10/10/python-for-photonics-development/#other-resources","title":"Other Resources","text":"<p>While AI coding assistants are a great starting point when you need help with code, there are numerous online communities and resources available to assist with more specialized problems that other developers may have already solved. Engaging with these communities can provide valuable insights and support.</p> <ul> <li> <p>Stack Overflow: A premier platform for getting help with specific coding issues. You can ask questions, share knowledge, and learn from the experiences of other developers.</p> </li> <li> <p>GitHub: Many photonics projects and libraries are hosted on GitHub. By engaging with repositories' issues and discussions, you can get direct support from developers and other users. Contributing to open-source projects or raising issues can also enhance your understanding and help improve the tools you use.</p> </li> <li> <p>\"Think Python: How to Think Like a Computer Scientist\" by Allen B. Downey: An excellent introduction to Python programming, focusing on developing a computational thinking mindset. Python is an evolving language, so older books might not cover everything you need. But this one is so elegantly organized and written that it's still a great resource.</p> </li> <li> <p>\"Effective Computation in Physics: Field Guide to Research with Python\" by Anthony Scopatz and Kathryn D. Huff: This guidebook covers Python in the context of scientific computing and physics research, making it particularly useful for photonics developers.</p> </li> <li> <p>\"Talk Python to Me\": A podcast that explores various topics in the Python ecosystem through interviews with experts and contributors. There is more to a language than just the syntax and libraries, and this podcast offers a great perspective on the language from the people who help shape it.</p> </li> </ul>"},{"location":"blog/2024/10/10/python-for-photonics-development/#whats-next","title":"What's Next","text":"<p>To further advance your photonics development journey with Python:</p> <ol> <li> <p>Explore Photonics Simulations: Experiment with examples from Meep and Tidy3D documentation to deepen your understanding of photonic simulations and computational electromagnetics.</p> </li> <li> <p>Contribute to Open-Source Projects: Get involved with projects like gdsfactory and SiEPIC. Contributing allows you to collaborate with others, improve existing tools, and engage with the photonics community.</p> </li> <li> <p>Develop Your Own Tools!: We can't wait to see what you build.</p> </li> </ol> <p>And of course, you can run our notebook examples on using virtual nanofabrication models to add fabrication-awareness to your photonics simulations and designs.</p>"},{"location":"examples/1_prediction/","title":"Making a prediction","text":"<p>This notebook offers an interactive tutorial on using PreFab to predict the fabrication result of a 500 nm-wide target nanostructure on a silicon-on-insulator (SOI) e-beam lithography process. This tutorial is structured as follows:</p> <ol> <li>Preparing a test device for prediction</li> <li>Executing a prediction</li> <li>Analyzing the prediction and uncertainty</li> </ol> <p>To begin, we need to import the necessary libraries:</p> In\u00a0[1]: Copied! <pre>import prefab as pf\n</pre> import prefab as pf <p>The first step involves preparing a device for prediction. <code>Device</code> is the base class that represents photonic design geometries in PreFab and can be instantiated by loading an image or GDS layout as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use a small target structure, but feel free to explore other structures available in the <code>shapes.py</code> module, or add your own.</p> In\u00a0[2]: Copied! <pre>device = pf.shapes.target(width=500, arm_width=60)\ndevice.plot(show_buffer=False)\n</pre> device = pf.shapes.target(width=500, arm_width=60) device.plot(show_buffer=False) Out[2]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>We proceed with the prediction of the device for a specific fabrication model. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for a library of available models.</p> <p>You can also select if you want a binarized output. The prediction model, by default, produces raw outputs, which includes \"fuzzy\" edges of the structure that may vary between different fabrication runs or even different device instances on the same chip. When binarized, the prediction model outputs the most probable fabrication outcome (i.e., a threshold of 50%). Post-prediction binarization is also an option, as we'll show here.</p> <p>Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> In\u00a0[15]: Copied! <pre>MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</pre> MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\" prediction = device.predict(model=pf.models[MODEL_NAME]) prediction_bin = prediction.binarize()  prediction.plot(show_buffer=False) prediction_bin.plot(show_buffer=False) <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 43.12%/s]\n</pre> Out[15]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>Comparing the (binary) prediction with the nominal device, we can observe erosion (or corner rounding, or over-etching) in the 60 nm-wide arms and convex corners of the target geometry. We also see dilation (or under-etching) for the concave corners in the center, as well as the complete filling of the center opening.</p> In\u00a0[16]: Copied! <pre>prediction_bin.plot_compare(ref_device=device, show_buffer=False)\n</pre> prediction_bin.plot_compare(ref_device=device, show_buffer=False) Out[16]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>To evaluate the quality of the prediction quantitatively, PreFab provides a function to compute the Intersection over Union (IoU) between the prediction and the nominal device. This metric measures the overlap between the two geometries, where 1.0 indicates a perfect match and 0.0 indicates no overlap.</p> In\u00a0[17]: Copied! <pre>print(\n    f\"Prediction IoU: {pf.compare.intersection_over_union(device, prediction_bin):.2f}\"\n)\n</pre> print(     f\"Prediction IoU: {pf.compare.intersection_over_union(device, prediction_bin):.2f}\" ) <pre>Prediction IoU: 0.83\n</pre> <p>83% is not great, but the feature size was demanding. Try other values for <code>arm_width</code> and see how it affects the results.</p> <p>We can further visualize and understand the prediction by highlighting the \"fuzzy\" edge regions. This is a measure of the uncertainty of the prediction model due to stochastic variance in the fabrication process and the modelling process. From device-to-device, run-to-run, the device edge may lie anywhere in this uncertainty region. Although PreFab cannot correct for uncertainty, visualizing it is valuable in identifying features with high variance.</p> In\u00a0[18]: Copied! <pre>prediction.plot_uncertainty(show_buffer=False)\n</pre> prediction.plot_uncertainty(show_buffer=False) Out[18]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>And that's it! See the next example to learn how to restore this nanostructure using PreFab's correction capabilities.</p>"},{"location":"examples/1_prediction/#making-a-prediction","title":"Making a prediction\u00b6","text":""},{"location":"examples/1_prediction/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/1_prediction/#loading-a-device","title":"Loading a device\u00b6","text":""},{"location":"examples/1_prediction/#predicting-a-device","title":"Predicting a device\u00b6","text":""},{"location":"examples/1_prediction/#analyzing-a-prediction","title":"Analyzing a prediction\u00b6","text":""},{"location":"examples/2_correction/","title":"Making a correction","text":"<p>This notebook offers an interactive tutorial on using PreFab to correct the fabrication result of the same 500 nm-wide target nanostructure used in the previous prediction example. This tutorial is structured as follows:</p> <ol> <li>Preparing a test device for correction</li> <li>Executing a correction</li> <li>Making a prediction of the correction</li> </ol> <p>To begin, we need to import the necessary libraries:</p> In\u00a0[1]: Copied! <pre>import prefab as pf\n</pre> import prefab as pf <p>The first step involves preparing a device for correction. <code>Device</code> is the base class that represents photonic design geometries in PreFab and can be instantiated by loading an image or GDS layout as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use a small target structure, but feel free to explore other structures available in the <code>shapes.py</code> module, or add your own.</p> In\u00a0[2]: Copied! <pre>device = pf.shapes.target(width=500, arm_width=60)\ndevice.plot(show_buffer=False)\n</pre> device = pf.shapes.target(width=500, arm_width=60) device.plot(show_buffer=False) Out[2]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>We proceed with the correction of the device for a specific fabrication model. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for a library of available models.</p> <p>Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> In\u00a0[7]: Copied! <pre>MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\"\ncorrection = device.correct(model=pf.models[MODEL_NAME])\ncorrection.plot(show_buffer=False)\n</pre> MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\" correction = device.correct(model=pf.models[MODEL_NAME]) correction.plot(show_buffer=False) <pre>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 83.13%/s]\n</pre> Out[7]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>The corrector compensates for expected fabrication errors by adjusting the design. It adds silicon in places where it predicts erosion and removes silicon where it predicts dilation.</p> In\u00a0[8]: Copied! <pre>correction.plot_compare(ref_device=device, show_buffer=False)\n</pre> correction.plot_compare(ref_device=device, show_buffer=False) Out[8]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>We then predict the nanofabrication outcome for the corrected target structure by using the prediction model again.</p> <p>In the corrected design, the corners are expected to be sharper and the middle opening is better resolved compared to the nominal design. Additionally, the Intersection over Union score is improved from 83% to 98%! This means that the corrected design will more closely match the intended design, leading to better fabrication outcomes and better chips.</p> In\u00a0[9]: Copied! <pre>outcome = correction.predict(model=pf.models[MODEL_NAME])\noutcome_bin = outcome.binarize()\n\noutcome.plot(show_buffer=False)\noutcome_bin.plot(show_buffer=False)\noutcome_bin.plot_compare(ref_device=device, show_buffer=False)\n</pre> outcome = correction.predict(model=pf.models[MODEL_NAME]) outcome_bin = outcome.binarize()  outcome.plot(show_buffer=False) outcome_bin.plot(show_buffer=False) outcome_bin.plot_compare(ref_device=device, show_buffer=False) <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 41.95%/s]\n</pre> Out[9]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> In\u00a0[10]: Copied! <pre>print(f\"Corrected IoU: {pf.compare.intersection_over_union(device, outcome_bin):.2f}\")\n</pre> print(f\"Corrected IoU: {pf.compare.intersection_over_union(device, outcome_bin):.2f}\") <pre>Corrected IoU: 0.98\n</pre> <p>While it may not always be possible to fully restore the original design to 100%, achieving this is our goal. We encourage you to stay up-to-date with our latest models, as we are continually striving to improve.</p>"},{"location":"examples/2_correction/#making-a-correction","title":"Making a correction\u00b6","text":""},{"location":"examples/2_correction/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/2_correction/#loading-a-device","title":"Loading a device\u00b6","text":""},{"location":"examples/2_correction/#correcting-a-device","title":"Correcting a device\u00b6","text":""},{"location":"examples/2_correction/#making-a-prediction-of-the-correction","title":"Making a prediction of the correction\u00b6","text":""},{"location":"examples/3_sidewall_angle/","title":"Working with sidewall angles","text":"<p>This notebook uses PreFab to predict and correct the fabrication result of a 400 nm-wide ring nanostructure on a silicon nitride (SiN) e-beam lithography process that has angled sidewalls. This tutorial is structured as follows:</p> <ol> <li>Preparing a test device for prediction</li> <li>Executing a prediction</li> <li>Analyzing the prediction and uncertainty</li> <li>Correcting the device and discussion of sidewall angles</li> </ol> <p>To begin, we need to import the necessary libraries:</p> In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport prefab as pf\n</pre> import matplotlib.pyplot as plt import prefab as pf <p>In this tutorial, we'll use a small ring structure, but feel free to explore other structures available in the <code>shapes.py</code> module, or load your own from a GDS file.</p> In\u00a0[34]: Copied! <pre>device = pf.shapes.ring(width=400, border_width=100)\ndevice.plot(show_buffer=False)\n</pre> device = pf.shapes.ring(width=400, border_width=100) device.plot(show_buffer=False) Out[34]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>The prediction process is similar to previous notebook examples, but we'll use a model trained on SiN structures with angled sidewalls. This model outputs three segments: core (yellow), sidewall of the core (green), and cladding (purple), unlike the previous examples' models which had only core and cladding (indicating a vertical sidewall).</p> <p>Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> In\u00a0[35]: Copied! <pre>MODEL_NAME = \"ANT_SiN_ANF1_d1\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</pre> MODEL_NAME = \"ANT_SiN_ANF1_d1\" prediction = device.predict(model=pf.models[MODEL_NAME]) prediction_bin = prediction.binarize()  prediction.plot(show_buffer=False) prediction_bin.plot(show_buffer=False) <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:06&lt;00:00, 16.13%/s]\n</pre> Out[35]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>The model outputs an NxMx2 array, where the third dimension represents the top and bottom edges of the structure. We can visualize these edges separately using the <code>level</code> parameter.</p> In\u00a0[13]: Copied! <pre>prediction.plot(level=0, show_buffer=False)\nprediction.plot(level=1, show_buffer=False)\n</pre> prediction.plot(level=0, show_buffer=False) prediction.plot(level=1, show_buffer=False)  Out[13]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>We can overlay the contour of the nominal device on the prediction to visualize the differences between the nominal and predicted geometries. This comparison reveals significant erosion at the top level or edge, and shows that the outer sidewall is wider than the inner sidewall, indicating a non-uniform, feature-dependent sidewall angle.</p> In\u00a0[36]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(10, 5))\nprediction_bin.plot(show_buffer=False, ax=ax)\ndevice.plot_contour(show_buffer=False, ax=ax)\nplt.show()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(10, 5)) prediction_bin.plot(show_buffer=False, ax=ax) device.plot_contour(show_buffer=False, ax=ax) plt.show() <p>Likewise, each edge carries its own level of uncertainty. We are still investigating the relationship between edge uncertainty and sidewall angle, and how they vary from device to device and fabrication run to run. The less these uncertainties overlap with the optical signal, the more robust the device will be to fabrication variations.</p> In\u00a0[37]: Copied! <pre>prediction.plot_uncertainty(show_buffer=False)\n</pre> prediction.plot_uncertainty(show_buffer=False) Out[37]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>The sidewall angle is a result of the etching process and cannot be corrected through lithography adjustments. However, we can compensate for the sidewall angle by ensuring the half-width of the sidewall region matches the nominal width. By overlaying the contour of the nominal device on the corrected outcome, we can see that the corrector model has successfully compensated for the sidewall angle.</p> <p>This method helps maintain a consistent effective volume and index profile, minimizing performance degradation. Research is ongoing to verify different sidewall-angle compensation strategies. Other factors to consider include the height of the core region and the linearity of the sidewall.</p> In\u00a0[39]: Copied! <pre>MODEL_NAME = \"ANT_SiN_ANF1_d1\"\ncorrection = device.correct(model=pf.models[MODEL_NAME])\noutcome = correction.predict(model=pf.models[MODEL_NAME])\noutcome_bin = outcome.binarize()\n\ncorrection.plot(show_buffer=False)\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\noutcome_bin.plot(show_buffer=False, ax=ax)\ndevice.plot_contour(show_buffer=False, ax=ax)\nplt.show()\n</pre> MODEL_NAME = \"ANT_SiN_ANF1_d1\" correction = device.correct(model=pf.models[MODEL_NAME]) outcome = correction.predict(model=pf.models[MODEL_NAME]) outcome_bin = outcome.binarize()  correction.plot(show_buffer=False)  fig, ax = plt.subplots(1, 1, figsize=(10, 5)) outcome_bin.plot(show_buffer=False, ax=ax) device.plot_contour(show_buffer=False, ax=ax) plt.show() <pre>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 78.78%/s]\nPrediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 39.85%/s]\n</pre> <p>Feel free to try different structures and settings to see how they affect your designs. Thanks for following along!</p>"},{"location":"examples/3_sidewall_angle/#working-with-sidewall-angles","title":"Working with sidewall angles\u00b6","text":""},{"location":"examples/3_sidewall_angle/#introduction","title":"Introduction\u00b6","text":""},{"location":"examples/3_sidewall_angle/#loading-a-device","title":"Loading a device\u00b6","text":""},{"location":"examples/3_sidewall_angle/#predicting-a-device","title":"Predicting a device\u00b6","text":""},{"location":"examples/3_sidewall_angle/#analyzing-a-prediction","title":"Analyzing a prediction\u00b6","text":""},{"location":"examples/3_sidewall_angle/#correction","title":"Correction\u00b6","text":""},{"location":"examples/4_SEM_generation/","title":"Generating SEM-like images","text":"In\u00a0[1]: Copied! <pre>import prefab as pf\n</pre> import prefab as pf <p>In this tutorial, we'll use an L-grating structure, but feel free to explore other structures available in the <code>shapes</code> module, or load your own from a GDS file.</p> In\u00a0[2]: Copied! <pre>device = pf.shapes.l_grating(height=500, pitch=90)\ndevice.plot(show_buffer=False)\n</pre> device = pf.shapes.l_grating(height=500, pitch=90) device.plot(show_buffer=False) Out[2]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>We'll run our prediction just like we did in the previous tutorial. Note how the small gaps between the L-grating arms are highly uncertain in the raw prediction and get partially filled in by the binarization step. As expected, there is also significant rounding at the corners of the L-grating arms.</p> <p>Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> In\u00a0[35]: Copied! <pre>MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</pre> MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\" prediction = device.predict(model=pf.models[MODEL_NAME]) prediction_bin = prediction.binarize()  prediction.plot(show_buffer=False) prediction_bin.plot(show_buffer=False) <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 44.07%/s]\n</pre> Out[35]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>We are exploring a feature that uses varying threshold levels around the edges of the prediction. Although this method is not yet fully validated, it shows promise in producing more realistic images that display bumps and roughness along the sidewalls of the fabricated devices. While this is primarily for aesthetic purposes in this tutorial, we believe it will be useful in assessing the robustness to edge defects in the fabrication process. This is an active area of research, and we welcome any feedback and suggestions.</p> In\u00a0[49]: Copied! <pre>prediction_bin_rng = prediction.binarize_monte_carlo(noise_magnitude=2, blur_radius=10)\nprediction_bin_rng.plot(show_buffer=False)\n</pre> prediction_bin_rng = prediction.binarize_monte_carlo(noise_magnitude=2, blur_radius=10) prediction_bin_rng.plot(show_buffer=False) Out[49]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>Lastly, we can generate an SEM-like image of the randomly thresholded prediction using the <code>semulate</code> method and specifying the artificial nanofabrication model for the process we used to create the prediction.</p> In\u00a0[50]: Copied! <pre>sem = prediction_bin_rng.semulate(pf.models[\"ANT_NanoSOI_ANF1_d10\"])\nsem.plot(show_buffer=False, cmap=\"gray\")\n</pre> sem = prediction_bin_rng.semulate(pf.models[\"ANT_NanoSOI_ANF1_d10\"]) sem.plot(show_buffer=False, cmap=\"gray\") <pre>SEMulate: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 37.29%/s]\n</pre> Out[50]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>Of course, SEM styling is influenced by various factors, including the fabrication process, the specific SEM equipment used, and the expertise of the operator. While these generated images are not intended to replace actual SEM imaging, they demonstrate a compelling alternative application of our computer vision models.</p>"},{"location":"examples/4_SEM_generation/#generating-sem-like-images","title":"Generating SEM-like images\u00b6","text":""},{"location":"examples/4_SEM_generation/#introduction","title":"Introduction\u00b6","text":"<p>This notebook shows how our computer vision models can be used to generate (SEMulate) SEM-like images of the predicted device geometries. Unlike the other notebook examples in our docs, there is no utility here, but it is a fun application of our computer vision models. We'll go through the following steps:</p> <ol> <li>Preparing a test device for prediction</li> <li>Executing a prediction</li> <li>Generating an SEM-like image</li> </ol> <p>To begin, we need to import the necessary libraries:</p>"},{"location":"examples/4_SEM_generation/#loading-a-device","title":"Loading a device\u00b6","text":""},{"location":"examples/4_SEM_generation/#predicting-a-device","title":"Predicting a device\u00b6","text":""},{"location":"examples/4_SEM_generation/#generating-an-sem-like-image","title":"Generating an SEM-like image\u00b6","text":""},{"location":"examples/5_prediction_simulation/","title":"Simulating device predictions","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pylab as plt\nimport numpy as np\nimport tidy3d as td\n\nimport prefab as pf\n</pre> import matplotlib.pylab as plt import numpy as np import tidy3d as td  import prefab as pf In\u00a0[2]: Copied! <pre># materials\nAir = td.Medium(permittivity=1.0)\nSi = td.Medium(permittivity=3.47**2)\nSiO2 = td.Medium(permittivity=1.44**2)\n\n# geometric parameters\nwg_height = 0.22\nwg_feed_length = 0.75\nwg_feed_width = 0.5\ncorrug_width = 0.05\nnum_periods = 100\nperiod = 0.324\n\nshift = period / 2\ncorrug_length = period / 2\nwg_length = num_periods * period\nwg_width = wg_feed_width - corrug_width\n\nwavelength0 = 1.532\nfreq0 = td.C_0 / wavelength0\nfwidth = freq0 / 40.0\nrun_time = 5.0e-12\nwavelength_min = td.C_0 / (freq0 + fwidth)\n\n# place the two waveguides with their centres half a free-space wavelength apart\nwg1_y = wavelength0 / 2\nwg2_y = -wavelength0 / 2\n\n# waveguide 1\nwg1_size = [td.inf, wg_width, wg_height]\nwg1_center = [0, wg1_y, wg_height / 2]\nwg1_medium = Si\n\n# waveguide 2\nwg2_size = [td.inf, wg_width, wg_height]\nwg2_center = [0, wg2_y, wg_height / 2]\nwg2_medium = Si\n\n# corrugation setup for waveguide 1\ncg1_size = [corrug_length, corrug_width, wg_height]\ncg1_center_plus = [\n    -wg_length / 2 + corrug_length / 2,\n    wg_width / 2 + corrug_width / 2 + wg1_y,\n    wg_height / 2,\n]\ncg1_center_minus = [\n    -wg_length / 2 + corrug_length / 2,\n    -wg_width / 2 - corrug_width / 2 + wg1_y,\n    wg_height / 2,\n]\ncg1_medium = Si\n\n# corrugation setup for waveguide 2\ncg2_size = [corrug_length, corrug_width, wg_height]\ncg2_center_plus = [\n    -wg_length / 2 + corrug_length / 2,\n    wg_width / 2 + corrug_width / 2 + wg2_y,\n    wg_height / 2,\n]\ncg2_center_minus = [\n    -wg_length / 2 + corrug_length / 2 + shift,\n    -wg_width / 2 - corrug_width / 2 + wg2_y,\n    wg_height / 2,\n]\ncg2_medium = Si\n\n# substrate\nsub_size = [td.inf, td.inf, 2]\nsub_center = [0, 0, -1.0]\nsub_medium = SiO2\n\n# create the substrate\nsubstrate = td.Structure(\n    geometry=td.Box(center=sub_center, size=sub_size),\n    medium=sub_medium,\n    name=\"substrate\",\n)\n\n# create the first waveguide\nwaveguide_1 = td.Structure(\n    geometry=td.Box(center=wg1_center, size=wg1_size),\n    medium=wg1_medium,\n    name=\"waveguide_1\",\n)\n\n# create the second waveguide\nwaveguide_2 = td.Structure(\n    geometry=td.Box(center=wg2_center, size=wg2_size),\n    medium=wg2_medium,\n    name=\"waveguide_2\",\n)\n\n# create the corrugation for the first waveguide\ncorrug1_plus = []\ncorrug1_minus = []\nfor i in range(num_periods):\n    # corrugation on the +y side\n    center = cg1_center_plus\n    if i &gt; 0:\n        center[0] += period\n    plus = td.Structure(\n        geometry=td.Box(center=center, size=cg1_size),\n        medium=cg1_medium,\n        name=f\"corrug1_plus_{i}\",\n    )\n\n    # corrugation on the -y side\n    center = cg1_center_minus\n    if i &gt; 0:\n        center[0] += period\n    minus = td.Structure(\n        geometry=td.Box(center=center, size=cg1_size),\n        medium=cg1_medium,\n        name=f\"corrug1_minus_{i}\",\n    )\n\n    corrug1_plus.append(plus)\n    corrug1_minus.append(minus)\n\n# create the corrugation for the second waveguide\ncorrug2_plus = []\ncorrug2_minus = []\nfor i in range(num_periods):\n    # corrugation on the +y side\n    center = cg2_center_plus\n    if i &gt; 0:\n        center[0] += period\n    plus = td.Structure(\n        geometry=td.Box(center=center, size=cg2_size),\n        medium=cg2_medium,\n        name=f\"corrug2_plus_{i}\",\n    )\n\n    # corrugation on the -y side\n    center = cg2_center_minus\n    if i &gt; 0:\n        center[0] += period\n    minus = td.Structure(\n        geometry=td.Box(center=center, size=cg2_size),\n        medium=cg2_medium,\n        name=f\"corrug2_minus_{i}\",\n    )\n\n    corrug2_plus.append(plus)\n    corrug2_minus.append(minus)\n\n# full simulation domain\nsim_size = [\n    wg_length + wavelength0 * 1.5,\n    2 * wavelength0 + wg_width + 2 * corrug_width,\n    3.7,\n]\nsim_center = [0, 0, 0.0]\n\n# boundary conditions - Bloch boundaries are used to emulate an infinitely long grating\nboundary_spec = td.BoundarySpec(\n    # x=td.Boundary.bloch(bloch_vec=num_periods/2),\n    x=td.Boundary.pml(),\n    y=td.Boundary.pml(),\n    z=td.Boundary.pml(),\n)\n\n# grid specification\ngrid_spec = td.GridSpec.auto(min_steps_per_wvl=20)\n</pre> # materials Air = td.Medium(permittivity=1.0) Si = td.Medium(permittivity=3.47**2) SiO2 = td.Medium(permittivity=1.44**2)  # geometric parameters wg_height = 0.22 wg_feed_length = 0.75 wg_feed_width = 0.5 corrug_width = 0.05 num_periods = 100 period = 0.324  shift = period / 2 corrug_length = period / 2 wg_length = num_periods * period wg_width = wg_feed_width - corrug_width  wavelength0 = 1.532 freq0 = td.C_0 / wavelength0 fwidth = freq0 / 40.0 run_time = 5.0e-12 wavelength_min = td.C_0 / (freq0 + fwidth)  # place the two waveguides with their centres half a free-space wavelength apart wg1_y = wavelength0 / 2 wg2_y = -wavelength0 / 2  # waveguide 1 wg1_size = [td.inf, wg_width, wg_height] wg1_center = [0, wg1_y, wg_height / 2] wg1_medium = Si  # waveguide 2 wg2_size = [td.inf, wg_width, wg_height] wg2_center = [0, wg2_y, wg_height / 2] wg2_medium = Si  # corrugation setup for waveguide 1 cg1_size = [corrug_length, corrug_width, wg_height] cg1_center_plus = [     -wg_length / 2 + corrug_length / 2,     wg_width / 2 + corrug_width / 2 + wg1_y,     wg_height / 2, ] cg1_center_minus = [     -wg_length / 2 + corrug_length / 2,     -wg_width / 2 - corrug_width / 2 + wg1_y,     wg_height / 2, ] cg1_medium = Si  # corrugation setup for waveguide 2 cg2_size = [corrug_length, corrug_width, wg_height] cg2_center_plus = [     -wg_length / 2 + corrug_length / 2,     wg_width / 2 + corrug_width / 2 + wg2_y,     wg_height / 2, ] cg2_center_minus = [     -wg_length / 2 + corrug_length / 2 + shift,     -wg_width / 2 - corrug_width / 2 + wg2_y,     wg_height / 2, ] cg2_medium = Si  # substrate sub_size = [td.inf, td.inf, 2] sub_center = [0, 0, -1.0] sub_medium = SiO2  # create the substrate substrate = td.Structure(     geometry=td.Box(center=sub_center, size=sub_size),     medium=sub_medium,     name=\"substrate\", )  # create the first waveguide waveguide_1 = td.Structure(     geometry=td.Box(center=wg1_center, size=wg1_size),     medium=wg1_medium,     name=\"waveguide_1\", )  # create the second waveguide waveguide_2 = td.Structure(     geometry=td.Box(center=wg2_center, size=wg2_size),     medium=wg2_medium,     name=\"waveguide_2\", )  # create the corrugation for the first waveguide corrug1_plus = [] corrug1_minus = [] for i in range(num_periods):     # corrugation on the +y side     center = cg1_center_plus     if i &gt; 0:         center[0] += period     plus = td.Structure(         geometry=td.Box(center=center, size=cg1_size),         medium=cg1_medium,         name=f\"corrug1_plus_{i}\",     )      # corrugation on the -y side     center = cg1_center_minus     if i &gt; 0:         center[0] += period     minus = td.Structure(         geometry=td.Box(center=center, size=cg1_size),         medium=cg1_medium,         name=f\"corrug1_minus_{i}\",     )      corrug1_plus.append(plus)     corrug1_minus.append(minus)  # create the corrugation for the second waveguide corrug2_plus = [] corrug2_minus = [] for i in range(num_periods):     # corrugation on the +y side     center = cg2_center_plus     if i &gt; 0:         center[0] += period     plus = td.Structure(         geometry=td.Box(center=center, size=cg2_size),         medium=cg2_medium,         name=f\"corrug2_plus_{i}\",     )      # corrugation on the -y side     center = cg2_center_minus     if i &gt; 0:         center[0] += period     minus = td.Structure(         geometry=td.Box(center=center, size=cg2_size),         medium=cg2_medium,         name=f\"corrug2_minus_{i}\",     )      corrug2_plus.append(plus)     corrug2_minus.append(minus)  # full simulation domain sim_size = [     wg_length + wavelength0 * 1.5,     2 * wavelength0 + wg_width + 2 * corrug_width,     3.7, ] sim_center = [0, 0, 0.0]  # boundary conditions - Bloch boundaries are used to emulate an infinitely long grating boundary_spec = td.BoundarySpec(     # x=td.Boundary.bloch(bloch_vec=num_periods/2),     x=td.Boundary.pml(),     y=td.Boundary.pml(),     z=td.Boundary.pml(), )  # grid specification grid_spec = td.GridSpec.auto(min_steps_per_wvl=20) <p>A mode source is defined for each waveguide.</p> In\u00a0[3]: Copied! <pre># mode source for waveguide 1\nsource1_time = td.GaussianPulse(freq0=freq0, fwidth=fwidth, amplitude=1)\nmode_src1 = td.ModeSource(\n    center=[-wg_length / 2 - period, wg1_y, wg_height / 2],\n    size=[0, waveguide_1.geometry.size[1] * 2, waveguide_1.geometry.size[2] * 2],\n    mode_index=0,\n    direction=\"+\",\n    source_time=source1_time,\n    mode_spec=td.ModeSpec(),\n)\n\n# mode source for waveguide 2\nsource2_time = td.GaussianPulse(freq0=freq0, fwidth=fwidth, amplitude=1)\nmode_src2 = td.ModeSource(\n    center=[-wg_length / 2 - period, wg2_y, wg_height / 2],\n    size=[0, waveguide_2.geometry.size[1] * 2, waveguide_2.geometry.size[2] * 2],\n    mode_index=0,\n    direction=\"+\",\n    source_time=source2_time,\n    mode_spec=td.ModeSpec(),\n)\n</pre> # mode source for waveguide 1 source1_time = td.GaussianPulse(freq0=freq0, fwidth=fwidth, amplitude=1) mode_src1 = td.ModeSource(     center=[-wg_length / 2 - period, wg1_y, wg_height / 2],     size=[0, waveguide_1.geometry.size[1] * 2, waveguide_1.geometry.size[2] * 2],     mode_index=0,     direction=\"+\",     source_time=source1_time,     mode_spec=td.ModeSpec(), )  # mode source for waveguide 2 source2_time = td.GaussianPulse(freq0=freq0, fwidth=fwidth, amplitude=1) mode_src2 = td.ModeSource(     center=[-wg_length / 2 - period, wg2_y, wg_height / 2],     size=[0, waveguide_2.geometry.size[1] * 2, waveguide_2.geometry.size[2] * 2],     mode_index=0,     direction=\"+\",     source_time=source2_time,     mode_spec=td.ModeSpec(), ) <p>To visualize the field distribution in the waveguides, a monitor is placed in the <code>xy</code> plane cutting through both waveguides. A pair of flux monitors is also placed on the far side the demonstrate the transmission and reflection characteristics.</p> In\u00a0[4]: Copied! <pre># create monitors\nmonitor_xy = td.FieldMonitor(\n    center=[0, 0, wg_height / 2],\n    size=[wg_length, 2 * wavelength0 + wg_width + 2 * corrug_width, 0],\n    freqs=[freq0],\n    name=\"fields_xy\",\n)\n\nfreqs = np.linspace(freq0 - 2 * fwidth, freq0 + 2 * fwidth, 200)\nmonitor_flux_aligned = td.FluxMonitor(\n    center=[wg_length / 2 + period, wg1_y, wg_height / 2],\n    size=[0, waveguide_1.geometry.size[1] * 3, waveguide_1.geometry.size[2] * 5],\n    freqs=freqs,\n    name=\"flux_aligned\",\n)\n\nmonitor_flux_misaligned = td.FluxMonitor(\n    center=[wg_length / 2 + period, wg2_y, wg_height / 2],\n    size=[0, waveguide_2.geometry.size[1] * 3, waveguide_2.geometry.size[2] * 5],\n    freqs=freqs,\n    name=\"flux_misaligned\",\n)\n</pre> # create monitors monitor_xy = td.FieldMonitor(     center=[0, 0, wg_height / 2],     size=[wg_length, 2 * wavelength0 + wg_width + 2 * corrug_width, 0],     freqs=[freq0],     name=\"fields_xy\", )  freqs = np.linspace(freq0 - 2 * fwidth, freq0 + 2 * fwidth, 200) monitor_flux_aligned = td.FluxMonitor(     center=[wg_length / 2 + period, wg1_y, wg_height / 2],     size=[0, waveguide_1.geometry.size[1] * 3, waveguide_1.geometry.size[2] * 5],     freqs=freqs,     name=\"flux_aligned\", )  monitor_flux_misaligned = td.FluxMonitor(     center=[wg_length / 2 + period, wg2_y, wg_height / 2],     size=[0, waveguide_2.geometry.size[1] * 3, waveguide_2.geometry.size[2] * 5],     freqs=freqs,     name=\"flux_misaligned\", ) <p>All the structures, sources, and monitors are consolidated, and the simulation is created and visualized.</p> In\u00a0[5]: Copied! <pre># list of all structures\nstructures = (\n    [substrate, waveguide_1, waveguide_2]\n    + corrug1_plus\n    + corrug1_minus\n    + corrug2_plus\n    + corrug2_minus\n)\n\n# list of all sources\nsources = [mode_src1, mode_src2]\n\n# list of all monitors\nmonitors = [monitor_xy, monitor_flux_aligned, monitor_flux_misaligned]\n\n# create the simulation\nsim = td.Simulation(\n    center=sim_center,\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=structures,\n    sources=sources,\n    monitors=monitors,\n    run_time=run_time,\n    boundary_spec=boundary_spec,\n)\n\n# plot the simulation domain\nf, (ax1, ax3) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4))\nsim.plot(x=0, ax=ax1)\nsim.plot(z=wg_height / 2, ax=ax3)\nax3.set_xlim(0, 20 * period)\nplt.show()\n</pre> # list of all structures structures = (     [substrate, waveguide_1, waveguide_2]     + corrug1_plus     + corrug1_minus     + corrug2_plus     + corrug2_minus )  # list of all sources sources = [mode_src1, mode_src2]  # list of all monitors monitors = [monitor_xy, monitor_flux_aligned, monitor_flux_misaligned]  # create the simulation sim = td.Simulation(     center=sim_center,     size=sim_size,     grid_spec=grid_spec,     structures=structures,     sources=sources,     monitors=monitors,     run_time=run_time,     boundary_spec=boundary_spec, )  # plot the simulation domain f, (ax1, ax3) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4)) sim.plot(x=0, ax=ax1) sim.plot(z=wg_height / 2, ax=ax3) ax3.set_xlim(0, 20 * period) plt.show() In\u00a0[6]: Copied! <pre># run simulation\nimport tidy3d.web as web\n\nsim_data = web.run(sim, task_name=\"bragg\", path=\"data/bragg.hdf5\", verbose=True)\n</pre> # run simulation import tidy3d.web as web  sim_data = web.run(sim, task_name=\"bragg\", path=\"data/bragg.hdf5\", verbose=True) <pre>15:19:44 EST Created task 'bragg' with task_id                                  \n             'fdve-89aed5d1-dd5c-437d-b5a2-c59c5bf38464' and task_type 'FDTD'.  \n</pre> <pre>             View task using web UI at                                          \n             'https://tidy3d.simulation.cloud/workbench?taskId=fdve-89aed5d1-dd5\n             c-437d-b5a2-c59c5bf38464'.                                         \n</pre> <pre>Output()</pre> <pre></pre> <pre>15:19:48 EST status = success                                                   \n</pre> <pre>Output()</pre> <pre></pre> <pre>15:19:52 EST loading simulation from data/bragg.hdf5                            \n</pre> <p>The frequency-domain fields are plotted in the <code>xy</code> plane cutting through the waveguides. We notice that the grating with aligned corrugation effectively reflects power at the design frequency, while the misalignment in the second grating causes it to be mostly transmissive.</p> In\u00a0[7]: Copied! <pre># plot fields on the monitor\nfig, ax = plt.subplots(2, 1, tight_layout=True, figsize=(9, 5))\nsim_data.plot_field(\n    field_monitor_name=\"fields_xy\", field_name=\"Ey\", val=\"real\", f=freq0, ax=ax[0]\n)\nsim_data.plot_field(\n    field_monitor_name=\"fields_xy\", field_name=\"Sx\", val=\"real\", f=freq0, ax=ax[1]\n)\nplt.show()\n</pre> # plot fields on the monitor fig, ax = plt.subplots(2, 1, tight_layout=True, figsize=(9, 5)) sim_data.plot_field(     field_monitor_name=\"fields_xy\", field_name=\"Ey\", val=\"real\", f=freq0, ax=ax[0] ) sim_data.plot_field(     field_monitor_name=\"fields_xy\", field_name=\"Sx\", val=\"real\", f=freq0, ax=ax[1] ) plt.show() <p>The observations made in the field plot above can be confirmed by plotting the flux recorded by the flux monitors as a function of frequency. In the region of the design frequency, indicated by the dashed black line, the drop in flux for the aligned-corrugation grating confirms its reflective property.</p> In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)\n\n# plot transmitted flux for each waveguide\nax.plot(td.C_0 / freqs, sim_data[\"flux_aligned\"].flux, label=\"Aligned corrugation\")\nax.plot(\n    td.C_0 / freqs, sim_data[\"flux_misaligned\"].flux, label=\"Misaligned corrugation\"\n)\n\n# vertical line at design frequency\nax.axvline(td.C_0 / freq0, ls=\"--\", color=\"k\")\n\nax.set(xlabel=\"Wavelength (\u00b5m)\", ylabel=\"Transmission\")\n\nax.grid(True)\nplt.legend()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)  # plot transmitted flux for each waveguide ax.plot(td.C_0 / freqs, sim_data[\"flux_aligned\"].flux, label=\"Aligned corrugation\") ax.plot(     td.C_0 / freqs, sim_data[\"flux_misaligned\"].flux, label=\"Misaligned corrugation\" )  # vertical line at design frequency ax.axvline(td.C_0 / freq0, ls=\"--\", color=\"k\")  ax.set(xlabel=\"Wavelength (\u00b5m)\", ylabel=\"Transmission\")  ax.grid(True) plt.legend() plt.show() <p>To convert Tidy3D structures into a PreFab <code>Device</code>, we can use <code>prefab.read.from_tidy3d</code>. However, we'll take a detailed approach to help you understand the underlying process.</p> <p>We include a small buffer region around the structures to prevent rounding off the input/output interfaces, as these will likely connect to other devices and we want to avoid unnecessary scattering.</p> In\u00a0[9]: Copied! <pre>prediction_buffer_width = 0.5\nX = np.arange(\n    sim.bounds[0][0] - prediction_buffer_width,\n    sim.bounds[1][0] + prediction_buffer_width,\n    0.001,\n)\nY = np.arange(\n    sim.bounds[0][1] - prediction_buffer_width,\n    sim.bounds[1][1] + prediction_buffer_width,\n    0.001,\n)\nZ = np.array([wg_height / 2])\ngrid = td.Grid(boundaries=td.Coords(x=X, y=Y, z=Z))\neps = np.real(sim.epsilon_on_grid(grid=grid, coord_key=\"boundaries\", freq=freq0).values)\ndevice_array = pf.geometry.binarize_hard(device_array=eps, eta=Si.permittivity - 0.1)[\n    :, :, 0\n]\ndevice_array = np.rot90(device_array, k=1)\n\ndevice = pf.Device(device_array=device_array)\ndevice.plot()\n</pre> prediction_buffer_width = 0.5 X = np.arange(     sim.bounds[0][0] - prediction_buffer_width,     sim.bounds[1][0] + prediction_buffer_width,     0.001, ) Y = np.arange(     sim.bounds[0][1] - prediction_buffer_width,     sim.bounds[1][1] + prediction_buffer_width,     0.001, ) Z = np.array([wg_height / 2]) grid = td.Grid(boundaries=td.Coords(x=X, y=Y, z=Z)) eps = np.real(sim.epsilon_on_grid(grid=grid, coord_key=\"boundaries\", freq=freq0).values) device_array = pf.geometry.binarize_hard(device_array=eps, eta=Si.permittivity - 0.1)[     :, :, 0 ] device_array = np.rot90(device_array, k=1)  device = pf.Device(device_array=device_array) device.plot() Out[9]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>With the device defined and formatted for PreFab, we can now predict it. We use the <code>ANT_NanoSOI</code> model of Applied Nanotools for this prediction.</p> <p>Note: If you would like to see models of other fabrication processes, please contact us at support@prefabphotonics.com to request them. Current models are listed here.</p> <p>We set <code>gpu=True</code> to speed up the prediction. Note that GPU predictions have a longer startup time, so smaller devices will run faster on the CPU (<code>gpu=False</code>). We set <code>binarize=True</code> to capture the most likely fabrication outcome, but we can also set <code>binarize=False</code> to get the full range of possible outcomes (more on this in a future notebook about prediction uncertainty and fabrication variability).</p> In\u00a0[10]: Copied! <pre>prediction = device.predict(model=pf.models[\"ANT_NanoSOI\"], binarize=True, gpu=True)\nprediction.plot()\n</pre> prediction = device.predict(model=pf.models[\"ANT_NanoSOI\"], binarize=True, gpu=True) prediction.plot() <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:20&lt;00:00,  4.85%/s]\n</pre> Out[10]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>Now convert the predicted device back to a Tidy3D structure with gdstk as an intermediate layer.</p> <p>Note: We also extend the run time of the simulation to 10 ps to account for the additional time required for the fields to decay.</p> In\u00a0[11]: Copied! <pre>prediction_cell = prediction.to_gdstk(\n    cell_name=\"bragg_p\", origin=(sim.center[0], sim.center[1])\n)\n\nbragg_p = td.Structure(\n    geometry=td.Geometry.from_gds(\n        gds_cell=prediction_cell,\n        axis=2,\n        slab_bounds=(0, wg_height),\n        gds_layer=1,\n        gds_dtype=0,\n    ),\n    medium=Si,\n)\n\nsim_p = sim.copy(update=dict(structures=[substrate, bragg_p], run_time=10.0e-12))\n\n# plot the predicted structure\nf, (ax1, ax3) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4))\nsim_p.plot(x=0, ax=ax1)\nsim_p.plot(z=wg_height / 2, ax=ax3)\nax3.set_xlim(sim_p.bounds[0][0], sim_p.bounds[0][0] + 10 * period)\nplt.show()\n\n# plot the nominal structure\nf, (ax1, ax3) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4))\nsim.plot(x=0, ax=ax1)\nsim.plot(z=wg_height / 2, ax=ax3)\nax3.set_xlim(sim.bounds[0][0], sim.bounds[0][0] + 10 * period)\nplt.show()\n</pre> prediction_cell = prediction.to_gdstk(     cell_name=\"bragg_p\", origin=(sim.center[0], sim.center[1]) )  bragg_p = td.Structure(     geometry=td.Geometry.from_gds(         gds_cell=prediction_cell,         axis=2,         slab_bounds=(0, wg_height),         gds_layer=1,         gds_dtype=0,     ),     medium=Si, )  sim_p = sim.copy(update=dict(structures=[substrate, bragg_p], run_time=10.0e-12))  # plot the predicted structure f, (ax1, ax3) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4)) sim_p.plot(x=0, ax=ax1) sim_p.plot(z=wg_height / 2, ax=ax3) ax3.set_xlim(sim_p.bounds[0][0], sim_p.bounds[0][0] + 10 * period) plt.show()  # plot the nominal structure f, (ax1, ax3) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4)) sim.plot(x=0, ax=ax1) sim.plot(z=wg_height / 2, ax=ax3) ax3.set_xlim(sim.bounds[0][0], sim.bounds[0][0] + 10 * period) plt.show() <pre>Creating cell 'bragg_p'...\n</pre> <p>Plotting the predicted and nominal structures side by side, we can see that the predicted structure undergoes significant corner rounding.</p> In\u00a0[12]: Copied! <pre>bounds = (\n    (2000, int(device.shape[0] / 2) - 1500),\n    (3000, int(device.shape[0] / 2) + 1500),\n)\n\nfig, axes = plt.subplots(1, 2, tight_layout=True)\ndevice.plot(bounds=bounds, ax=axes[0])\naxes[0].set_title(\"Device\")\nprediction.plot(bounds=bounds, ax=axes[1])\naxes[1].set_title(\"Prediction\")\nplt.show()\n</pre> bounds = (     (2000, int(device.shape[0] / 2) - 1500),     (3000, int(device.shape[0] / 2) + 1500), )  fig, axes = plt.subplots(1, 2, tight_layout=True) device.plot(bounds=bounds, ax=axes[0]) axes[0].set_title(\"Device\") prediction.plot(bounds=bounds, ax=axes[1]) axes[1].set_title(\"Prediction\") plt.show() In\u00a0[13]: Copied! <pre># run simulation\nimport tidy3d.web as web\n\nsim_data_p = web.run(sim_p, task_name=\"bragg_p\", path=\"data/bragg_p.hdf5\", verbose=True)\n</pre> # run simulation import tidy3d.web as web  sim_data_p = web.run(sim_p, task_name=\"bragg_p\", path=\"data/bragg_p.hdf5\", verbose=True) <pre>15:20:49 EST Created task 'bragg_p' with task_id                                \n             'fdve-45f7ae2b-1b7a-4f0c-a909-068c27a98578' and task_type 'FDTD'.  \n</pre> <pre>             View task using web UI at                                          \n             'https://tidy3d.simulation.cloud/workbench?taskId=fdve-45f7ae2b-1b7\n             a-4f0c-a909-068c27a98578'.                                         \n</pre> <pre>Output()</pre> <pre></pre> <pre>15:20:59 EST status = queued                                                    \n</pre> <pre>             To cancel the simulation, use 'web.abort(task_id)' or              \n             'web.delete(task_id)' or abort/delete the task in the web UI.      \n             Terminating the Python script will not stop the job running on the \n             cloud.                                                             \n</pre> <pre>Output()</pre> <pre>15:21:05 EST status = preprocess                                                \n</pre> <pre></pre> <pre>15:21:09 EST Maximum FlexCredit cost: 1.663. Use 'web.real_cost(task_id)' to get\n             the billed FlexCredit cost after a simulation run.                 \n</pre> <pre>             starting up solver                                                 \n</pre> <pre>             running solver                                                     \n</pre> <pre>Output()</pre> <pre>15:23:16 EST early shutoff detected at 72%, exiting.                            \n</pre> <pre></pre> <pre>15:23:17 EST status = postprocess                                               \n</pre> <pre>Output()</pre> <pre>15:23:19 EST status = success                                                   \n</pre> <pre></pre> <pre>             View simulation result at                                          \n             'https://tidy3d.simulation.cloud/workbench?taskId=fdve-45f7ae2b-1b7\n             a-4f0c-a909-068c27a98578'.                                         \n</pre> <pre>Output()</pre> <pre></pre> <pre>15:23:25 EST loading simulation from data/bragg_p.hdf5                          \n</pre> <p>The predicted device exhibits a broader reflection window compared to the nominal device, primarily due to the rounding of the corrugation corners. Additionally, there is a slight shift in the center of the reflection peak.</p> <p>In a real device, other factors such as sidewall roughness, thickness variations, and slanted sidewalls can contribute to further losses. These factors can also be incorporated into the analysis to provide a more comprehensive understanding of performance degradation resulting from the fabrication process, particularly lithography.</p> In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)\n\n# plot transmitted flux for each waveguide\nax.plot(td.C_0 / freqs, sim_data[\"flux_aligned\"].flux, label=\"Nominal\", ls=\"-\")\nax.plot(td.C_0 / freqs, sim_data_p[\"flux_aligned\"].flux, label=\"Predicted\", ls=\"--\")\n\n# vertical line at design frequency\nax.axvline(td.C_0 / freq0, ls=\"--\", color=\"k\")\n\nax.set(\n    xlabel=\"Wavelength (\u00b5m)\",\n    ylabel=\"Transmission\",\n    title=\"Comparison of nominal and predicted performance\",\n)\n\nax.grid(True)\nplt.legend()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)  # plot transmitted flux for each waveguide ax.plot(td.C_0 / freqs, sim_data[\"flux_aligned\"].flux, label=\"Nominal\", ls=\"-\") ax.plot(td.C_0 / freqs, sim_data_p[\"flux_aligned\"].flux, label=\"Predicted\", ls=\"--\")  # vertical line at design frequency ax.axvline(td.C_0 / freq0, ls=\"--\", color=\"k\")  ax.set(     xlabel=\"Wavelength (\u00b5m)\",     ylabel=\"Transmission\",     title=\"Comparison of nominal and predicted performance\", )  ax.grid(True) plt.legend() plt.show() <p>The process of predicting and simulating a photonic device is straightforward and adaptable to various designs and simulation scenarios. The key steps involve converting device designs into a format compatible with PreFab, using a selected fabrication model to predict the device, and then converting the predicted device back into the simulation domain for re-simulation.</p> <p>We encourage you to apply this process to your own devices!</p>"},{"location":"examples/5_prediction_simulation/#simulating-device-predictions","title":"Simulating device predictions\u00b6","text":""},{"location":"examples/5_prediction_simulation/#introduction","title":"Introduction\u00b6","text":"<p>This notebook provides a guide to predicting and simulating a complete photonic device. It extends the Bragg grating example from Tidy3D, which is based on the reference cited below. Our tutorial is organized into the three following sections:</p> <ol> <li>Conduct a nominal simulation of a waveguide Bragg grating, exactly as demonstrated in the Tidy3D example.</li> <li>Predict and compare the structures using PreFab.</li> <li>Simulate and evaluate the predicted performances using Tidy3D.</li> </ol> <p>Reference:  <code>Xu Wang, Yun Wang, Jonas Flueckiger, Richard Bojko, Amy Liu, Adam Reid, James Pond, Nicolas A. F. Jaeger, and Lukas Chrostowski, \"Precise control of the coupling coefficient through destructive interference in silicon waveguide Bragg gratings,\" Opt. Lett. 39, 5519-5522 (2014)</code>, DOI: 10.1364/OL.39.005519.</p>"},{"location":"examples/5_prediction_simulation/#nominal-simulation","title":"Nominal simulation\u00b6","text":"<p>First, the geometry of the structure is defined. Both waveguides are set up in the same simulation side-by-side.</p>"},{"location":"examples/5_prediction_simulation/#prefab-prediction","title":"PreFab prediction\u00b6","text":""},{"location":"examples/5_prediction_simulation/#simulation-of-predicted-device","title":"Simulation of predicted device\u00b6","text":"<p>Let's now simulate the predicted device and compare the results to the nominal simulation.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/","title":"Fabrication-aware inverse design","text":"In\u00a0[1]: Copied! <pre>import autograd as ag\nimport autograd.numpy as anp\nimport matplotlib.pylab as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\n\nimport prefab as pf\n\nnp.random.seed(2)\n</pre> import autograd as ag import autograd.numpy as anp import matplotlib.pylab as plt import numpy as np import tidy3d as td import tidy3d.web as web  import prefab as pf  np.random.seed(2) In\u00a0[6]: Copied! <pre># material information\nn_si = 3.49\nn_sio2 = 1.45  # not used in 2D\nn_air = 1\n\n# channel wavelengths\nwvls_design = np.array([1.270, 1.290, 1.310, 1.330])\n\nfreqs_design = td.C_0 / wvls_design\nnum_freqs_design = len(freqs_design)\nfreq_max = np.max(freqs_design)\nfreq_min = np.min(freqs_design)\nkeys = [str(i) for i in range(num_freqs_design)]\ndf_design = abs(np.mean(np.diff(freqs_design)))\n\n# forward source\nfreq0 = np.mean(freqs_design)\nwvl0 = td.C_0 / freq0\nfwidth = freq_max - freq_min\nrun_time = 120 / fwidth\n\n# we average the metrics over the channels with some frequency width\nchannel_fwidth = df_design / 2.0\nchannel_bounds = [\n    (f - channel_fwidth / 2, f + channel_fwidth / 2) for f in freqs_design\n]\nnum_freqs_channel = 5\nchannel_freqs = []\nfor fmin, fmax in channel_bounds:\n    sub_freqs = np.linspace(fmin, fmax, num_freqs_channel)\n    channel_freqs += sub_freqs.tolist()\n\n# size of design region\nlx = 4.5\nly = 4.5\nly_single = ly / num_freqs_design\nlz = td.inf\n\n# size of waveguides\nwg_width = 0.3\nwg_length = 1.5\nwg_spacing = 0.8\n\n# spacing between design region and PML in y\nbuffer = 1.5\n\n# size of simulation\nLx = lx + wg_length * 2\nLy = ly + buffer * 2\nLz = 0.0\n\n# fabrication constraints (feature size and projection strength)\nradius = 0.100\nbeta0 = 2\n\n# resolution information\nmin_steps_per_wvl = 18\ndl_design_region = 0.015\n</pre> # material information n_si = 3.49 n_sio2 = 1.45  # not used in 2D n_air = 1  # channel wavelengths wvls_design = np.array([1.270, 1.290, 1.310, 1.330])  freqs_design = td.C_0 / wvls_design num_freqs_design = len(freqs_design) freq_max = np.max(freqs_design) freq_min = np.min(freqs_design) keys = [str(i) for i in range(num_freqs_design)] df_design = abs(np.mean(np.diff(freqs_design)))  # forward source freq0 = np.mean(freqs_design) wvl0 = td.C_0 / freq0 fwidth = freq_max - freq_min run_time = 120 / fwidth  # we average the metrics over the channels with some frequency width channel_fwidth = df_design / 2.0 channel_bounds = [     (f - channel_fwidth / 2, f + channel_fwidth / 2) for f in freqs_design ] num_freqs_channel = 5 channel_freqs = [] for fmin, fmax in channel_bounds:     sub_freqs = np.linspace(fmin, fmax, num_freqs_channel)     channel_freqs += sub_freqs.tolist()  # size of design region lx = 4.5 ly = 4.5 ly_single = ly / num_freqs_design lz = td.inf  # size of waveguides wg_width = 0.3 wg_length = 1.5 wg_spacing = 0.8  # spacing between design region and PML in y buffer = 1.5  # size of simulation Lx = lx + wg_length * 2 Ly = ly + buffer * 2 Lz = 0.0  # fabrication constraints (feature size and projection strength) radius = 0.100 beta0 = 2  # resolution information min_steps_per_wvl = 18 dl_design_region = 0.015 In\u00a0[7]: Copied! <pre># define the waveguide ports\nwg_in = td.Structure(\n    geometry=td.Box(\n        center=(-Lx / 2, 0, 0),\n        size=(wg_length * 2, wg_width, lz),\n    ),\n    medium=td.Medium(permittivity=n_si**2),\n)\n\ncenters_y = np.linspace(\n    -ly / 2.0 + ly_single / 2.0, +ly / 2.0 - ly_single / 2.0, num_freqs_design\n)\nmode_size = (0, 0.9 * ly_single, td.inf)\n\nwgs_out = []\nfor center_y in centers_y:\n    wg_out = td.Structure(\n        geometry=td.Box(\n            center=(+Lx / 2, center_y, 0),\n            size=(wg_length * 2, wg_width, lz),\n        ),\n        medium=td.Medium(permittivity=n_si**2),\n    )\n    wgs_out.append(wg_out)\n\n# measure the mode amplitudes at each of the output ports\nmnts_mode = []\nfor key, center_y in zip(keys, centers_y):\n    mnt_mode = td.ModeMonitor(\n        center=(Lx / 2 - wg_length / 2, center_y, 0),\n        size=mode_size,\n        freqs=channel_freqs,\n        mode_spec=td.ModeSpec(),\n        name=f\"mode_{key}\",\n    )\n    mnts_mode.append(mnt_mode)\n\n# measures the flux at each of the output ports\nmnts_flux = []\nfor key, center_y in zip(keys, centers_y):\n    mnt_flux = td.FluxMonitor(\n        center=(Lx / 2 - wg_length / 2, center_y, 0),\n        size=mode_size,\n        freqs=channel_freqs,\n        name=f\"flux_{key}\",\n    )\n    mnts_flux.append(mnt_flux)\n\n# and a field monitor that measures fields on the z=0 plane at the design freqs\nfld_mnt = td.FieldMonitor(\n    center=(0, 0, 0),\n    size=(td.inf, td.inf, 0),\n    freqs=freqs_design,\n    name=\"field\",\n)\n\n# inject the fundamental mode into the input waveguide\nmode_src = td.ModeSource(\n    center=(-Lx / 2 + wg_length / 2, 0, 0),\n    size=mode_size,\n    source_time=td.GaussianPulse(\n        freq0=freq0,\n        fwidth=fwidth,\n    ),\n    direction=\"+\",\n    mode_index=0,\n)\n\nsim_base = td.Simulation(\n    size=(Lx, Ly, Lz),\n    grid_spec=td.GridSpec.auto(\n        min_steps_per_wvl=min_steps_per_wvl,\n        wavelength=np.min(wvls_design),\n    ),\n    structures=[wg_in] + wgs_out,\n    sources=[mode_src],\n    monitors=mnts_mode + mnts_flux + [fld_mnt],\n    boundary_spec=td.BoundarySpec.pml(x=True, y=True, z=True if Lz else False),\n    run_time=run_time,\n)\n</pre> # define the waveguide ports wg_in = td.Structure(     geometry=td.Box(         center=(-Lx / 2, 0, 0),         size=(wg_length * 2, wg_width, lz),     ),     medium=td.Medium(permittivity=n_si**2), )  centers_y = np.linspace(     -ly / 2.0 + ly_single / 2.0, +ly / 2.0 - ly_single / 2.0, num_freqs_design ) mode_size = (0, 0.9 * ly_single, td.inf)  wgs_out = [] for center_y in centers_y:     wg_out = td.Structure(         geometry=td.Box(             center=(+Lx / 2, center_y, 0),             size=(wg_length * 2, wg_width, lz),         ),         medium=td.Medium(permittivity=n_si**2),     )     wgs_out.append(wg_out)  # measure the mode amplitudes at each of the output ports mnts_mode = [] for key, center_y in zip(keys, centers_y):     mnt_mode = td.ModeMonitor(         center=(Lx / 2 - wg_length / 2, center_y, 0),         size=mode_size,         freqs=channel_freqs,         mode_spec=td.ModeSpec(),         name=f\"mode_{key}\",     )     mnts_mode.append(mnt_mode)  # measures the flux at each of the output ports mnts_flux = [] for key, center_y in zip(keys, centers_y):     mnt_flux = td.FluxMonitor(         center=(Lx / 2 - wg_length / 2, center_y, 0),         size=mode_size,         freqs=channel_freqs,         name=f\"flux_{key}\",     )     mnts_flux.append(mnt_flux)  # and a field monitor that measures fields on the z=0 plane at the design freqs fld_mnt = td.FieldMonitor(     center=(0, 0, 0),     size=(td.inf, td.inf, 0),     freqs=freqs_design,     name=\"field\", )  # inject the fundamental mode into the input waveguide mode_src = td.ModeSource(     center=(-Lx / 2 + wg_length / 2, 0, 0),     size=mode_size,     source_time=td.GaussianPulse(         freq0=freq0,         fwidth=fwidth,     ),     direction=\"+\",     mode_index=0, )  sim_base = td.Simulation(     size=(Lx, Ly, Lz),     grid_spec=td.GridSpec.auto(         min_steps_per_wvl=min_steps_per_wvl,         wavelength=np.min(wvls_design),     ),     structures=[wg_in] + wgs_out,     sources=[mode_src],     monitors=mnts_mode + mnts_flux + [fld_mnt],     boundary_spec=td.BoundarySpec.pml(x=True, y=True, z=True if Lz else False),     run_time=run_time, ) In\u00a0[8]: Copied! <pre>ax = sim_base.plot_eps(z=0.01)\nax.set_aspect(\"equal\")\n</pre> ax = sim_base.plot_eps(z=0.01) ax.set_aspect(\"equal\") In\u00a0[9]: Copied! <pre>from tidy3d.plugins.mode import ModeSolver\nfrom tidy3d.plugins.mode.web import run as run_mode_solver\n\n# we'll ask for 4 modes just to inspect\nnum_modes = 4\n\n# let's define how large the mode planes are and how far they are from the PML relative to the design region\nmode_size = (0, ly_single, td.inf)\n\n# make a plane corresponding to where we wish to measure the input mode\nplane_in = td.Box(\n    center=(-Lx / 2 + wg_length / 2.0, 0, 0),\n    size=mode_size,\n)\n\nmode_solver = ModeSolver(\n    simulation=sim_base,\n    plane=plane_in,\n    freqs=freqs_design,\n    mode_spec=td.ModeSpec(num_modes=num_modes),\n)\n</pre> from tidy3d.plugins.mode import ModeSolver from tidy3d.plugins.mode.web import run as run_mode_solver  # we'll ask for 4 modes just to inspect num_modes = 4  # let's define how large the mode planes are and how far they are from the PML relative to the design region mode_size = (0, ly_single, td.inf)  # make a plane corresponding to where we wish to measure the input mode plane_in = td.Box(     center=(-Lx / 2 + wg_length / 2.0, 0, 0),     size=mode_size, )  mode_solver = ModeSolver(     simulation=sim_base,     plane=plane_in,     freqs=freqs_design,     mode_spec=td.ModeSpec(num_modes=num_modes), ) <p>Next we run the mode solver on the servers.</p> In\u00a0[10]: Copied! <pre>mode_data = run_mode_solver(\n    mode_solver, reduce_simulation=True, results_file=\"data/mode_solver.hdf5\"\n)\n</pre> mode_data = run_mode_solver(     mode_solver, reduce_simulation=True, results_file=\"data/mode_solver.hdf5\" ) <pre>15:39:02 EST Mode solver created with                                           \n             task_id='fdve-bd79fa16-6098-46c5-aeb7-b41164b4bf2e',               \n             solver_id='mo-840d02cc-5271-46a1-9c82-dbd5870a36ce'.               \n</pre> <pre>Output()</pre> <pre></pre> <pre>\n</pre> <pre>Output()</pre> <pre></pre> <pre>\n</pre> <pre>15:39:04 EST Mode solver status: success                                        \n</pre> <pre>Output()</pre> <pre></pre> <pre>\n</pre> <p>And visualize the results.</p> In\u00a0[11]: Copied! <pre>fig, axs = plt.subplots(num_modes, 3, figsize=(12, 22), tight_layout=True)\nfor mode_index in range(num_modes):\n    vmax = 1.1 * max(\n        abs(mode_data.field_components[n].sel(mode_index=mode_index)).max()\n        for n in (\"Ex\", \"Ey\", \"Ez\")\n    )\n    for field_name, ax in zip((\"Ex\", \"Ey\", \"Ez\"), axs[mode_index]):\n        for freq in freqs_design:\n            key = f\"{td.C_0 / freq * 1000 :.0f} nm\"\n            field = mode_data.field_components[field_name].sel(\n                mode_index=mode_index, f=freq\n            )\n            field.real.plot(label=f\"Real ({key})\", ax=ax)\n            field.imag.plot(ls=\"--\", label=f\"Imag ({key})\", ax=ax)\n        ax.set_title(f\"index={mode_index}, {field_name}\")\n        ax.set_ylim(-vmax, vmax)\n        ax.legend()\n\nprint(\"Effective index of computed modes: \", np.array(mode_data.n_eff))\n</pre> fig, axs = plt.subplots(num_modes, 3, figsize=(12, 22), tight_layout=True) for mode_index in range(num_modes):     vmax = 1.1 * max(         abs(mode_data.field_components[n].sel(mode_index=mode_index)).max()         for n in (\"Ex\", \"Ey\", \"Ez\")     )     for field_name, ax in zip((\"Ex\", \"Ey\", \"Ez\"), axs[mode_index]):         for freq in freqs_design:             key = f\"{td.C_0 / freq * 1000 :.0f} nm\"             field = mode_data.field_components[field_name].sel(                 mode_index=mode_index, f=freq             )             field.real.plot(label=f\"Real ({key})\", ax=ax)             field.imag.plot(ls=\"--\", label=f\"Imag ({key})\", ax=ax)         ax.set_title(f\"index={mode_index}, {field_name}\")         ax.set_ylim(-vmax, vmax)         ax.legend()  print(\"Effective index of computed modes: \", np.array(mode_data.n_eff)) <pre>Effective index of computed modes:  [[3.1513898 2.840793  2.006425  1.0989405]\n [3.1436877 2.8191965 1.970435  1.0913303]\n [3.1359682 2.797195  1.934321  1.0847051]\n [3.1282325 2.7747855 1.8980899 1.0788841]]\n</pre> <p>We identify <code>mode_index=0</code> as the first order mode that is out of plane of the device. Let's choose to optimize our device with respect to this as the mode of interest for both the input and output.</p> <p>We'll update or Base Simulation with the new mode index and mode specification, in case these are different from the original ones.</p> In\u00a0[12]: Copied! <pre>mode_index = 0\nmode_spec = td.ModeSpec(num_modes=mode_index + 1)\n\nsim_base = sim_base.updated_copy(mode_index=mode_index, path=\"sources/0\")\nsim_base = sim_base.updated_copy(mode_spec=mode_spec, path=\"sources/0\")\nfor i in range(num_freqs_design):\n    sim_base = sim_base.updated_copy(mode_spec=mode_spec, path=f\"monitors/{i}\")\n</pre> mode_index = 0 mode_spec = td.ModeSpec(num_modes=mode_index + 1)  sim_base = sim_base.updated_copy(mode_index=mode_index, path=\"sources/0\") sim_base = sim_base.updated_copy(mode_spec=mode_spec, path=\"sources/0\") for i in range(num_freqs_design):     sim_base = sim_base.updated_copy(mode_spec=mode_spec, path=f\"monitors/{i}\") In\u00a0[13]: Copied! <pre>nx = int(lx / dl_design_region)\nny = int(ly / dl_design_region)\n\ndesign_region_geo = td.Box(size=(lx, ly, lz), center=(0, 0, 0))\n</pre> nx = int(lx / dl_design_region) ny = int(ly / dl_design_region)  design_region_geo = td.Box(size=(lx, ly, lz), center=(0, 0, 0)) <p>PreFab models function on a grid with a 1 nm resolution. To use the prediction function effectively, we adjust our simulation design region to match this resolution. We also add a buffer layer to the design region to account for the interface between it and the waveguides. Afterward, we will convert it back to the original size and resolution.</p> <p>While this process introduces discretization error, it can be minimized by using a higher simulation resolution\u2014which is recommended for production designs.</p> <p>Note: We'll use a model for the electron-beam lithography process from Applied Nanotools Inc. (ANT) for the prediction.</p> In\u00a0[14]: Copied! <pre>FAB_MODEL = pf.models[\"ANT_NanoSOI_ANF1_d10\"]\nprediction_buffer = 0.16\nn_prediction_buffer = int(prediction_buffer / dl_design_region)\n\n\ndef resize_array(array: np.ndarray, scale: float) -&gt; np.ndarray:\n    H, W = array.shape\n    \"\"\"Array resizing using bilinear interpolation.\"\"\"\n    new_H = int(H * scale)\n    new_W = int(W * scale)\n\n    x = anp.linspace(0, W - 1, new_W)\n    y = anp.linspace(0, H - 1, new_H)\n    x_grid, y_grid = anp.meshgrid(x, y)\n\n    x0 = anp.floor(x_grid).astype(int)\n    x1 = x0 + 1\n    y0 = anp.floor(y_grid).astype(int)\n    y1 = y0 + 1\n\n    x0 = anp.clip(x0, 0, W - 1)\n    x1 = anp.clip(x1, 0, W - 1)\n    y0 = anp.clip(y0, 0, H - 1)\n    y1 = anp.clip(y1, 0, H - 1)\n\n    Ia = array[y0, x0]\n    Ib = array[y1, x0]\n    Ic = array[y0, x1]\n    Id = array[y1, x1]\n\n    wa = (x1 - x_grid) * (y1 - y_grid)\n    wb = (x1 - x_grid) * (y_grid - y0)\n    wc = (x_grid - x0) * (y1 - y_grid)\n    wd = (x_grid - x0) * (y_grid - y0)\n\n    resized_image = wa * Ia + wb * Ib + wc * Ic + wd * Id\n    return resized_image\n\n\ndef add_prediction_buffer(params):\n    \"\"\"Add a buffer layer to the design region. This is useful for predicting the interface between the design region and the waveguides.\"\"\"\n    params = anp.pad(\n        params, pad_width=n_prediction_buffer, mode=\"constant\", constant_values=0\n    )\n    wg_mask = anp.zeros_like(params)\n    center_y_mask = wg_mask.shape[1] // 2\n\n    # add input waveguide to mask\n    wg_half_width = int((wg_width / 2) / dl_design_region)\n    wg_mask[\n        0:n_prediction_buffer,\n        center_y_mask - wg_half_width : center_y_mask + wg_half_width,\n    ] = 1\n\n    # add output waveguides to mask\n    for center_y in centers_y:\n        wg_center = int(center_y / dl_design_region)\n        wg_mask[\n            -n_prediction_buffer:,\n            center_y_mask + wg_center - wg_half_width : center_y_mask\n            + wg_center\n            + wg_half_width,\n        ] = 1\n\n    return params * (1 - wg_mask) + wg_mask\n\n\ndef params_to_device_array(\n    params: np.ndarray, scale: float, pad_width: int = 100\n) -&gt; np.ndarray:\n    \"\"\"Convert params to a device array at 1 nm resolution.\"\"\"\n    params = add_prediction_buffer(params)\n    device_array = resize_array(params, scale)\n    return device_array\n\n\ndef device_array_to_params(\n    device_array: np.ndarray, scale: float, pad_width: int = 100\n) -&gt; np.ndarray:\n    \"\"\"Convert device array to params at the original resolution.\"\"\"\n    params = resize_array(device_array, 1 / scale)\n    params = params[\n        n_prediction_buffer:-n_prediction_buffer,\n        n_prediction_buffer:-n_prediction_buffer,\n    ]\n    return params\n</pre> FAB_MODEL = pf.models[\"ANT_NanoSOI_ANF1_d10\"] prediction_buffer = 0.16 n_prediction_buffer = int(prediction_buffer / dl_design_region)   def resize_array(array: np.ndarray, scale: float) -&gt; np.ndarray:     H, W = array.shape     \"\"\"Array resizing using bilinear interpolation.\"\"\"     new_H = int(H * scale)     new_W = int(W * scale)      x = anp.linspace(0, W - 1, new_W)     y = anp.linspace(0, H - 1, new_H)     x_grid, y_grid = anp.meshgrid(x, y)      x0 = anp.floor(x_grid).astype(int)     x1 = x0 + 1     y0 = anp.floor(y_grid).astype(int)     y1 = y0 + 1      x0 = anp.clip(x0, 0, W - 1)     x1 = anp.clip(x1, 0, W - 1)     y0 = anp.clip(y0, 0, H - 1)     y1 = anp.clip(y1, 0, H - 1)      Ia = array[y0, x0]     Ib = array[y1, x0]     Ic = array[y0, x1]     Id = array[y1, x1]      wa = (x1 - x_grid) * (y1 - y_grid)     wb = (x1 - x_grid) * (y_grid - y0)     wc = (x_grid - x0) * (y1 - y_grid)     wd = (x_grid - x0) * (y_grid - y0)      resized_image = wa * Ia + wb * Ib + wc * Ic + wd * Id     return resized_image   def add_prediction_buffer(params):     \"\"\"Add a buffer layer to the design region. This is useful for predicting the interface between the design region and the waveguides.\"\"\"     params = anp.pad(         params, pad_width=n_prediction_buffer, mode=\"constant\", constant_values=0     )     wg_mask = anp.zeros_like(params)     center_y_mask = wg_mask.shape[1] // 2      # add input waveguide to mask     wg_half_width = int((wg_width / 2) / dl_design_region)     wg_mask[         0:n_prediction_buffer,         center_y_mask - wg_half_width : center_y_mask + wg_half_width,     ] = 1      # add output waveguides to mask     for center_y in centers_y:         wg_center = int(center_y / dl_design_region)         wg_mask[             -n_prediction_buffer:,             center_y_mask + wg_center - wg_half_width : center_y_mask             + wg_center             + wg_half_width,         ] = 1      return params * (1 - wg_mask) + wg_mask   def params_to_device_array(     params: np.ndarray, scale: float, pad_width: int = 100 ) -&gt; np.ndarray:     \"\"\"Convert params to a device array at 1 nm resolution.\"\"\"     params = add_prediction_buffer(params)     device_array = resize_array(params, scale)     return device_array   def device_array_to_params(     device_array: np.ndarray, scale: float, pad_width: int = 100 ) -&gt; np.ndarray:     \"\"\"Convert device array to params at the original resolution.\"\"\"     params = resize_array(device_array, 1 / scale)     params = params[         n_prediction_buffer:-n_prediction_buffer,         n_prediction_buffer:-n_prediction_buffer,     ]     return params <p>Next we write a function to give us the pixelated array as a function of our parameters through our filtering and projection methods, which are used to make the resulting structures easier to fabricate. For more details, refer to our 4th lecture in the inverse design 101 lecture series, which focuses on fabrication constraints.</p> <p>We also wrap this function in another one that generates the entire <code>td.Structure</code> corresponding to the design region, for convenience later.</p> <p>For FAID: During each iteration, we predict the fabrication variation of the structure and incorporate the new geometry into the simulation. This approach allows us to optimize a \"virtual\" structure, which accounts for fabrication imperfections, rather than an idealized version. We introduce a <code>use_predict</code> flag here.</p> In\u00a0[15]: Copied! <pre>from tidy3d.plugins.autograd import make_filter_and_project, rescale\n\nfilter_project = make_filter_and_project(radius, dl_design_region)\n\n\ndef get_density(params: np.ndarray, beta: float) -&gt; np.ndarray:\n    \"\"\"Get the density of material (0, 1) as a function of the parameters (0,1)\"\"\"\n    return filter_project(params, beta=beta)\n\n\ndef make_eps(params: np.ndarray, beta: float, use_predict: bool = False) -&gt; np.ndarray:\n    \"\"\"Generates permittivity values for the design region, optionally using a PreFab prediction model to account for manufacturing variations.\"\"\"\n    density = get_density(params, beta=beta)\n\n    # ********** START OF ADDED PREFAB CODE **********\n    if use_predict:\n        device_array = params_to_device_array(density, dl_design_region * 1000)\n        prediction_array = pf.predict.predict_array_with_grad(device_array, FAB_MODEL)\n        predicted_density = device_array_to_params(\n            prediction_array, dl_design_region * 1000\n        )\n        return rescale(predicted_density, 1, n_si**2)\n    # ********** END OF ADDED PREFAB CODE **********\n\n    else:\n        return rescale(density, 1, n_si**2)\n\n\ndef make_custom_medium(\n    params: np.ndarray, beta: float, use_predict: bool = False\n) -&gt; td.Structure:\n    \"\"\"Make td.Structure containing custom medium with the permittivity data as a function of parameters.\"\"\"\n    eps = make_eps(params, beta, use_predict).reshape((nx, ny, 1))\n    xs = anp.linspace(-lx / 2, lx / 2, nx)\n    ys = anp.linspace(-ly / 2, ly / 2, ny)\n    zs = [0]\n    coords = dict(x=xs, y=ys, z=zs)\n\n    eps_arr = td.ScalarFieldDataArray(data=eps, coords=coords)\n\n    medium = td.CustomMedium(permittivity=eps_arr)\n\n    return td.Structure(geometry=design_region_geo, medium=medium)\n</pre> from tidy3d.plugins.autograd import make_filter_and_project, rescale  filter_project = make_filter_and_project(radius, dl_design_region)   def get_density(params: np.ndarray, beta: float) -&gt; np.ndarray:     \"\"\"Get the density of material (0, 1) as a function of the parameters (0,1)\"\"\"     return filter_project(params, beta=beta)   def make_eps(params: np.ndarray, beta: float, use_predict: bool = False) -&gt; np.ndarray:     \"\"\"Generates permittivity values for the design region, optionally using a PreFab prediction model to account for manufacturing variations.\"\"\"     density = get_density(params, beta=beta)      # ********** START OF ADDED PREFAB CODE **********     if use_predict:         device_array = params_to_device_array(density, dl_design_region * 1000)         prediction_array = pf.predict.predict_array_with_grad(device_array, FAB_MODEL)         predicted_density = device_array_to_params(             prediction_array, dl_design_region * 1000         )         return rescale(predicted_density, 1, n_si**2)     # ********** END OF ADDED PREFAB CODE **********      else:         return rescale(density, 1, n_si**2)   def make_custom_medium(     params: np.ndarray, beta: float, use_predict: bool = False ) -&gt; td.Structure:     \"\"\"Make td.Structure containing custom medium with the permittivity data as a function of parameters.\"\"\"     eps = make_eps(params, beta, use_predict).reshape((nx, ny, 1))     xs = anp.linspace(-lx / 2, lx / 2, nx)     ys = anp.linspace(-ly / 2, ly / 2, ny)     zs = [0]     coords = dict(x=xs, y=ys, z=zs)      eps_arr = td.ScalarFieldDataArray(data=eps, coords=coords)      medium = td.CustomMedium(permittivity=eps_arr)      return td.Structure(geometry=design_region_geo, medium=medium) In\u00a0[16]: Copied! <pre>def get_sim(params, beta, include_extra_mnts: bool = True, use_predict: bool = False):\n    design_region = make_custom_medium(params, beta=beta, use_predict=use_predict)\n\n    design_override = td.MeshOverrideStructure(\n        geometry=design_region.geometry,\n        dl=[dl_design_region, dl_design_region, dl_design_region],\n    )\n    grid_spec = sim_base.grid_spec.updated_copy(\n        override_structures=list(sim_base.grid_spec.override_structures)\n        + [design_override]\n    )\n\n    update_dict = dict(\n        structures=list(sim_base.structures) + [design_region],\n        grid_spec=grid_spec,\n    )\n\n    # if include_extra_mnts is False, update sim to only include mode monitors, to save data.\n    if not include_extra_mnts:\n        update_dict[\"monitors\"] = mnts_mode\n\n    return sim_base.updated_copy(**update_dict)\n</pre> def get_sim(params, beta, include_extra_mnts: bool = True, use_predict: bool = False):     design_region = make_custom_medium(params, beta=beta, use_predict=use_predict)      design_override = td.MeshOverrideStructure(         geometry=design_region.geometry,         dl=[dl_design_region, dl_design_region, dl_design_region],     )     grid_spec = sim_base.grid_spec.updated_copy(         override_structures=list(sim_base.grid_spec.override_structures)         + [design_override]     )      update_dict = dict(         structures=list(sim_base.structures) + [design_region],         grid_spec=grid_spec,     )      # if include_extra_mnts is False, update sim to only include mode monitors, to save data.     if not include_extra_mnts:         update_dict[\"monitors\"] = mnts_mode      return sim_base.updated_copy(**update_dict) <p>Let's test out our function. We'll make an initially random array of parameters between 0 and 1 and generate the Base Simulation to plot and inspect.</p> In\u00a0[17]: Copied! <pre>params0 = np.random.random((nx, ny))\nsim0 = get_sim(params0, beta=beta0, use_predict=False)\n</pre> params0 = np.random.random((nx, ny)) sim0 = get_sim(params0, beta=beta0, use_predict=False) In\u00a0[18]: Copied! <pre>ax = sim0.plot_eps(z=0.01)\nax.set_aspect(\"equal\")\n</pre> ax = sim0.plot_eps(z=0.01) ax.set_aspect(\"equal\") In\u00a0[19]: Copied! <pre>import xarray as xr\n\n\ndef average_over_channel(\n    spectrum: xr.DataArray, fmin: float, fmax: float\n) -&gt; xr.DataArray:\n    \"\"\"Get average of the spectrum within the frequency range between fmin and fmax.\"\"\"\n    freqs = spectrum.f\n    freqs_in_channel = np.logical_and(freqs &gt;= fmin, freqs &lt;= fmax).values\n    num_freqs = np.sum(freqs_in_channel)\n    avg_power = spectrum.values @ freqs_in_channel / num_freqs\n    return avg_power\n\n\ndef get_power(sim_data: td.SimulationData, mnt_index: int, freq_index: int) -&gt; float:\n    \"\"\"Get the average power at waveguide `mnt_index` and frequency channel `freq_index`.\"\"\"\n    mnt_name = mnts_mode[mnt_index].name\n    mnt_data = sim_data[mnt_name]\n    fmin_channel, fmax_channel = channel_bounds[freq_index]\n    amp = mnt_data.amps.sel(direction=\"+\", mode_index=0)\n    power_spectrum = anp.abs(amp) ** 2\n    return average_over_channel(power_spectrum, fmin=fmin_channel, fmax=fmax_channel)\n\n\ndef get_metric(\n    sim_data: td.SimulationData, mnt_index: int, leak_weight: float = 1.0\n) -&gt; float:\n    \"\"\"measure of how well this channel (`mnt_index`) performs. With an adjustable weight to reduce cross talk influence.\"\"\"\n\n    power_all = [\n        get_power(sim_data=sim_data, mnt_index=mnt_index, freq_index=j)\n        for j in range(num_freqs_design)\n    ]\n\n    power_transmitted = power_all[mnt_index]\n\n    # remove the extra term of power_self in power_all\n    power_leaked = sum(power_all) - power_transmitted\n    avg_power_leaked = power_leaked / (num_freqs_design - 1)\n\n    return power_transmitted - leak_weight * avg_power_leaked\n</pre> import xarray as xr   def average_over_channel(     spectrum: xr.DataArray, fmin: float, fmax: float ) -&gt; xr.DataArray:     \"\"\"Get average of the spectrum within the frequency range between fmin and fmax.\"\"\"     freqs = spectrum.f     freqs_in_channel = np.logical_and(freqs &gt;= fmin, freqs &lt;= fmax).values     num_freqs = np.sum(freqs_in_channel)     avg_power = spectrum.values @ freqs_in_channel / num_freqs     return avg_power   def get_power(sim_data: td.SimulationData, mnt_index: int, freq_index: int) -&gt; float:     \"\"\"Get the average power at waveguide `mnt_index` and frequency channel `freq_index`.\"\"\"     mnt_name = mnts_mode[mnt_index].name     mnt_data = sim_data[mnt_name]     fmin_channel, fmax_channel = channel_bounds[freq_index]     amp = mnt_data.amps.sel(direction=\"+\", mode_index=0)     power_spectrum = anp.abs(amp) ** 2     return average_over_channel(power_spectrum, fmin=fmin_channel, fmax=fmax_channel)   def get_metric(     sim_data: td.SimulationData, mnt_index: int, leak_weight: float = 1.0 ) -&gt; float:     \"\"\"measure of how well this channel (`mnt_index`) performs. With an adjustable weight to reduce cross talk influence.\"\"\"      power_all = [         get_power(sim_data=sim_data, mnt_index=mnt_index, freq_index=j)         for j in range(num_freqs_design)     ]      power_transmitted = power_all[mnt_index]      # remove the extra term of power_self in power_all     power_leaked = sum(power_all) - power_transmitted     avg_power_leaked = power_leaked / (num_freqs_design - 1)      return power_transmitted - leak_weight * avg_power_leaked <p>Next we add a penalty to produce structures that are invariant under erosion and dilation, which is a useful approach to implementing minimum length scale features.</p> In\u00a0[20]: Copied! <pre>from tidy3d.plugins.autograd import make_erosion_dilation_penalty\n\nbeta_penalty = 10\n\npenalty = make_erosion_dilation_penalty(radius, dl_design_region, beta=beta_penalty)\n</pre> from tidy3d.plugins.autograd import make_erosion_dilation_penalty  beta_penalty = 10  penalty = make_erosion_dilation_penalty(radius, dl_design_region, beta=beta_penalty) In\u00a0[21]: Copied! <pre># useful for debugging, if you want to turn off the metric, penalty, or prediction\nuse_penalty = False\nuse_metric = True\nuse_predict = True\n\n\ndef objective(\n    params, beta: float, penalty_weight: float = 1.0, leak_weight: float = 0.0\n) -&gt; float:\n    metric = 0.0\n    penalty_value = 0.0\n\n    if use_metric:\n        sim = get_sim(\n            params, beta=beta, include_extra_mnts=False, use_predict=use_predict\n        )\n        simulations = {f\"WDM_invdes_{key}\": sim for key in keys}\n        batch_data = web.run_async(simulations, verbose=False, path_dir=\"data/\")\n        metric = 0.0\n        for mnt_index, (_, sim_data) in enumerate(batch_data.items()):\n            metric = metric + get_metric(\n                sim_data=sim_data, mnt_index=mnt_index, leak_weight=leak_weight\n            )\n        metric = metric / num_freqs_design\n\n    if use_penalty:\n        penalty_value = penalty(params)\n\n    return metric - penalty_weight * penalty_value\n</pre> # useful for debugging, if you want to turn off the metric, penalty, or prediction use_penalty = False use_metric = True use_predict = True   def objective(     params, beta: float, penalty_weight: float = 1.0, leak_weight: float = 0.0 ) -&gt; float:     metric = 0.0     penalty_value = 0.0      if use_metric:         sim = get_sim(             params, beta=beta, include_extra_mnts=False, use_predict=use_predict         )         simulations = {f\"WDM_invdes_{key}\": sim for key in keys}         batch_data = web.run_async(simulations, verbose=False, path_dir=\"data/\")         metric = 0.0         for mnt_index, (_, sim_data) in enumerate(batch_data.items()):             metric = metric + get_metric(                 sim_data=sim_data, mnt_index=mnt_index, leak_weight=leak_weight             )         metric = metric / num_freqs_design      if use_penalty:         penalty_value = penalty(params)      return metric - penalty_weight * penalty_value In\u00a0[22]: Copied! <pre>grad_fn = ag.value_and_grad(objective)\n</pre> grad_fn = ag.value_and_grad(objective) <p>Let's try out our gradient function.</p> In\u00a0[23]: Copied! <pre>J, grad = grad_fn(params0, beta=1)\n</pre> J, grad = grad_fn(params0, beta=1) In\u00a0[24]: Copied! <pre>print(J)\nprint(grad.shape)\nprint(np.linalg.norm(grad))\n</pre> print(J) print(grad.shape) print(np.linalg.norm(grad)) <pre>0.09930831775707324\n(300, 300)\n0.004744553423072362\n</pre> In\u00a0[25]: Copied! <pre>import os\nimport pickle\n\nimport optax\n\n# check if the optimization history file exists\nhistory_file_path = \"misc/optimization_history_FAID_4ch_R100_1filter_buffer.pkl\"\nif os.path.exists(history_file_path):\n    # load the saved optimization history\n    with open(history_file_path, \"rb\") as f:\n        data_history = pickle.load(f)\n    Js = data_history[\"Js\"]\n    params_history = data_history[\"params_history\"]\n    beta_history = data_history[\"beta_history\"]\n    opt_state = data_history[\"opt_state\"]\n    start_step = len(Js)\n    print(f\"Loaded {start_step} steps from history file.\")\n    params = params_history[-1]\nelse:\n    # initialize new optimization history\n    Js = []\n    params_history = [params0]\n    beta_history = []\n    start_step = 0\n    params = 0.5 * np.ones_like(params0)\n    opt_state = None\n\n# hyperparameters\nnum_steps = 70\nlearning_rate = 0.1\nbeta_min = 1\nbeta_max = 50\n\n# initialize the optimizer with the last known state\noptimizer = optax.adam(learning_rate=learning_rate)\nif opt_state is None:\n    opt_state = optimizer.init(params)\n\nfor i in range(start_step, num_steps):\n    perc_done = i / (num_steps - 1)\n\n    # in case we want to change parameters over the optimization procedure\n    one_third = 1.0 / 3.0\n\n    penalty_weight = 1.0\n    leak_weight = 0.0 if perc_done &lt; one_third else 1.0\n    beta_i = beta_min * (1 - perc_done) + beta_max * perc_done\n\n    # make a plot of density to check on progress\n    density = get_density(params, beta_i)\n    plt.subplots(figsize=(2, 2))\n    plt.imshow(np.flipud(1 - density.T), cmap=\"gray\", vmin=0, vmax=1)\n    plt.axis(\"off\")\n    plt.show()\n\n    # compute gradient and current objective function value\n    value, gradient = grad_fn(\n        params, beta=beta_i, penalty_weight=penalty_weight, leak_weight=leak_weight\n    )\n\n    # outputs\n    print(f\"step = {i + 1}\")\n    print(f\"\\tJ = {value:.4e}\")\n    print(f\"\\tbeta = {beta_i:.2f}\")\n    print(f\"\\tgrad_norm = {np.linalg.norm(gradient):.4e}\")\n\n    # compute and apply updates to the optimizer based on gradient (-1 sign to maximize obj_fn)\n    updates, opt_state = optimizer.update(-gradient, opt_state, params)\n    params = optax.apply_updates(params, updates)\n    params = np.array(params)\n\n    # keep params between 0 and 1\n    params = anp.minimum(1.0, params)\n    params = anp.maximum(0.0, params)\n\n    # save history\n    Js.append(value)\n    params_history.append(params)\n    beta_history.append(beta_i)\n    data_to_save = {\n        \"Js\": Js,\n        \"params_history\": params_history,\n        \"beta_history\": beta_history,\n        \"opt_state\": opt_state,\n    }\n    with open(history_file_path, \"wb\") as f:\n        pickle.dump(data_to_save, f)\n</pre> import os import pickle  import optax  # check if the optimization history file exists history_file_path = \"misc/optimization_history_FAID_4ch_R100_1filter_buffer.pkl\" if os.path.exists(history_file_path):     # load the saved optimization history     with open(history_file_path, \"rb\") as f:         data_history = pickle.load(f)     Js = data_history[\"Js\"]     params_history = data_history[\"params_history\"]     beta_history = data_history[\"beta_history\"]     opt_state = data_history[\"opt_state\"]     start_step = len(Js)     print(f\"Loaded {start_step} steps from history file.\")     params = params_history[-1] else:     # initialize new optimization history     Js = []     params_history = [params0]     beta_history = []     start_step = 0     params = 0.5 * np.ones_like(params0)     opt_state = None  # hyperparameters num_steps = 70 learning_rate = 0.1 beta_min = 1 beta_max = 50  # initialize the optimizer with the last known state optimizer = optax.adam(learning_rate=learning_rate) if opt_state is None:     opt_state = optimizer.init(params)  for i in range(start_step, num_steps):     perc_done = i / (num_steps - 1)      # in case we want to change parameters over the optimization procedure     one_third = 1.0 / 3.0      penalty_weight = 1.0     leak_weight = 0.0 if perc_done &lt; one_third else 1.0     beta_i = beta_min * (1 - perc_done) + beta_max * perc_done      # make a plot of density to check on progress     density = get_density(params, beta_i)     plt.subplots(figsize=(2, 2))     plt.imshow(np.flipud(1 - density.T), cmap=\"gray\", vmin=0, vmax=1)     plt.axis(\"off\")     plt.show()      # compute gradient and current objective function value     value, gradient = grad_fn(         params, beta=beta_i, penalty_weight=penalty_weight, leak_weight=leak_weight     )      # outputs     print(f\"step = {i + 1}\")     print(f\"\\tJ = {value:.4e}\")     print(f\"\\tbeta = {beta_i:.2f}\")     print(f\"\\tgrad_norm = {np.linalg.norm(gradient):.4e}\")      # compute and apply updates to the optimizer based on gradient (-1 sign to maximize obj_fn)     updates, opt_state = optimizer.update(-gradient, opt_state, params)     params = optax.apply_updates(params, updates)     params = np.array(params)      # keep params between 0 and 1     params = anp.minimum(1.0, params)     params = anp.maximum(0.0, params)      # save history     Js.append(value)     params_history.append(params)     beta_history.append(beta_i)     data_to_save = {         \"Js\": Js,         \"params_history\": params_history,         \"beta_history\": beta_history,         \"opt_state\": opt_state,     }     with open(history_file_path, \"wb\") as f:         pickle.dump(data_to_save, f) <pre>Loaded 70 steps from history file.\n</pre> In\u00a0[26]: Copied! <pre>plt.plot(Js)\nplt.xlabel(\"iteration number\")\nplt.ylabel(\"objective function\")\nplt.show()\n</pre> plt.plot(Js) plt.xlabel(\"iteration number\") plt.ylabel(\"objective function\") plt.show() In\u00a0[27]: Copied! <pre># we'll sample the modes at a finer frequency resolution for this final evaluation, for smoother plots\niter_final = -1\n\nnum_freqs_measure = 151\nfreqs_measure = np.linspace(\n    freq_min - df_design, freq_max + df_design, num_freqs_measure\n)\n\nsim_final = get_sim(\n    params_history[iter_final], beta=beta_history[iter_final], use_predict=False\n)\n\nfor i in range(num_freqs_design):\n    sim_final = sim_final.updated_copy(freqs=freqs_measure, path=f\"monitors/{i}\")\n    sim_final = sim_final.updated_copy(\n        freqs=freqs_measure, path=f\"monitors/{i + num_freqs_design}\"\n    )\n</pre> # we'll sample the modes at a finer frequency resolution for this final evaluation, for smoother plots iter_final = -1  num_freqs_measure = 151 freqs_measure = np.linspace(     freq_min - df_design, freq_max + df_design, num_freqs_measure )  sim_final = get_sim(     params_history[iter_final], beta=beta_history[iter_final], use_predict=False )  for i in range(num_freqs_design):     sim_final = sim_final.updated_copy(freqs=freqs_measure, path=f\"monitors/{i}\")     sim_final = sim_final.updated_copy(         freqs=freqs_measure, path=f\"monitors/{i + num_freqs_design}\"     ) In\u00a0[28]: Copied! <pre>ax = sim_final.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0)\n</pre> ax = sim_final.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0) In\u00a0[29]: Copied! <pre>penalty_value_final = penalty(params_history[-1])\nprint(penalty_value_final)\n</pre> penalty_value_final = penalty(params_history[-1]) print(penalty_value_final) <pre>0.4385708213150775\n</pre> In\u00a0[30]: Copied! <pre>sim_data_final = web.run(sim_final, verbose=False, task_name=\"wdm_final\")\n</pre> sim_data_final = web.run(sim_final, verbose=False, task_name=\"wdm_final\") <p>Let's also run the final simulation with the prediction model.</p> In\u00a0[32]: Copied! <pre>sim_final_predicted = get_sim(\n    params_history[iter_final], beta=beta_history[iter_final], use_predict=True\n)\n\nfor i in range(num_freqs_design):\n    sim_final_predicted = sim_final_predicted.updated_copy(\n        freqs=freqs_measure, path=f\"monitors/{i}\"\n    )\n    sim_final_predicted = sim_final_predicted.updated_copy(\n        freqs=freqs_measure, path=f\"monitors/{i + num_freqs_design}\"\n    )\n</pre> sim_final_predicted = get_sim(     params_history[iter_final], beta=beta_history[iter_final], use_predict=True )  for i in range(num_freqs_design):     sim_final_predicted = sim_final_predicted.updated_copy(         freqs=freqs_measure, path=f\"monitors/{i}\"     )     sim_final_predicted = sim_final_predicted.updated_copy(         freqs=freqs_measure, path=f\"monitors/{i + num_freqs_design}\"     ) <p>The predicted fabrication variations show some notable differences from the ideal design, such as the filled-in hole in the bottom left. However, most variations are quite subtle at this scale and resolution. Despite the seemingly minor geometric differences, these variations lead to meaningful changes in device performance, which we will analyze in the next section.</p> In\u00a0[33]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))\nsim_final_predicted.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0, ax=ax1)\nax1.set_title(\"predicted cross section at z=0.01\")\nsim_final.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0, ax=ax2)\nax2.set_title(\"idealized cross section at z=0.01\")\nplt.show()\n</pre> fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6)) sim_final_predicted.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0, ax=ax1) ax1.set_title(\"predicted cross section at z=0.01\") sim_final.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0, ax=ax2) ax2.set_title(\"idealized cross section at z=0.01\") plt.show() In\u00a0[34]: Copied! <pre>sim_data_final_predicted = web.run(\n    sim_final_predicted, verbose=False, task_name=\"wdm_final_predicted\"\n)\n</pre> sim_data_final_predicted = web.run(     sim_final_predicted, verbose=False, task_name=\"wdm_final_predicted\" ) In\u00a0[35]: Copied! <pre>def plot_flux(sim_data, title, linestyle=\"-\"):\n    for i in range(num_freqs_design):\n        freq = freqs_design[i]\n        flux_data = sim_data[mnts_flux[i].name]\n        wvl_nm = 1000 * td.C_0 / freq\n        wavelengths_nm = 1000 * td.C_0 / np.array(flux_data.flux.f)\n        flux = np.array(flux_data.flux.values)\n        loss_db = 10 * np.log10(flux)\n        label = f\"channel @ {int(wvl_nm)} nm\"\n        fmin, fmax = channel_bounds[i]\n        plt.gca().axvspan(1000 * td.C_0 / fmin, 1000 * td.C_0 / fmax, alpha=0.2)\n        plt.plot(wavelengths_nm, loss_db, label=label, linestyle=linestyle)\n        plt.scatter([wvl_nm], [0], 100, marker=\"*\")\n        plt.xlabel(\"wavelength (nm)\")\n        plt.ylabel(\"insertion loss (dB)\")\n        plt.legend()\n        plt.grid(\"on\")\n    plt.title(title)\n    plt.show()\n\n\nplot_flux(sim_data_final_predicted, \"total flux (with fabrication prediction)\")\nplot_flux(sim_data_final, \"total flux (without fabrication prediction)\", linestyle=\"--\")\n</pre> def plot_flux(sim_data, title, linestyle=\"-\"):     for i in range(num_freqs_design):         freq = freqs_design[i]         flux_data = sim_data[mnts_flux[i].name]         wvl_nm = 1000 * td.C_0 / freq         wavelengths_nm = 1000 * td.C_0 / np.array(flux_data.flux.f)         flux = np.array(flux_data.flux.values)         loss_db = 10 * np.log10(flux)         label = f\"channel @ {int(wvl_nm)} nm\"         fmin, fmax = channel_bounds[i]         plt.gca().axvspan(1000 * td.C_0 / fmin, 1000 * td.C_0 / fmax, alpha=0.2)         plt.plot(wavelengths_nm, loss_db, label=label, linestyle=linestyle)         plt.scatter([wvl_nm], [0], 100, marker=\"*\")         plt.xlabel(\"wavelength (nm)\")         plt.ylabel(\"insertion loss (dB)\")         plt.legend()         plt.grid(\"on\")     plt.title(title)     plt.show()   plot_flux(sim_data_final_predicted, \"total flux (with fabrication prediction)\") plot_flux(sim_data_final, \"total flux (without fabrication prediction)\", linestyle=\"--\")  In\u00a0[36]: Copied! <pre>def plot_power(sim_data, title, linestyle=\"-\"):\n    for i in range(num_freqs_design):\n        freq = freqs_design[i]\n        amps = sim_data[mnts_mode[i].name].amps\n        powers = np.abs(amps.sel(direction=\"+\", mode_index=0)) ** 2\n        wvl_nm = 1000 * td.C_0 / freq\n        flux_data = sim_data[mnts_flux[i].name]\n        wavelengths_nm = 1000 * td.C_0 / np.array(flux_data.flux.f)\n        flux = np.array(powers.values)\n        loss_db = 10 * np.log10(flux)\n        label = f\"channel @ {int(wvl_nm)} nm\"\n        fmin, fmax = channel_bounds[i]\n        plt.gca().axvspan(1000 * td.C_0 / fmin, 1000 * td.C_0 / fmax, alpha=0.2)\n        plt.plot(wavelengths_nm, loss_db, label=label, linestyle=linestyle)\n        plt.scatter([wvl_nm], [0], 100, marker=\"*\")\n        plt.xlabel(\"wavelength (nm)\")\n        plt.ylabel(\"insertion loss (dB)\")\n        plt.legend()\n        plt.grid(\"on\")\n    plt.title(title)\n    plt.show()\n\n\nplot_power(\n    sim_data_final_predicted, \"power at mode_index=0 (with fabrication prediction)\"\n)\nplot_power(\n    sim_data_final,\n    \"power at mode_index=0 (without fabrication prediction)\",\n    linestyle=\"--\",\n)\n</pre> def plot_power(sim_data, title, linestyle=\"-\"):     for i in range(num_freqs_design):         freq = freqs_design[i]         amps = sim_data[mnts_mode[i].name].amps         powers = np.abs(amps.sel(direction=\"+\", mode_index=0)) ** 2         wvl_nm = 1000 * td.C_0 / freq         flux_data = sim_data[mnts_flux[i].name]         wavelengths_nm = 1000 * td.C_0 / np.array(flux_data.flux.f)         flux = np.array(powers.values)         loss_db = 10 * np.log10(flux)         label = f\"channel @ {int(wvl_nm)} nm\"         fmin, fmax = channel_bounds[i]         plt.gca().axvspan(1000 * td.C_0 / fmin, 1000 * td.C_0 / fmax, alpha=0.2)         plt.plot(wavelengths_nm, loss_db, label=label, linestyle=linestyle)         plt.scatter([wvl_nm], [0], 100, marker=\"*\")         plt.xlabel(\"wavelength (nm)\")         plt.ylabel(\"insertion loss (dB)\")         plt.legend()         plt.grid(\"on\")     plt.title(title)     plt.show()   plot_power(     sim_data_final_predicted, \"power at mode_index=0 (with fabrication prediction)\" ) plot_power(     sim_data_final,     \"power at mode_index=0 (without fabrication prediction)\",     linestyle=\"--\", )  In\u00a0[37]: Copied! <pre># plot fields at the two design wavelengths\n\nfig, axes = plt.subplots(\n    1, num_freqs_design, tight_layout=True, figsize=(15, 0.8 * num_freqs_design)\n)\n\nfor freq, ax in zip(freqs_design, axes):\n    sim_data_final_predicted.plot_field(\"field\", \"E\", \"abs^2\", f=freq, ax=ax, vmax=1200)\n    wvl = 1000 * td.C_0 / freq\n    ax.set_title(f\"wavelength = {int(wvl)} nm\")\n</pre> # plot fields at the two design wavelengths  fig, axes = plt.subplots(     1, num_freqs_design, tight_layout=True, figsize=(15, 0.8 * num_freqs_design) )  for freq, ax in zip(freqs_design, axes):     sim_data_final_predicted.plot_field(\"field\", \"E\", \"abs^2\", f=freq, ax=ax, vmax=1200)     wvl = 1000 * td.C_0 / freq     ax.set_title(f\"wavelength = {int(wvl)} nm\") In\u00a0[38]: Copied! <pre>import matplotlib.animation as animation\nfrom IPython.display import HTML\n\nfig, ax1 = fig, axes = plt.subplots(1, 1, tight_layout=False, figsize=(9, 4))\n\n\ndef animate(i):\n    sim_i = get_sim(params_history[i], beta_history[i])\n    sim_i.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0, ax=ax1)\n    ax1.set_aspect(\"equal\")\n\n\n# create animation\nani = animation.FuncAnimation(fig, animate, frames=len(beta_history))\nplt.close()\n</pre> import matplotlib.animation as animation from IPython.display import HTML  fig, ax1 = fig, axes = plt.subplots(1, 1, tight_layout=False, figsize=(9, 4))   def animate(i):     sim_i = get_sim(params_history[i], beta_history[i])     sim_i.plot_eps(z=0.01, monitor_alpha=0, source_alpha=0, ax=ax1)     ax1.set_aspect(\"equal\")   # create animation ani = animation.FuncAnimation(fig, animate, frames=len(beta_history)) plt.close() In\u00a0[39]: Copied! <pre># display the animation (press \"play\" to start)\nHTML(ani.to_jshtml())\n</pre> # display the animation (press \"play\" to start) HTML(ani.to_jshtml()) Out[39]: Once Loop Reflect <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> <p>To save the animation as a file, uncomment the line below</p> <p>Note: can take several more minutes to complete</p> In\u00a0[40]: Copied! <pre># ani.save(\"img/animation_wdm_autograd.gif\", fps=30)\n</pre> # ani.save(\"img/animation_wdm_autograd.gif\", fps=30) In\u00a0[41]: Copied! <pre># sim_final.to_gds_file(\n#     fname=\"./misc/inv_des_wdm_ag_FAID.gds\",\n#     z=0,\n#     permittivity_threshold=(n_si**2 + 1) / 2,\n#     frequency=freq0,\n# )\n</pre> # sim_final.to_gds_file( #     fname=\"./misc/inv_des_wdm_ag_FAID.gds\", #     z=0, #     permittivity_threshold=(n_si**2 + 1) / 2, #     frequency=freq0, # ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/6_fabrication-aware_inverse_design/#fabrication-aware-inverse-design","title":"Fabrication-aware inverse design\u00b6","text":"<p>This notebook extends the Adjoint Optimization of a Wavelength Division Multiplexer by incorporating fabrication awareness into the design process. Specifically, we integrate a differentiable computer vision model into the topology optimization loop to predict and optimize the manufacturability of photonic device designs. This approach, known as fabrication-aware inverse design (FAID), results in devices that are inherently more robust to fabrication variations.</p> <p>Unlike optical proximity correction (OPC), which adjusts designs to compensate for lithography-induced distortions after the design phase, FAID directly optimizes for manufacturable designs by using fabrication predictions within the design loop. While OPC can enhance design fidelity, it may not ensure manufacturability for complex features. FAID focuses on creating features that are inherently realizable by the fabrication process, leading to designs that are more practical to manufacture.</p> <p>For a deeper look at the FAID concept, refer to this paper by Lukas Chrostowski's group at the University of British Columbia.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#predicting-device-performance","title":"Predicting Device Performance\u00b6","text":"<p>Using the prediction model, we can simulate the expected experimental performance of device designs such as the wavelength division multiplexer (WDM) in the Adjoint Optimization of a Wavelength Division Multiplexer. The WDM was optimized with a relatively large feature size and an erosion/dilation penalty to enhance robustness against fabrication variations. This optimization allows it to tolerate predicted fabrication variations quite well; however, some performance degradation is still observed. As illustrated in the figure below, the fabrication-predicted transmission spectra get distorted, insertion loss is increased, and further crosstalk is introduced. This performance degradation can be mitigated with FAID.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/","title":"\u00b6","text":""},{"location":"examples/6_fabrication-aware_inverse_design/","title":"\u00b6","text":""},{"location":"examples/6_fabrication-aware_inverse_design/#sim-setup","title":"Sim Setup\u00b6","text":"<p>Then we set up our basic simulation for the FAID optimization.</p> <p>We have an input waveguide connected to a square design region, which has <code>n=4</code> output waveguides.</p> <p>The square design region is a custom medium with a pixelated permittivity grid that we wish to optimize such that input light of different wavelengths gets directed to different output ports.</p> <p>As this is a SOI device, we typically define the design region and waveguides as Silicon sitting on a SiO2 substrate. For this demo, we make a 2D simulation, but it can be easily made 3D by changing the <code>Lz</code> parameter, adding dimension to the structures, and adding a substrate.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#base-simulation","title":"Base Simulation\u00b6","text":"<p>First, we'll define the simulation without any design region using the \"base\" components that don't change over the optimization.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#solving-modes","title":"Solving modes\u00b6","text":"<p>Next, we want to ensure that we are injecting and measuring the right waveguide modes at each of the ports.</p> <p>We'll use <code>tidy3d</code>'s <code>ModeSolver</code> to analyze the modes of our input waveguide.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#define-design-region","title":"Define design region\u00b6","text":"<p>Next, we define the design region as a pixelated grid of permittivity values that get generated from our optimization parameters.</p> <p>We first define the overall geometry as a <code>td.Box</code> and also the number of pixels in x and y based on our design region resolution.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#construct-simulation","title":"Construct Simulation\u00b6","text":"<p>With all of these functions and variables defined, we can write a single function to return our \"base\" <code>td.Simulation</code> as a function of our design parameters. This function first constructs the design region, a mesh override structure to control the resolution in this region, and then creates a copy of the original <code>td.Simulation</code> with all of the basic parameters.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#defining-objective-function","title":"Defining Objective Function\u00b6","text":"<p>With our simulation fully defined as a function of our parameters, we are ready to define our objective function.</p> <p>In this case, it is quite simple, we simply measure the transmitted power in our <code>num_freqs = 4</code> output waveguide modes for each of the <code>num_freqs = 4</code> design frequencies.</p> <p>Our objective when looking at waveguide <code>i</code> will be to maximize power transmission at frequency <code>i</code>. To reduce cross talk between waveguide <code>i</code> and frequency <code>j != i</code>, we will subtract the average of the power transmissions for all of the other ports.</p> <p>Our overall metric will then be the average</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#total-objective-function","title":"Total Objective function\u00b6","text":"<p>Then we write an <code>objective</code> function that constructs our simulation, runs it, measures our metric, and subtracts our penalty.</p> <p>Note: due to current limitations of the autograd support in tidy3d, when running broadband simulations, one must have only a single output 'port' in the forward simulation. Therefore, we split our problem into one simulation per output waveguide, and then run these in parallel using <code>web.run_async()</code>.</p> <p>For FAID: We set <code>use_predict=True</code> and <code>use_penalty=False</code>.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#differentiating-the-objective","title":"Differentiating the objective\u00b6","text":"<p>Finally, we can simply use <code>autograd</code> (<code>ag</code>) to transform this objective function into a function that returns our objective function value and our gradient, which we will feed to the optimizer.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#run-optimization","title":"Run Optimization\u00b6","text":"<p>Finally, we are ready to optimize our device. We will make use of the <code>optax</code> package to define an optimizer using the <code>adam</code> method, as we've done in the previous inverse design tutorials.</p> <p>We record a history of objective function values, and parameters, for visualization later.</p> <p>For FAID: The PreFab prediction will add close to a minute to the runtime of each iteration.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#visualize-results","title":"Visualize Results\u00b6","text":"<p>Let's visualize the results of our optimization.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#objective-function-vs-iteration","title":"Objective function vs Iteration\u00b6","text":"<p>First we inspect the objective function value as a function of optimization iteration number. We see that it steadily increases as expected.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#final-simulation","title":"Final Simulation\u00b6","text":"<p>Let's take a look at the final simulation, without the prediction model, which we grab from our history.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#flux","title":"Flux\u00b6","text":"<p>Let's inspect the flux over each of the output ports as a function of wavelength.</p> <p>We notice that the ports have peaks in transmission at their corresponding design wavelengths, and are suppressed at the other wavelengths, as expected!</p> <p>For FAID: Because we optimized the design based on the fabrication-predicted geometry, we observe that the predicted design has higher performance than the final idealized design. This is intended. This contrasts with non-FAID-based optimization, where the fabrication-predicted structures typically have lower performance than the ideal design due to unaccounted fabrication variations.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#fields","title":"Fields\u00b6","text":"<p>Let's also plot the field intensity patterns at each of the design wavelengths for the predicted design.</p> <p>We see from this plot the expected result that the power is directed to the design port at each frequency.</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#animation","title":"Animation\u00b6","text":"<p>Finally, we animate this plot as a function of iteration number. The animation shows the device quickly accomplishing our design objective.</p> <p>Note: can take a few minutes to complete</p>"},{"location":"examples/6_fabrication-aware_inverse_design/#export-to-gds","title":"Export to GDS\u00b6","text":"<p>The <code>Simulation</code> object has the .to_gds_file convenience function to export the final design to a <code>GDS</code> file. In addition to a file name, it is necessary to set a cross-sectional plane (<code>z = 0</code> in this case) on which to evaluate the geometry, a <code>frequency</code> to evaluate the permittivity, and a <code>permittivity_threshold</code> to define the shape boundaries in custom mediums. See the GDS export notebook for a detailed example on using <code>.to_gds_file</code> and other GDS related functions.</p> <p>For FAID: Even though we optimize based on the predicted (fabricated) structure, we export the final idealized (not predicted) design. By accounting for fabrication imperfections during optimization, we aim for the structure that is ultimately fabricated to perform at its best.</p>"},{"location":"examples/7_sidewall_simulation/","title":"Predicting, simulating, and correcting sidewall angle","text":"In\u00a0[1]: Copied! <pre>import cv2\nimport matplotlib.pylab as plt\nimport numpy as np\nimport tidy3d as td\nfrom tidy3d.constants import C_0\nfrom tidy3d.plugins.mode import ModeSolver\n\nimport prefab as pf\n</pre> import cv2 import matplotlib.pylab as plt import numpy as np import tidy3d as td from tidy3d.constants import C_0 from tidy3d.plugins.mode import ModeSolver  import prefab as pf In\u00a0[2]: Copied! <pre># size of simulation domain\nLx, Ly, Lz = 2, 4, 2\ndl = 0.01\n\n# waveguide information\nwg_width = 0.8\nwg_height = 0.4\nAir = td.Medium(permittivity=1.0**2)\nSiN = td.Medium(permittivity=2.0**2)\n\n# central frequency\nwvl_um = 1.55\nfreq0 = C_0 / wvl_um\nfwidth = freq0 / 6\n\n# run_time in ps\nrun_time = 1e-12\n\n# uniform grid specification\ngrid_spec = td.GridSpec.uniform(dl=dl)\n</pre> # size of simulation domain Lx, Ly, Lz = 2, 4, 2 dl = 0.01  # waveguide information wg_width = 0.8 wg_height = 0.4 Air = td.Medium(permittivity=1.0**2) SiN = td.Medium(permittivity=2.0**2)  # central frequency wvl_um = 1.55 freq0 = C_0 / wvl_um fwidth = freq0 / 6  # run_time in ps run_time = 1e-12  # uniform grid specification grid_spec = td.GridSpec.uniform(dl=dl) In\u00a0[3]: Copied! <pre>waveguide = td.Structure(\n    geometry=td.Box(size=(wg_width, td.inf, wg_height)),\n    medium=td.Medium(permittivity=SiN.permittivity),\n)\n\nsim = td.Simulation(\n    size=(Lx, Ly, Lz),\n    grid_spec=grid_spec,\n    structures=[waveguide],\n    run_time=run_time,\n    boundary_spec=td.BoundarySpec.all_sides(boundary=td.Periodic()),\n)\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 4))\nsim.plot_eps(z=0, ax=axs[0])\nsim.plot_eps(y=0, ax=axs[1])\nplt.show()\n</pre> waveguide = td.Structure(     geometry=td.Box(size=(wg_width, td.inf, wg_height)),     medium=td.Medium(permittivity=SiN.permittivity), )  sim = td.Simulation(     size=(Lx, Ly, Lz),     grid_spec=grid_spec,     structures=[waveguide],     run_time=run_time,     boundary_spec=td.BoundarySpec.all_sides(boundary=td.Periodic()), )  fig, axs = plt.subplots(1, 2, figsize=(10, 4)) sim.plot_eps(z=0, ax=axs[0]) sim.plot_eps(y=0, ax=axs[1]) plt.show() In\u00a0[4]: Copied! <pre>plane = td.Box(center=(0, 0, 0), size=(2, 0, 2))\n\nmode_spec = td.ModeSpec(\n    num_modes=2,\n    target_neff=1.45,\n)\n\nnum_freqs = 11\nf0_ind = num_freqs // 2\nfreqs = np.linspace(freq0 - fwidth / 2, freq0 + fwidth / 2, num_freqs)\n\nmode_solver = ModeSolver(\n    simulation=sim,\n    plane=plane,\n    mode_spec=mode_spec,\n    freqs=freqs,\n)\nmode_data = mode_solver.solve()\n</pre> plane = td.Box(center=(0, 0, 0), size=(2, 0, 2))  mode_spec = td.ModeSpec(     num_modes=2,     target_neff=1.45, )  num_freqs = 11 f0_ind = num_freqs // 2 freqs = np.linspace(freq0 - fwidth / 2, freq0 + fwidth / 2, num_freqs)  mode_solver = ModeSolver(     simulation=sim,     plane=plane,     mode_spec=mode_spec,     freqs=freqs, ) mode_data = mode_solver.solve() <pre>10:21:54 EST WARNING: Use the remote mode solver with subpixel averaging for    \n             better accuracy through 'tidy3d.plugins.mode.web.run(...)'.        \n</pre> <p>Next we use PreFab to predict how the nominal waveguide will actually be fabricated. Even for this simple waveguide structure, the fabrication process introduces imperfections - most notably non-vertical sidewalls. While other fabrication effects like sidewall roughness, layer thickness variation, and etch depth variation can be simulated, we'll focus only on sidewall angle for this example.</p> <p>First, we'll convert the simulation structure to an array for PreFab to process. We'll do this step-by-step to understand the process, though it could be abstracted into a function.</p> In\u00a0[5]: Copied! <pre># convert the simulation structure to an ndarray with 1 nm resolution\nX = np.arange(\n    sim.bounds[0][0],\n    sim.bounds[1][0],\n    0.001,\n)\nY = np.arange(\n    sim.bounds[0][1],\n    sim.bounds[1][1],\n    0.001,\n)\nZ = np.array([0])\ngrid = td.Grid(boundaries=td.Coords(x=X, y=Y, z=Z))\neps = np.real(sim.epsilon_on_grid(grid=grid, coord_key=\"boundaries\", freq=freq0).values)\neta = (eps.min() + eps.max()) / 2\ndevice_array = pf.geometry.binarize_hard(device_array=eps, eta=eta)[:, :, 0]\n\n# create a device object from the ndarray\nbuffer_spec = pf.BufferSpec(\n    mode={\"top\": \"edge\", \"bottom\": \"edge\", \"left\": \"edge\", \"right\": \"edge\"},\n    thickness={\"top\": 100, \"bottom\": 100, \"left\": 100, \"right\": 100},\n)\ndevice = pf.Device(\n    device_array=device_array,\n    buffer_spec=buffer_spec,\n)\ndevice.plot()\n</pre> # convert the simulation structure to an ndarray with 1 nm resolution X = np.arange(     sim.bounds[0][0],     sim.bounds[1][0],     0.001, ) Y = np.arange(     sim.bounds[0][1],     sim.bounds[1][1],     0.001, ) Z = np.array([0]) grid = td.Grid(boundaries=td.Coords(x=X, y=Y, z=Z)) eps = np.real(sim.epsilon_on_grid(grid=grid, coord_key=\"boundaries\", freq=freq0).values) eta = (eps.min() + eps.max()) / 2 device_array = pf.geometry.binarize_hard(device_array=eps, eta=eta)[:, :, 0]  # create a device object from the ndarray buffer_spec = pf.BufferSpec(     mode={\"top\": \"edge\", \"bottom\": \"edge\", \"left\": \"edge\", \"right\": \"edge\"},     thickness={\"top\": 100, \"bottom\": 100, \"left\": 100, \"right\": 100}, ) device = pf.Device(     device_array=device_array,     buffer_spec=buffer_spec, ) device.plot() Out[5]: <pre>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</pre> <p>Next we run the prediction for the SiN process from Applied Nanotools. We also run the correction and then the prediction again to get the final, best outcome. There is not much to be observed at this level of scale, other than the sidewall segment, but we will take a closer look in the next section.</p> <p>Note: If you would like to see models of other fabrication processes, please contact us at support@prefabphotonics.com to request them. Current models are listed here.</p> <p>We set <code>gpu=True</code> to speed up the prediction. Note that GPU predictions have a longer startup time, so smaller devices will run faster on the CPU (<code>gpu=False</code>). We set <code>binarize=True</code> to capture the most likely fabrication outcome, but we can also set <code>binarize=False</code> to get the full range of possible outcomes (more on this in a future notebook about prediction uncertainty and fabrication variability).</p> In\u00a0[6]: Copied! <pre>MODEL_NAME = \"ANT_SiN\"\nuse_gpu = True\n\nprediction = device.predict(model=pf.models[MODEL_NAME], binarize=True, gpu=use_gpu)\nax1 = prediction.plot()\nax1.set_title(\"Prediction\")\ncorrection = device.correct(model=pf.models[MODEL_NAME], binarize=True, gpu=use_gpu)\nax2 = correction.plot()\nax2.set_title(\"Correction\")\noutcome = correction.predict(model=pf.models[MODEL_NAME], binarize=True, gpu=use_gpu)\nax3 = outcome.plot()\nax3.set_title(\"Corrected Outcome\")\n</pre> MODEL_NAME = \"ANT_SiN\" use_gpu = True  prediction = device.predict(model=pf.models[MODEL_NAME], binarize=True, gpu=use_gpu) ax1 = prediction.plot() ax1.set_title(\"Prediction\") correction = device.correct(model=pf.models[MODEL_NAME], binarize=True, gpu=use_gpu) ax2 = correction.plot() ax2.set_title(\"Correction\") outcome = correction.predict(model=pf.models[MODEL_NAME], binarize=True, gpu=use_gpu) ax3 = outcome.plot() ax3.set_title(\"Corrected Outcome\") <pre>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:26&lt;00:00,  3.81%/s]\nCorrection: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 43.58%/s]\nPrediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 51.37%/s]\n</pre> Out[6]: <pre>Text(0.5, 1.0, 'Corrected Outcome')</pre> <p>PreFab represents sidewall angles using two layers: the bottom and top edges of the waveguide. We'll convert this 2D prediction into a 3D representation using a simple linear profile, though real sidewalls can have curved or more complex features.</p> In\u00a0[7]: Copied! <pre>resolution_3d = 0.3  # to reduce the array size for faster computation\n\n\ndef to_3d(prediction):\n    thickness_nm = wg_height * 1000\n\n    prediction_array = prediction.to_ndarray()\n\n    new_shape = tuple(int(dim * resolution_3d) for dim in prediction_array.shape[:2])\n    scaled_thickness = max(int(thickness_nm * resolution_3d), 2)\n\n    bottom_layer = cv2.resize(\n        prediction_array[:, :, 0],\n        (new_shape[1], new_shape[0]),\n        interpolation=cv2.INTER_LINEAR,\n    )\n    top_layer = cv2.resize(\n        prediction_array[:, :, -1],\n        (new_shape[1], new_shape[0]),\n        interpolation=cv2.INTER_LINEAR,\n    )\n\n    bottom_layer = (bottom_layer &gt; 0.5).astype(np.uint8)\n    top_layer = (top_layer &gt; 0.5).astype(np.uint8)\n\n    dt_bottom = cv2.distanceTransform(\n        bottom_layer, cv2.DIST_L2, 5\n    ) - cv2.distanceTransform(1 - bottom_layer, cv2.DIST_L2, 5)\n    dt_top = cv2.distanceTransform(top_layer, cv2.DIST_L2, 5) - cv2.distanceTransform(\n        1 - top_layer, cv2.DIST_L2, 5\n    )\n\n    weights = np.linspace(0, 1, scaled_thickness)\n    prediction_3d = np.zeros((new_shape[0], new_shape[1], scaled_thickness))\n\n    for i, w in enumerate(weights):\n        dt_interp = (1 - w) * dt_bottom + w * dt_top\n        prediction_3d[:, :, i] = 1 / (1 + np.exp(-dt_interp))\n\n    return prediction_3d\n\n\nprediction_3d = to_3d(prediction)\noutcome_3d = to_3d(outcome)\n</pre> resolution_3d = 0.3  # to reduce the array size for faster computation   def to_3d(prediction):     thickness_nm = wg_height * 1000      prediction_array = prediction.to_ndarray()      new_shape = tuple(int(dim * resolution_3d) for dim in prediction_array.shape[:2])     scaled_thickness = max(int(thickness_nm * resolution_3d), 2)      bottom_layer = cv2.resize(         prediction_array[:, :, 0],         (new_shape[1], new_shape[0]),         interpolation=cv2.INTER_LINEAR,     )     top_layer = cv2.resize(         prediction_array[:, :, -1],         (new_shape[1], new_shape[0]),         interpolation=cv2.INTER_LINEAR,     )      bottom_layer = (bottom_layer &gt; 0.5).astype(np.uint8)     top_layer = (top_layer &gt; 0.5).astype(np.uint8)      dt_bottom = cv2.distanceTransform(         bottom_layer, cv2.DIST_L2, 5     ) - cv2.distanceTransform(1 - bottom_layer, cv2.DIST_L2, 5)     dt_top = cv2.distanceTransform(top_layer, cv2.DIST_L2, 5) - cv2.distanceTransform(         1 - top_layer, cv2.DIST_L2, 5     )      weights = np.linspace(0, 1, scaled_thickness)     prediction_3d = np.zeros((new_shape[0], new_shape[1], scaled_thickness))      for i, w in enumerate(weights):         dt_interp = (1 - w) * dt_bottom + w * dt_top         prediction_3d[:, :, i] = 1 / (1 + np.exp(-dt_interp))      return prediction_3d   prediction_3d = to_3d(prediction) outcome_3d = to_3d(outcome) <p>Next we'll convert the 3D prediction into a new Tidy3D simulation.</p> In\u00a0[8]: Copied! <pre>def prediction_to_sim(prediction_3d, sim_base):\n    convert_scale = 1000 * resolution_3d\n\n    X = np.linspace(\n        sim.bounds[0][0],\n        sim.bounds[1][0],\n        prediction_3d.shape[0],\n    )\n    Y = np.linspace(\n        sim.bounds[0][1],\n        sim.bounds[1][1],\n        prediction_3d.shape[1],\n    )\n    Z = np.linspace(\n        -prediction_3d.shape[2] / 2 / convert_scale,\n        prediction_3d.shape[2] / 2 / convert_scale,\n        prediction_3d.shape[2],\n    )\n\n    eps_array = prediction_3d * (SiN.permittivity - Air.permittivity) + Air.permittivity\n    eps_dataset = td.SpatialDataArray(eps_array, coords=dict(x=X, y=Y, z=Z))\n    medium = td.CustomMedium(permittivity=eps_dataset)\n    wg_p = td.Structure(\n        geometry=td.Box(center=(0, 0, 0), size=(td.inf, td.inf, wg_height), attrs={}),\n        medium=medium,\n        attrs={},\n    )\n\n    return sim_base.copy(update=dict(structures=[wg_p]))\n\n\nsim_p = prediction_to_sim(prediction_3d, sim)\nsim_o = prediction_to_sim(outcome_3d, sim)\n</pre> def prediction_to_sim(prediction_3d, sim_base):     convert_scale = 1000 * resolution_3d      X = np.linspace(         sim.bounds[0][0],         sim.bounds[1][0],         prediction_3d.shape[0],     )     Y = np.linspace(         sim.bounds[0][1],         sim.bounds[1][1],         prediction_3d.shape[1],     )     Z = np.linspace(         -prediction_3d.shape[2] / 2 / convert_scale,         prediction_3d.shape[2] / 2 / convert_scale,         prediction_3d.shape[2],     )      eps_array = prediction_3d * (SiN.permittivity - Air.permittivity) + Air.permittivity     eps_dataset = td.SpatialDataArray(eps_array, coords=dict(x=X, y=Y, z=Z))     medium = td.CustomMedium(permittivity=eps_dataset)     wg_p = td.Structure(         geometry=td.Box(center=(0, 0, 0), size=(td.inf, td.inf, wg_height), attrs={}),         medium=medium,         attrs={},     )      return sim_base.copy(update=dict(structures=[wg_p]))   sim_p = prediction_to_sim(prediction_3d, sim) sim_o = prediction_to_sim(outcome_3d, sim) <p>Observing the cross-section of the simulation, we can see that the prediction indeed has a sidewall angle, where the top edge is narrower than the nominal width. The corrected waveguide still has angled sidewalls, as we cannot structurally correct for sidewall angle with lithographic OPC techniques, but its full width at half maximum height matches the nominal waveguide, resulting in the same effective index (as we'll see in the next section).</p> In\u00a0[16]: Copied! <pre>fig, axs = plt.subplots(3, 1, figsize=(8, 15))\n\nsim.plot_eps(y=0, ax=axs[0])\naxs[0].axvline(x=-wg_width / 2, color=\"k\", linestyle=\"--\")\naxs[0].axvline(x=wg_width / 2, color=\"k\", linestyle=\"--\")\naxs[0].set_title(\"Nominal Cross-Section\")\n\nsim_p.plot_eps(y=0, ax=axs[1])\naxs[1].axvline(x=-wg_width / 2, color=\"r\", linestyle=\"--\")\naxs[1].axvline(x=wg_width / 2, color=\"r\", linestyle=\"--\")\naxs[1].set_title(\"Predicted Cross-Section\")\n\nsim_o.plot_eps(y=0, ax=axs[2])\naxs[2].axvline(x=-wg_width / 2, color=\"g\", linestyle=\"--\")\naxs[2].axvline(x=wg_width / 2, color=\"g\", linestyle=\"--\")\naxs[2].set_title(\"Corrected Cross-Section\")\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axs = plt.subplots(3, 1, figsize=(8, 15))  sim.plot_eps(y=0, ax=axs[0]) axs[0].axvline(x=-wg_width / 2, color=\"k\", linestyle=\"--\") axs[0].axvline(x=wg_width / 2, color=\"k\", linestyle=\"--\") axs[0].set_title(\"Nominal Cross-Section\")  sim_p.plot_eps(y=0, ax=axs[1]) axs[1].axvline(x=-wg_width / 2, color=\"r\", linestyle=\"--\") axs[1].axvline(x=wg_width / 2, color=\"r\", linestyle=\"--\") axs[1].set_title(\"Predicted Cross-Section\")  sim_o.plot_eps(y=0, ax=axs[2]) axs[2].axvline(x=-wg_width / 2, color=\"g\", linestyle=\"--\") axs[2].axvline(x=wg_width / 2, color=\"g\", linestyle=\"--\") axs[2].set_title(\"Corrected Cross-Section\")  plt.tight_layout() plt.show() <p>Run the mode solver again!</p> In\u00a0[14]: Copied! <pre>mode_solver_p = ModeSolver(\n    simulation=sim_p,\n    plane=plane,\n    mode_spec=mode_spec,\n    freqs=freqs,\n)\nmode_data_p = mode_solver_p.solve()\n\nmode_solver_o = ModeSolver(\n    simulation=sim_o,\n    plane=plane,\n    mode_spec=mode_spec,\n    freqs=freqs,\n)\nmode_data_o = mode_solver_o.solve()\n</pre> mode_solver_p = ModeSolver(     simulation=sim_p,     plane=plane,     mode_spec=mode_spec,     freqs=freqs, ) mode_data_p = mode_solver_p.solve()  mode_solver_o = ModeSolver(     simulation=sim_o,     plane=plane,     mode_spec=mode_spec,     freqs=freqs, ) mode_data_o = mode_solver_o.solve() <p>Here we see how the effective index is reduced for the predicted waveguide, which makes sense as the volume of the SiN is reduced. The corrected waveguide has the same effective index as the nominal waveguide, as expected. With the relatively low refractive index of SiN, the effective index is only reduced by a few percent, but this effect can be more significant for silicon and other high-index materials.</p> In\u00a0[17]: Copied! <pre>lams = C_0 / freqs\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 10))\n\n# nominal and predicted\naxs[0].plot(lams, mode_data.n_eff[:, 0], \"b-\", label=\"Nominal Mode 1\")\naxs[0].plot(lams, mode_data.n_eff[:, 1], \"b--\", label=\"Nominal Mode 2\")\naxs[0].plot(lams, mode_data_p.n_eff[:, 0], \"r-\", label=\"Predicted Mode 1\")\naxs[0].plot(lams, mode_data_p.n_eff[:, 1], \"r--\", label=\"Predicted Mode 2\")\naxs[0].legend()\naxs[0].set_title(\"Nominal vs Predicted Effective Index\")\naxs[0].set_xlabel(\"Wavelength\")\naxs[0].set_ylabel(\"Effective Index\")\n\n# nominal and corrected outcome\naxs[1].plot(lams, mode_data.n_eff[:, 0], \"b-\", label=\"Nominal Mode 1\")\naxs[1].plot(lams, mode_data.n_eff[:, 1], \"b--\", label=\"Nominal Mode 2\")\naxs[1].plot(lams, mode_data_o.n_eff[:, 0], \"g-\", label=\"Corrected Mode 1\")\naxs[1].plot(lams, mode_data_o.n_eff[:, 1], \"g--\", label=\"Corrected Mode 2\")\naxs[1].legend()\naxs[1].set_title(\"Nominal vs Corrected Effective Index\")\naxs[1].set_xlabel(\"Wavelength\")\naxs[1].set_ylabel(\"Effective Index\")\n\nplt.tight_layout()\nplt.show()\n</pre> lams = C_0 / freqs  fig, axs = plt.subplots(2, 1, figsize=(8, 10))  # nominal and predicted axs[0].plot(lams, mode_data.n_eff[:, 0], \"b-\", label=\"Nominal Mode 1\") axs[0].plot(lams, mode_data.n_eff[:, 1], \"b--\", label=\"Nominal Mode 2\") axs[0].plot(lams, mode_data_p.n_eff[:, 0], \"r-\", label=\"Predicted Mode 1\") axs[0].plot(lams, mode_data_p.n_eff[:, 1], \"r--\", label=\"Predicted Mode 2\") axs[0].legend() axs[0].set_title(\"Nominal vs Predicted Effective Index\") axs[0].set_xlabel(\"Wavelength\") axs[0].set_ylabel(\"Effective Index\")  # nominal and corrected outcome axs[1].plot(lams, mode_data.n_eff[:, 0], \"b-\", label=\"Nominal Mode 1\") axs[1].plot(lams, mode_data.n_eff[:, 1], \"b--\", label=\"Nominal Mode 2\") axs[1].plot(lams, mode_data_o.n_eff[:, 0], \"g-\", label=\"Corrected Mode 1\") axs[1].plot(lams, mode_data_o.n_eff[:, 1], \"g--\", label=\"Corrected Mode 2\") axs[1].legend() axs[1].set_title(\"Nominal vs Corrected Effective Index\") axs[1].set_xlabel(\"Wavelength\") axs[1].set_ylabel(\"Effective Index\")  plt.tight_layout() plt.show() <p>That's it for this simple tutorial. We see how sidewall angle can be predicted and corrected with PreFab. The same process can be applied to complex device designs with many features. When applying this to your own designs, you may observe that the angle varies by feature type - an interesting process characteristic - but the same correction approach still applies.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/7_sidewall_simulation/#predicting-simulating-and-correcting-sidewall-angle","title":"Predicting, simulating, and correcting sidewall angle\u00b6","text":""},{"location":"examples/7_sidewall_simulation/#introduction","title":"Introduction\u00b6","text":"<p>This notebook example provides a guide to predicting and simulating the effective refractive index of a waveguide with an angled sidewall. While sidewall angle is an effect of the etching process, and we cannot correct the structure with lithographic techniques, we can adjust the dimensions of the design to achieve a similar effective structure. This tutorial adapts and extends the mode solver example from Tidy3D and is organized into the three following sections:</p> <ol> <li>Setup a nominal simulation of a silicon nitride (SiN) waveguide with Tidy3D's <code>ModeSolver</code>.</li> <li>Predict and compare the structures using PreFab.</li> <li>Simulate and evaluate the difference in effective index for the nominal, predicted, and corrected structures.</li> </ol> <p>We first import the necessary libraries:</p>"},{"location":"examples/7_sidewall_simulation/#nominal-simulation","title":"Nominal simulation\u00b6","text":"<p>We start with a simple nominal mode simulation of a SiN waveguide with Tidy3D's <code>ModeSolver</code>. We will visualize the results in the comparison at the end.</p>"},{"location":"examples/7_sidewall_simulation/#prefab-prediction","title":"PreFab prediction\u00b6","text":""},{"location":"examples/7_sidewall_simulation/#simulation-of-sidewall-angle","title":"Simulation of sidewall angle\u00b6","text":""},{"location":"reference/compare/","title":"Compare","text":"<p>Functions to measure the structural similarity between devices.</p>"},{"location":"reference/compare/#prefab.compare.dice_coefficient","title":"<code>dice_coefficient(device_a, device_b)</code>","text":"<p>Calculates the Dice coefficient between two binary devices. A value closer to 1 indicates more similarity. The Dice coefficient is calculated as twice the number of pixels in common divided by the total number of pixels in the two devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (binarized).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Dice coefficient between two devices.</p> Warnings <p>UserWarning     If one or both devices are not binarized.</p> Source code in <code>prefab/compare.py</code> <pre><code>def dice_coefficient(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Dice coefficient between two binary devices. A value closer to 1\n    indicates more similarity. The Dice coefficient is calculated as twice the number of\n    pixels in common divided by the total number of pixels in the two devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (binarized).\n    device_b : Device\n        The second device (binarized).\n\n    Returns\n    -------\n    float\n        The Dice coefficient between two devices.\n\n    Warnings\n    --------\n    UserWarning\n        If one or both devices are not binarized.\n    \"\"\"\n    if not device_a.is_binary or not device_b.is_binary:\n        warnings.warn(\n            \"One or both devices are not binarized.\", UserWarning, stacklevel=2\n        )\n\n    intersection = 2.0 * np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    )\n    size_a = np.sum(device_a.device_array)\n    size_b = np.sum(device_b.device_array)\n    return intersection / (size_a + size_b)\n</code></pre>"},{"location":"reference/compare/#prefab.compare.hamming_distance","title":"<code>hamming_distance(device_a, device_b)</code>","text":"<p>Calculates the Hamming distance between two binary devices. A lower value indicates more similarity. The Hamming distance is calculated as the number of positions at which the corresponding pixels are different.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (binarized).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Hamming distance between two devices.</p> Warnings <p>UserWarning     If one or both devices are not binarized.</p> Source code in <code>prefab/compare.py</code> <pre><code>def hamming_distance(device_a: Device, device_b: Device) -&gt; int:\n    \"\"\"\n    Calculates the Hamming distance between two binary devices. A lower value indicates\n    more similarity. The Hamming distance is calculated as the number of positions at\n    which the corresponding pixels are different.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (binarized).\n    device_b : Device\n        The second device (binarized).\n\n    Returns\n    -------\n    int\n        The Hamming distance between two devices.\n\n    Warnings\n    --------\n    UserWarning\n        If one or both devices are not binarized.\n    \"\"\"\n    if not device_a.is_binary or not device_b.is_binary:\n        warnings.warn(\n            \"One or both devices are not binarized.\", UserWarning, stacklevel=2\n        )\n\n    return int(np.sum(device_a.device_array != device_b.device_array))\n</code></pre>"},{"location":"reference/compare/#prefab.compare.intersection_over_union","title":"<code>intersection_over_union(device_a, device_b)</code>","text":"<p>Calculates the Intersection over Union (IoU) between two binary devices. A value closer to 1 indicates more similarity (more overlap).</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (binarized).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Intersection over Union between two devices.</p> Warnings <p>UserWarning     If one or both devices are not binarized.</p> Source code in <code>prefab/compare.py</code> <pre><code>def intersection_over_union(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Intersection over Union (IoU) between two binary devices. A value\n    closer to 1 indicates more similarity (more overlap).\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (binarized).\n    device_b : Device\n        The second device (binarized).\n\n    Returns\n    -------\n    float\n        The Intersection over Union between two devices.\n\n    Warnings\n    --------\n    UserWarning\n        If one or both devices are not binarized.\n    \"\"\"\n    if not device_a.is_binary or not device_b.is_binary:\n        warnings.warn(\n            \"One or both devices are not binarized.\", UserWarning, stacklevel=2\n        )\n\n    return np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    ) / np.sum(np.logical_or(device_a.device_array, device_b.device_array))\n</code></pre>"},{"location":"reference/compare/#prefab.compare.mean_squared_error","title":"<code>mean_squared_error(device_a, device_b)</code>","text":"<p>Calculate the mean squared error (MSE) between two devices. A lower value indicates more similarity.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device.</p> required <code>device_b</code> <code>Device</code> <p>The second device.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean squared error between two devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def mean_squared_error(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between two devices. A lower value indicates\n    more similarity.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The mean squared error between two devices.\n    \"\"\"\n    return float(np.mean((device_a.device_array - device_b.device_array) ** 2))\n</code></pre>"},{"location":"reference/device/","title":"Device","text":"<p>Provides the Device class for representing photonic devices.</p>"},{"location":"reference/device/#prefab.device.BufferSpec","title":"<code>BufferSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the specifications for a buffer zone around a device.</p> <p>This class is used to specify the mode and thickness of a buffer zone that is added around the device geometry. The buffer zone can be used for various purposes such as providing extra space for device fabrication processes or for ensuring that the device is isolated from surrounding structures.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict[str, str]</code> <p>A dictionary that defines the buffer mode for each side of the device ('top', 'bottom', 'left', 'right'), where: - 'constant' is used for isolated structures - 'edge' is utilized for preserving the edge, such as for waveguide connections - 'none' for no buffer on that side</p> required <code>thickness</code> <code>dict[str, int]</code> <p>A dictionary that defines the thickness of the buffer zone for each side of the device ('top', 'bottom', 'left', 'right'). Each value must be greater than or equal to 0.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the modes specified in the 'mode' dictionary are not one of the allowed values ('constant', 'edge', 'none'). Or if any of the thickness values are negative.</p> Example <pre><code>import prefab as pf\n\nbuffer_spec = pf.BufferSpec(\n    mode={\n        \"top\": \"constant\",\n        \"bottom\": \"none\",\n        \"left\": \"constant\",\n        \"right\": \"edge\",\n    },\n    thickness={\n        \"top\": 150,\n        \"bottom\": 0,\n        \"left\": 200,\n        \"right\": 250,\n    },\n)\n</code></pre> Source code in <code>prefab/device.py</code> <pre><code>class BufferSpec(BaseModel):\n    \"\"\"\n    Defines the specifications for a buffer zone around a device.\n\n    This class is used to specify the mode and thickness of a buffer zone that is added\n    around the device geometry. The buffer zone can be used for various purposes such as\n    providing extra space for device fabrication processes or for ensuring that the\n    device is isolated from surrounding structures.\n\n    Parameters\n    ----------\n    mode : dict[str, str]\n        A dictionary that defines the buffer mode for each side of the device\n        ('top', 'bottom', 'left', 'right'), where:\n        - 'constant' is used for isolated structures\n        - 'edge' is utilized for preserving the edge, such as for waveguide connections\n        - 'none' for no buffer on that side\n    thickness : dict[str, int]\n        A dictionary that defines the thickness of the buffer zone for each side of the\n        device ('top', 'bottom', 'left', 'right'). Each value must be greater than or\n        equal to 0.\n\n    Raises\n    ------\n    ValueError\n        If any of the modes specified in the 'mode' dictionary are not one of the\n        allowed values ('constant', 'edge', 'none'). Or if any of the thickness values\n        are negative.\n\n    Example\n    -------\n        import prefab as pf\n\n        buffer_spec = pf.BufferSpec(\n            mode={\n                \"top\": \"constant\",\n                \"bottom\": \"none\",\n                \"left\": \"constant\",\n                \"right\": \"edge\",\n            },\n            thickness={\n                \"top\": 150,\n                \"bottom\": 0,\n                \"left\": 200,\n                \"right\": 250,\n            },\n        )\n    \"\"\"\n\n    mode: dict[str, Literal[\"constant\", \"edge\", \"none\"]] = Field(\n        default_factory=lambda: {\n            \"top\": \"constant\",\n            \"bottom\": \"constant\",\n            \"left\": \"constant\",\n            \"right\": \"constant\",\n        }\n    )\n    thickness: dict[str, int] = Field(\n        default_factory=lambda: {\n            \"top\": 128,\n            \"bottom\": 128,\n            \"left\": 128,\n            \"right\": 128,\n        }\n    )\n\n    @validator(\"mode\", pre=True)\n    def check_mode(cls, v):\n        allowed_modes = [\"constant\", \"edge\", \"none\"]\n        if not all(mode in allowed_modes for mode in v.values()):\n            raise ValueError(f\"Buffer mode must be one of {allowed_modes}, got '{v}'.\")\n        return v\n\n    @validator(\"thickness\")\n    def check_thickness(cls, v):\n        if not all(t &gt;= 0 for t in v.values()):\n            raise ValueError(\"All thickness values must be greater than or equal to 0.\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def check_none_thickness(cls, values):\n        mode = values.mode\n        thickness = values.thickness\n        for side in mode:\n            if mode[side] == \"none\" and thickness[side] != 0:\n                raise ValueError(\n                    f\"Thickness must be 0 when mode is 'none' for {side} side\"\n                )\n            if mode[side] != \"none\" and thickness[side] == 0:\n                raise ValueError(\n                    f\"Mode must be 'none' when thickness is 0 for {side} side\"\n                )\n        return values\n</code></pre>"},{"location":"reference/device/#prefab.device.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>prefab/device.py</code> <pre><code>class Device(BaseModel):\n    device_array: np.ndarray = Field(...)\n    buffer_spec: BufferSpec = Field(default_factory=BufferSpec)\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        return tuple(self.device_array.shape)\n\n    def __init__(\n        self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n    ):\n        \"\"\"\n        Represents the planar geometry of a photonic device design that will have its\n        nanofabrication outcome predicted and/or corrected.\n\n        This class is designed to encapsulate the geometric representation of a photonic\n        device, facilitating operations such as padding, normalization, binarization,\n        erosion/dilation, trimming, and blurring. These operations are useful for\n        preparingthe device design for prediction or correction. Additionally, the class\n        providesmethods for exporting the device representation to various formats,\n        includingndarray, image files, and GDSII files, supporting a range of analysis\n        and fabrication workflows.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            A 2D array representing the planar geometry of the device. This array\n            undergoes various transformations to predict or correct the nanofabrication\n            process.\n        buffer_spec : Optional[BufferSpec]\n            Defines the parameters for adding a buffer zone around the device geometry.\n            This buffer zone is needed for providing surrounding context for prediction\n            or correction and for ensuring seamless integration with the surrounding\n            circuitry. By default, a generous padding is applied to accommodate isolated\n            structures.\n\n        Attributes\n        ----------\n        shape : tuple[int, int]\n            The shape of the device array.\n\n        Raises\n        ------\n        ValueError\n            If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n            indicating an invalid device geometry.\n        \"\"\"\n        super().__init__(\n            device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n        )\n        self._initial_processing()\n\n    def __call__(self, *args, **kwargs):\n        return self.plot(*args, **kwargs)\n\n    def _initial_processing(self):\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        if buffer_mode[\"top\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((buffer_thickness[\"top\"], 0), (0, 0)),\n                mode=buffer_mode[\"top\"],\n            )\n\n        if buffer_mode[\"bottom\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((0, buffer_thickness[\"bottom\"]), (0, 0)),\n                mode=buffer_mode[\"bottom\"],\n            )\n\n        if buffer_mode[\"left\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((0, 0), (buffer_thickness[\"left\"], 0)),\n                mode=buffer_mode[\"left\"],\n            )\n\n        if buffer_mode[\"right\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((0, 0), (0, buffer_thickness[\"right\"])),\n                mode=buffer_mode[\"right\"],\n            )\n\n        self.device_array = np.expand_dims(self.device_array, axis=-1)\n\n    @model_validator(mode=\"before\")\n    def check_device_array(cls, values):\n        device_array = values.get(\"device_array\")\n        if not isinstance(device_array, np.ndarray):\n            raise ValueError(\"device_array must be a numpy ndarray.\")\n        if device_array.ndim != 2:\n            raise ValueError(\"device_array must be a 2D array.\")\n        return values\n\n    @property\n    def is_binary(self) -&gt; bool:\n        \"\"\"\n        Check if the device geometry is binary.\n\n        Returns\n        -------\n        bool\n            True if the device geometry is binary, False otherwise.\n        \"\"\"\n        unique_values = np.unique(self.device_array)\n        return (\n            np.array_equal(unique_values, [0, 1])\n            or np.array_equal(unique_values, [1, 0])\n            or np.array_equal(unique_values, [0])\n            or np.array_equal(unique_values, [1])\n        )\n\n    def predict(\n        self,\n        model: Model,\n        binarize: bool = False,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Predict the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless prediction service, which\n        uses a specified machine learning model to predict the outcome of the\n        nanofabrication process.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for prediction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the prediction\n            is tailored to specific fabrication parameters.\n        binarize : bool\n            If True, the predicted device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic predictions into binary\n            geometries. Defaults to False.\n        gpu : bool\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the predicted geometry.\n\n        Raises\n        ------\n        RuntimeError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        prediction_array = predict_array(\n            device_array=self.device_array,\n            model=model,\n            model_type=\"p\",\n            binarize=binarize,\n            gpu=gpu,\n        )\n        return self.model_copy(update={\"device_array\": prediction_array})\n\n    def correct(\n        self,\n        model: Model,\n        binarize: bool = True,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Correct the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless correction service, which\n        uses a specified machine learning model to correct the outcome of the\n        nanofabrication process. The correction aims to adjust the device geometry to\n        compensate for known fabrication errors and improve the accuracy of the final\n        device structure.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for correction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the correction\n            is tailored to specific fabrication parameters.\n        binarize : bool\n            If True, the corrected device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic corrections into binary\n            geometries. Defaults to True.\n        gpu : bool\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the corrected geometry.\n\n        Raises\n        ------\n        RuntimeError\n            If the correction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        correction_array = predict_array(\n            device_array=self.device_array,\n            model=model,\n            model_type=\"c\",\n            binarize=binarize,\n            gpu=gpu,\n        )\n        return self.model_copy(update={\"device_array\": correction_array})\n\n    def semulate(\n        self,\n        model: Model,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Simulate the appearance of the device as if viewed under a scanning electron\n        microscope (SEM).\n\n        This method applies a specified machine learning model to transform the device\n        geometry into a style that resembles an SEM image. This can be useful for\n        visualizing how the device might appear under an SEM, which is often used for\n        inspecting the surface and composition of materials at high magnification.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for SEMulation, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the SEMulation\n            is tailored to specific fabrication parameters.\n        gpu : bool\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Notes\n        -----\n        The salt-and-pepper noise is added manually until the model is trained to\n        generate this noise (not a big priority).\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with its geometry transformed to simulate\n            an SEM image style.\n\n        Raises\n        ------\n        RuntimeError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        semulated_array = predict_array(\n            device_array=self.device_array,\n            model=model,\n            model_type=\"s\",\n            binarize=False,\n            gpu=gpu,\n        )\n        semulated_array += np.random.normal(0, 0.03, semulated_array.shape)\n        return self.model_copy(update={\"device_array\": semulated_array})\n\n    def segment(\n        self,\n        model: Model,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Segment a scanning electron microscope (SEM) image into a binary mask.\n\n        This method applies a specified machine learning model to transform a grayscale\n        SEM image into a binary mask, where 1 represents the device structure and 0\n        represents the background. This is useful for extracting the device geometry\n        from experimental SEM images for analysis or comparison with design intent.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for segmentation, representing a specific fabrication\n            process and dataset. This model encapsulates details about the fabrication\n            foundry, process, material, technology, thickness, and sidewall presence, as\n            defined in `models.py`. Each model is associated with a version and dataset\n            that detail its creation and the data it was trained on, ensuring the\n            segmentation is tailored to specific fabrication parameters.\n        gpu : bool\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with its geometry transformed into a\n            binary mask.\n\n        Raises\n        ------\n        RuntimeError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        segmented_array = predict_array(\n            device_array=self.normalize().device_array,\n            model=model,\n            model_type=\"b\",\n            binarize=False,\n            gpu=gpu,\n        )\n        return self.model_copy(update={\"device_array\": segmented_array})\n\n    def to_ndarray(self) -&gt; np.ndarray:\n        \"\"\"\n        Converts the device geometry to an ndarray.\n\n        This method applies the buffer specifications to crop the device array if\n        necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n        resulting ndarray representing the device geometry.\n\n        Returns\n        -------\n        np.ndarray\n            The ndarray representation of the device geometry, with any applied buffer\n            cropping.\n        \"\"\"\n        device_array = np.copy(self.device_array)\n        buffer_thickness = self.buffer_spec.thickness\n\n        crop_top = buffer_thickness[\"top\"]\n        crop_bottom = buffer_thickness[\"bottom\"]\n        crop_left = buffer_thickness[\"left\"]\n        crop_right = buffer_thickness[\"right\"]\n\n        ndarray = device_array[\n            crop_top : device_array.shape[0] - crop_bottom,\n            crop_left : device_array.shape[1] - crop_right,\n        ]\n        return ndarray\n\n    def to_img(self, img_path: str = \"prefab_device.png\"):\n        \"\"\"\n        Exports the device geometry as an image file.\n\n        This method converts the device geometry to an ndarray using `to_ndarray`,\n        scales the values to the range [0, 255] for image representation, and saves the\n        result as an image file.\n\n        Parameters\n        ----------\n        img_path : str\n            The path where the image file will be saved. If not specified, the image is\n            saved as \"prefab_device.png\" in the current directory.\n        \"\"\"\n        cv2.imwrite(img_path, 255 * self.flatten().to_ndarray())\n        print(f\"Saved Device image to '{img_path}'\")\n\n    def to_gds(\n        self,\n        gds_path: str = \"prefab_device.gds\",\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ):\n        \"\"\"\n        Exports the device geometry as a GDSII file.\n\n        This method converts the device geometry into a format suitable for GDSII files.\n        The conversion involves contour approximation to simplify the geometry while\n        preserving essential features.\n\n        Parameters\n        ----------\n        gds_path : str\n            The path where the GDSII file will be saved. If not specified, the file is\n            saved as \"prefab_device.gds\" in the current directory.\n        cell_name : str\n            The name of the cell within the GDSII file. If not specified, defaults to\n            \"prefab_device\".\n        gds_layer : tuple[int, int]\n            The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n        contour_approx_mode : int\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        origin : tuple[float, float]\n            The x and y coordinates of the origin in \u00b5m for the GDSII export. Defaults\n            to (0.0, 0.0).\n        \"\"\"\n        gdstk_cell = self.flatten()._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n            origin=origin,\n        )\n        print(f\"Saving GDS to '{gds_path}'...\")\n        gdstk_library = gdstk.Library()\n        gdstk_library.add(gdstk_cell)\n        gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n\n    def to_gdstk(\n        self,\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ):\n        \"\"\"\n        Converts the device geometry to a GDSTK cell object.\n\n        This method prepares the device geometry for GDSII file export by converting it\n        into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n        GDSII layout files. The conversion involves contour approximation to simplify\n        the geometry while preserving essential features.\n\n        Parameters\n        ----------\n        cell_name : str\n            The name of the cell to be created. Defaults to \"prefab_device\".\n        gds_layer : tuple[int, int]\n            The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n        contour_approx_mode : int\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        origin : tuple[float, float]\n            The x and y coordinates of the origin in \u00b5m for the GDSTK cell. Defaults\n            to (0.0, 0.0).\n\n        Returns\n        -------\n        gdstk.Cell\n            The GDSTK cell object representing the device geometry.\n        \"\"\"\n        # print(f\"Creating cell '{cell_name}'...\")\n        gdstk_cell = self.flatten()._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n            origin=origin,\n        )\n        return gdstk_cell\n\n    def _device_to_gdstk(\n        self,\n        cell_name: str,\n        gds_layer: tuple[int, int],\n        contour_approx_mode: int,\n        origin: tuple[float, float],\n    ) -&gt; gdstk.Cell:\n        approx_mode_mapping = {\n            1: cv2.CHAIN_APPROX_NONE,\n            2: cv2.CHAIN_APPROX_SIMPLE,\n            3: cv2.CHAIN_APPROX_TC89_L1,\n            4: cv2.CHAIN_APPROX_TC89_KCOS,\n        }\n\n        contours, hierarchy = cv2.findContours(\n            np.flipud(self.to_ndarray()).astype(np.uint8),\n            cv2.RETR_TREE,\n            approx_mode_mapping[contour_approx_mode],\n        )\n\n        hierarchy_polygons = {}\n        for idx, contour in enumerate(contours):\n            level = 0\n            current_idx = idx\n            while hierarchy[0][current_idx][3] != -1:\n                level += 1\n                current_idx = hierarchy[0][current_idx][3]\n\n            if len(contour) &gt; 2:\n                contour = contour / 1000\n                points = [tuple(point) for point in contour.squeeze().tolist()]\n                if level not in hierarchy_polygons:\n                    hierarchy_polygons[level] = []\n                hierarchy_polygons[level].append(points)\n\n        cell = gdstk.Cell(cell_name)\n        processed_polygons = []\n        for level in sorted(hierarchy_polygons.keys()):\n            operation = \"or\" if level % 2 == 0 else \"xor\"\n            polygons_to_process = hierarchy_polygons[level]\n\n            if polygons_to_process:\n                buffer_thickness = self.buffer_spec.thickness\n\n                center_x_nm = (\n                    self.device_array.shape[1]\n                    - buffer_thickness[\"left\"]\n                    - buffer_thickness[\"right\"]\n                ) / 2\n                center_y_nm = (\n                    self.device_array.shape[0]\n                    - buffer_thickness[\"top\"]\n                    - buffer_thickness[\"bottom\"]\n                ) / 2\n\n                center_x_um = center_x_nm / 1000\n                center_y_um = center_y_nm / 1000\n\n                adjusted_polygons = [\n                    gdstk.Polygon(\n                        [\n                            (x - center_x_um + origin[0], y - center_y_um + origin[1])\n                            for x, y in polygon\n                        ]\n                    )\n                    for polygon in polygons_to_process\n                ]\n                processed_polygons = gdstk.boolean(\n                    adjusted_polygons,\n                    processed_polygons,\n                    operation,\n                    layer=gds_layer[0],\n                    datatype=gds_layer[1],\n                )\n        for polygon in processed_polygons:\n            cell.add(polygon)\n\n        return cell\n\n    def to_gdsfactory(self) -&gt; \"gf.Component\":\n        \"\"\"\n        Convert the device geometry to a gdsfactory Component.\n\n        Returns\n        -------\n        gf.Component\n            A gdsfactory Component object representing the device geometry.\n\n        Raises\n        ------\n        ImportError\n            If the gdsfactory package is not installed.\n        \"\"\"\n        try:\n            import gdsfactory as gf\n        except ImportError:\n            raise ImportError(\n                \"The gdsfactory package is required to use this function; \"\n                \"try `pip install gdsfactory`.\"\n            ) from None\n\n        device_array = np.rot90(self.to_ndarray(), k=-1)\n        return gf.read.from_np(device_array, nm_per_pixel=1)\n\n    def to_tidy3d(\n        self,\n        eps0: float,\n        thickness: float,\n    ) -&gt; \"td.Structure\":\n        \"\"\"\n        Convert the device geometry to a Tidy3D Structure.\n\n        Parameters\n        ----------\n        eps0 : float\n            The permittivity value to assign to the device array.\n        thickness : float\n            The thickness of the device in the z-direction.\n\n        Returns\n        -------\n        td.Structure\n            A Tidy3D Structure object representing the device geometry.\n\n        Raises\n        ------\n        ImportError\n            If the tidy3d package is not installed.\n        \"\"\"\n        try:\n            from tidy3d import Box, CustomMedium, SpatialDataArray, Structure, inf\n        except ImportError:\n            raise ImportError(\n                \"The tidy3d package is required to use this function; \"\n                \"try `pip install tidy3d`.\"\n            ) from None\n\n        X = np.linspace(-self.shape[1] / 2000, self.shape[1] / 2000, self.shape[1])\n        Y = np.linspace(-self.shape[0] / 2000, self.shape[0] / 2000, self.shape[0])\n        Z = np.array([0])\n\n        device_array = np.rot90(np.fliplr(self.device_array), k=1)\n        eps_array = np.where(device_array &gt;= 1.0, eps0, device_array)\n        eps_array = np.where(eps_array &lt; 1.0, 1.0, eps_array)\n        eps_dataset = SpatialDataArray(eps_array, coords=dict(x=X, y=Y, z=Z))\n        medium = CustomMedium.from_eps_raw(eps_dataset)\n        return Structure(\n            geometry=Box(center=(0, 0, 0), size=(inf, inf, thickness), attrs={}),\n            medium=medium,\n            name=\"device\",\n            attrs={},\n        )\n\n    def to_3d(self, thickness_nm: int) -&gt; np.ndarray:\n        \"\"\"\n        Convert the 2D device geometry into a 3D representation.\n\n        This method creates a 3D array by interpolating between the bottom and top\n        layers of the device geometry. The interpolation is linear.\n\n        Parameters\n        ----------\n        thickness_nm : int\n            The thickness of the 3D representation in nanometers.\n\n        Returns\n        -------\n        np.ndarray\n            A 3D narray representing the device geometry with the specified thickness.\n        \"\"\"\n        bottom_layer = self.device_array[:, :, 0]\n        top_layer = self.device_array[:, :, -1]\n        dt_bottom = np.array(distance_transform_edt(bottom_layer)) - np.array(\n            distance_transform_edt(1 - bottom_layer)\n        )\n        dt_top = np.array(distance_transform_edt(top_layer)) - np.array(\n            distance_transform_edt(1 - top_layer)\n        )\n        weights = np.linspace(0, 1, thickness_nm)\n        layered_array = np.zeros(\n            (bottom_layer.shape[0], bottom_layer.shape[1], thickness_nm)\n        )\n        for i, w in enumerate(weights):\n            dt_interp = (1 - w) * dt_bottom + w * dt_top\n            layered_array[:, :, i] = dt_interp &gt;= 0\n        return layered_array\n\n    def to_stl(self, thickness_nm: int, filename: str = \"prefab_device.stl\"):\n        \"\"\"\n        Export the device geometry as an STL file.\n\n        Parameters\n        ----------\n        thickness_nm : int\n            The thickness of the 3D representation in nanometers.\n        filename : str\n            The name of the STL file to save. Defaults to \"prefab_device.stl\".\n\n        Raises\n        ------\n        ValueError\n            If the thickness is not a positive integer.\n        ImportError\n            If the numpy-stl package is not installed.\n        \"\"\"\n        try:\n            from stl import mesh  # type: ignore\n        except ImportError:\n            raise ImportError(\n                \"The stl package is required to use this function; \"\n                \"try `pip install numpy-stl`.\"\n            ) from None\n\n        if thickness_nm &lt;= 0:\n            raise ValueError(\"Thickness must be a positive integer.\")\n\n        layered_array = self.to_3d(thickness_nm)\n        layered_array = np.pad(\n            layered_array, ((0, 0), (0, 0), (10, 10)), mode=\"constant\"\n        )\n        verts, faces, _, _ = measure.marching_cubes(layered_array, level=0.5)\n        cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))\n        for i, f in enumerate(faces):\n            for j in range(3):\n                cube.vectors[i][j] = verts[f[j], :]\n        cube.save(filename)\n        print(f\"Saved Device to '{filename}'\")\n\n    def _plot_base(\n        self,\n        plot_array: np.ndarray,\n        show_buffer: bool,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]],\n        ax: Optional[Axes],\n        **kwargs,\n    ) -&gt; tuple[plt.cm.ScalarMappable, Axes]:\n        if ax is None:\n            _, ax = plt.subplots()\n        ax.set_ylabel(\"y (nm)\")\n        ax.set_xlabel(\"x (nm)\")\n\n        min_x, min_y = (0, 0) if bounds is None else bounds[0]\n        max_x, max_y = plot_array.shape[::-1] if bounds is None else bounds[1]\n        min_x = max(min_x, 0)\n        min_y = max(min_y, 0)\n        max_x = \"end\" if max_x == \"end\" else min(max_x, plot_array.shape[1])\n        max_y = \"end\" if max_y == \"end\" else min(max_y, plot_array.shape[0])\n        max_x = plot_array.shape[1] if max_x == \"end\" else max_x\n        max_y = plot_array.shape[0] if max_y == \"end\" else max_y\n        plot_array = plot_array[\n            plot_array.shape[0] - max_y : plot_array.shape[0] - min_y,\n            min_x:max_x,\n        ]\n\n        if not np.ma.is_masked(plot_array):\n            max_size = (1000, 1000)\n            scale_x = min(1, max_size[0] / plot_array.shape[1])\n            scale_y = min(1, max_size[1] / plot_array.shape[0])\n            fx = min(scale_x, scale_y)\n            fy = fx\n\n            plot_array = cv2.resize(\n                plot_array,\n                dsize=(0, 0),\n                fx=fx,\n                fy=fy,\n                interpolation=cv2.INTER_NEAREST,\n            )\n\n        mappable = ax.imshow(\n            plot_array,\n            extent=(\n                float(min_x),\n                float(max_x),\n                float(min_y),\n                float(max_y),\n            ),\n            **kwargs,\n        )\n\n        if show_buffer:\n            self._add_buffer_visualization(ax)\n\n        # # Adjust colorbar font size if a colorbar is added\n        # if \"cmap\" in kwargs:\n        #     cbar = plt.colorbar(mappable, ax=ax)\n        #     cbar.ax.tick_params(labelsize=14)\n        #     if \"label\" in kwargs:\n        #         cbar.set_label(kwargs[\"label\"], fontsize=16)\n\n        return mappable, ax\n\n    def plot(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: Optional[int] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the device geometry.\n\n        This method allows for the visualization of the device geometry. The\n        visualization can be customized with various matplotlib parameters and can be\n        drawn on an existing matplotlib Axes object or create a new one if none is\n        provided.\n\n        Parameters\n        ----------\n        show_buffer : bool\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the device geometry on. If\n            None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the plot. This object can be used for\n            further plot customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            plot_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            plot_array = self.device_array[:, :, level]\n        _, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        return ax\n\n    def plot_contour(\n        self,\n        linewidth: Optional[int] = None,\n        # label: Optional[str] = \"Device contour\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: Optional[int] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the contour of the device geometry.\n\n        This method plots the contour of the device geometry, emphasizing the edges and\n        boundaries of the device. The contour plot can be customized with various\n        matplotlib parameters, including line width and color. The plot can be drawn on\n        an existing matplotlib Axes object or create a new one if none is provided.\n\n        Parameters\n        ----------\n        linewidth : Optional[int]\n            The width of the contour lines. If None, the linewidth is automatically\n            determined based on the size of the device array. Defaults to None.\n        show_buffer : bool\n            If True, the buffer zones around the device will be visualized. By default,\n            it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the device contour on. If None, a\n            new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the contour plot. This can be used for\n            further customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            device_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            device_array = self.device_array[:, :, level]\n\n        kwargs.setdefault(\"cmap\", \"spring\")\n        if linewidth is None:\n            linewidth = device_array.shape[0] // 100\n\n        contours, _ = cv2.findContours(\n            geometry.binarize_hard(device_array).astype(np.uint8),\n            cv2.RETR_CCOMP,\n            cv2.CHAIN_APPROX_SIMPLE,\n        )\n        contour_array = np.zeros_like(device_array, dtype=np.uint8)\n        cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n        contour_array = np.ma.masked_equal(contour_array, 0)\n\n        _, ax = self._plot_base(\n            plot_array=contour_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n        # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n        # ax.legend([legend_proxy], [label], loc=\"upper right\")\n        return ax\n\n    def plot_uncertainty(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: Optional[int] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the uncertainty in the edge positions of the predicted device.\n\n        This method plots the uncertainty associated with the positions of the edges of\n        the device. The uncertainty is represented as a gradient, with areas of higher\n        uncertainty indicating a greater likelihood of the edge position from run to run\n        (due to inconsistencies in the fabrication process). This visualization can help\n        in identifying areas within the device geometry that may require design\n        adjustments to improve fabrication consistency.\n\n        Parameters\n        ----------\n        show_buffer : bool\n            If True, the buffer zones around the device will also be visualized. By\n            default, it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the uncertainty visualization on.\n            If None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the uncertainty visualization. This\n            can be used for further customization or saving the plot after the method\n            returns.\n        \"\"\"\n        uncertainty_array = self.get_uncertainty()\n\n        if level is None:\n            uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n        else:\n            uncertainty_array = uncertainty_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=uncertainty_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Uncertainty (a.u.)\")\n        return ax\n\n    def plot_compare(\n        self,\n        ref_device: \"Device\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: Optional[int] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the comparison between the current device geometry and a reference\n        device geometry.\n\n        Positive values (dilation) and negative values (erosion) are visualized with a\n        color map to indicate areas where the current device has expanded or contracted\n        relative to the reference.\n\n        Parameters\n        ----------\n        ref_device : Device\n            The reference device to compare against.\n        show_buffer : bool\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the comparison on. If None, a new\n            figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the comparison plot. This object can\n            be used for further plot customization or saving the plot after the method\n            returns.\n        \"\"\"\n        plot_array = ref_device.device_array - self.device_array\n\n        if level is None:\n            plot_array = geometry.flatten(plot_array)[:, :, 0]\n        else:\n            plot_array = plot_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            cmap=\"jet\",\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n        return ax\n\n    def _add_buffer_visualization(self, ax: Axes):\n        plot_array = self.device_array\n\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_fill = (0, 1, 0, 0.2)\n        buffer_hatch = \"/\"\n\n        mid_rect = Rectangle(\n            (buffer_thickness[\"left\"], buffer_thickness[\"top\"]),\n            plot_array.shape[1] - buffer_thickness[\"left\"] - buffer_thickness[\"right\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=\"none\",\n            edgecolor=\"black\",\n            linewidth=1,\n        )\n        ax.add_patch(mid_rect)\n\n        top_rect = Rectangle(\n            (0, 0),\n            plot_array.shape[1],\n            buffer_thickness[\"top\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(top_rect)\n\n        bottom_rect = Rectangle(\n            (0, plot_array.shape[0] - buffer_thickness[\"bottom\"]),\n            plot_array.shape[1],\n            buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(bottom_rect)\n\n        left_rect = Rectangle(\n            (0, buffer_thickness[\"top\"]),\n            buffer_thickness[\"left\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(left_rect)\n\n        right_rect = Rectangle(\n            (\n                plot_array.shape[1] - buffer_thickness[\"right\"],\n                buffer_thickness[\"top\"],\n            ),\n            buffer_thickness[\"right\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(right_rect)\n\n    def normalize(self) -&gt; \"Device\":\n        \"\"\"\n        Normalize the device geometry.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the normalized geometry.\n        \"\"\"\n        normalized_device_array = geometry.normalize(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": normalized_device_array})\n\n    def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry based on a threshold and a scaling factor.\n\n        Parameters\n        ----------\n        eta : float\n            The threshold value for binarization. Defaults to 0.5.\n        beta : float\n            The scaling factor for the binarization process. A higher value makes the\n            transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize(\n            device_array=self.device_array, eta=eta, beta=beta\n        )\n        return self.model_copy(\n            update={\"device_array\": binarized_device_array.astype(np.uint8)}\n        )\n\n    def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n        \"\"\"\n        Apply a hard threshold to binarize the device geometry. The `binarize` function\n        is generally preferred for most use cases, but it can create numerical artifacts\n        for large beta values.\n\n        Parameters\n        ----------\n        eta : float\n            The threshold value for binarization. Defaults to 0.5.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the threshold-binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_hard(\n            device_array=self.device_array, eta=eta\n        )\n        return self.model_copy(\n            update={\"device_array\": binarized_device_array.astype(np.uint8)}\n        )\n\n    def binarize_monte_carlo(\n        self,\n        noise_magnitude: float = 2.0,\n        blur_radius: float = 8.0,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Binarize the input ndarray using a dynamic thresholding approach to simulate\n        surfaceroughness.\n\n        This function applies a dynamic thresholding technique where the threshold value\n        is determined by a base value perturbed by Gaussian-distributed random noise.\n        Thethreshold is then spatially varied across the array using Gaussian blurring,\n        simulating a potentially more realistic scenario where the threshold is not\n        uniform across the device.\n\n        Notes\n        -----\n        This is a temporary solution, where the defaults are chosen based on what looks\n        good. A better, data-driven approach is needed.\n\n        Parameters\n        ----------\n        noise_magnitude : float\n            The standard deviation of the Gaussian distribution used to generate noise\n            for the threshold values. This controls the amount of randomness in the\n            threshold. Defaults to 2.0.\n        blur_radius : float\n            The standard deviation for the Gaussian kernel used in blurring the\n            threshold map. This controls the spatial variation of the threshold across\n            the array. Defaults to 9.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_monte_carlo(\n            device_array=self.device_array,\n            noise_magnitude=noise_magnitude,\n            blur_radius=blur_radius,\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n        \"\"\"\n        Ternarize the device geometry based on two thresholds. This function is useful\n        for flattened devices with angled sidewalls (i.e., three segments).\n\n        Parameters\n        ----------\n        eta1 : float\n            The first threshold value for ternarization. Defaults to 1/3.\n        eta2 : float\n            The second threshold value for ternarization. Defaults to 2/3.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the ternarized geometry.\n        \"\"\"\n        ternarized_device_array = geometry.ternarize(\n            device_array=self.flatten().device_array, eta1=eta1, eta2=eta2\n        )\n        return self.model_copy(update={\"device_array\": ternarized_device_array})\n\n    def trim(self) -&gt; \"Device\":\n        \"\"\"\n        Trim the device geometry by removing empty space around it.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the trimmed geometry.\n        \"\"\"\n        trimmed_device_array = geometry.trim(\n            device_array=self.device_array,\n            buffer_thickness=self.buffer_spec.thickness,\n        )\n        return self.model_copy(update={\"device_array\": trimmed_device_array})\n\n    def pad(self, pad_width: int) -&gt; \"Device\":\n        \"\"\"\n        Pad the device geometry with a specified width on all sides.\n        \"\"\"\n        padded_device_array = geometry.pad(\n            device_array=self.device_array, pad_width=pad_width\n        )\n        return self.model_copy(update={\"device_array\": padded_device_array})\n\n    def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n        \"\"\"\n        Apply Gaussian blur to the device geometry and normalize the result.\n\n        Parameters\n        ----------\n        sigma : float\n            The standard deviation for the Gaussian kernel. This controls the amount of\n            blurring. Defaults to 1.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the blurred and normalized geometry.\n        \"\"\"\n        blurred_device_array = geometry.blur(\n            device_array=self.device_array, sigma=sigma\n        )\n        return self.model_copy(update={\"device_array\": blurred_device_array})\n\n    def rotate(self, angle: float) -&gt; \"Device\":\n        \"\"\"\n        Rotate the device geometry by a given angle.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation in degrees. Positive values mean counter-clockwise\n            rotation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the rotated geometry.\n        \"\"\"\n        rotated_device_array = geometry.rotate(\n            device_array=self.device_array, angle=angle\n        )\n        return self.model_copy(update={\"device_array\": rotated_device_array})\n\n    def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Erode the device geometry by removing small areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for erosion.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the eroded geometry.\n        \"\"\"\n        eroded_device_array = geometry.erode(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": eroded_device_array})\n\n    def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Dilate the device geometry by expanding areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for dilation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the dilated geometry.\n        \"\"\"\n        dilated_device_array = geometry.dilate(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": dilated_device_array})\n\n    def flatten(self) -&gt; \"Device\":\n        \"\"\"\n        Flatten the device geometry by summing the vertical layers and normalizing the\n        result.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the flattened geometry.\n        \"\"\"\n        flattened_device_array = geometry.flatten(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": flattened_device_array})\n\n    def get_uncertainty(self) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the uncertainty in the edge positions of the predicted device.\n\n        This method computes the uncertainty based on the deviation of the device's\n        geometry values from the midpoint (0.5). The uncertainty is defined as the\n        absolute difference from 0.5, scaled and inverted to provide a measure where\n        higher values indicate greater uncertainty.\n\n        Returns\n        -------\n        np.ndarray\n            An array representing the uncertainty in the edge positions of the device,\n            with higher values indicating greater uncertainty.\n        \"\"\"\n        return 1 - 2 * np.abs(0.5 - self.device_array)\n\n    def enforce_feature_size(\n        self, min_feature_size: int, strel: str = \"disk\"\n    ) -&gt; \"Device\":\n        \"\"\"\n        Enforce a minimum feature size on the device geometry.\n\n        This method applies morphological operations to ensure that all features in the\n        device geometry are at least the specified minimum size. It uses either a disk\n        or square structuring element for the operations.\n\n        Notes\n        -----\n        This function does not guarantee that the minimum feature size is enforced in\n        all cases. A better process is needed.\n\n        Parameters\n        ----------\n        min_feature_size : int\n            The minimum feature size to enforce, in nanometers.\n        strel : str\n            The type of structuring element to use. Can be either \"disk\" or \"square\".\n            Defaults to \"disk\".\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the modified geometry.\n\n        Raises\n        ------\n        ValueError\n            If an invalid structuring element type is specified.\n        \"\"\"\n        modified_geometry = geometry.enforce_feature_size(\n            device_array=self.device_array,\n            min_feature_size=min_feature_size,\n            strel=strel,\n        )\n        return self.model_copy(update={\"device_array\": modified_geometry})\n\n    def check_feature_size(self, min_feature_size: int, strel: str = \"disk\"):\n        \"\"\"\n        Check and visualize the effect of enforcing a minimum feature size on the device\n        geometry.\n\n        This method enforces a minimum feature size on the device geometry using the\n        specified structuring element, compares the modified geometry with the original,\n        and plots the differences. It also calculates and prints the Hamming distance\n        between the original and modified geometries, providing a measure of the changes\n        introduced by the feature size enforcement.\n\n        Notes\n        -----\n        This is not a design-rule-checking function, but it can be useful for quick\n        checks.\n\n        Parameters\n        ----------\n        min_feature_size : int\n            The minimum feature size to enforce, in nanometers.\n        strel : str\n            The type of structuring element to use. Can be either \"disk\" or \"square\".\n            Defaults to \"disk\".\n\n        Raises\n        ------\n        ValueError\n            If an invalid structuring element type is specified or if min_feature_size\n            is not a positive integer.\n        \"\"\"\n        if min_feature_size &lt;= 0:\n            raise ValueError(\"min_feature_size must be a positive integer.\")\n\n        enforced_device = self.enforce_feature_size(min_feature_size, strel)\n\n        difference = np.abs(\n            enforced_device.device_array[:, :, 0] - self.device_array[:, :, 0]\n        )\n        _, ax = self._plot_base(\n            plot_array=difference,\n            show_buffer=False,\n            ax=None,\n            bounds=None,\n            cmap=\"jet\",\n        )\n\n        hamming_distance = compare.hamming_distance(self, enforced_device)\n        print(\n            f\"Feature size check with minimum size {min_feature_size} \"\n            f\"using '{strel}' structuring element resulted in a Hamming \"\n            f\"distance of: {hamming_distance}\"\n        )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.is_binary","title":"<code>is_binary</code>  <code>property</code>","text":"<p>Check if the device geometry is binary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device geometry is binary, False otherwise.</p>"},{"location":"reference/device/#prefab.device.Device.__init__","title":"<code>__init__(device_array, buffer_spec=None)</code>","text":"<p>Represents the planar geometry of a photonic device design that will have its nanofabrication outcome predicted and/or corrected.</p> <p>This class is designed to encapsulate the geometric representation of a photonic device, facilitating operations such as padding, normalization, binarization, erosion/dilation, trimming, and blurring. These operations are useful for preparingthe device design for prediction or correction. Additionally, the class providesmethods for exporting the device representation to various formats, includingndarray, image files, and GDSII files, supporting a range of analysis and fabrication workflows.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device. This array undergoes various transformations to predict or correct the nanofabrication process.</p> required <code>buffer_spec</code> <code>Optional[BufferSpec]</code> <p>Defines the parameters for adding a buffer zone around the device geometry. This buffer zone is needed for providing surrounding context for prediction or correction and for ensuring seamless integration with the surrounding circuitry. By default, a generous padding is applied to accommodate isolated structures.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple[int, int]</code> <p>The shape of the device array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided <code>device_array</code> is not a numpy ndarray or is not a 2D array, indicating an invalid device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def __init__(\n    self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n):\n    \"\"\"\n    Represents the planar geometry of a photonic device design that will have its\n    nanofabrication outcome predicted and/or corrected.\n\n    This class is designed to encapsulate the geometric representation of a photonic\n    device, facilitating operations such as padding, normalization, binarization,\n    erosion/dilation, trimming, and blurring. These operations are useful for\n    preparingthe device design for prediction or correction. Additionally, the class\n    providesmethods for exporting the device representation to various formats,\n    includingndarray, image files, and GDSII files, supporting a range of analysis\n    and fabrication workflows.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array\n        undergoes various transformations to predict or correct the nanofabrication\n        process.\n    buffer_spec : Optional[BufferSpec]\n        Defines the parameters for adding a buffer zone around the device geometry.\n        This buffer zone is needed for providing surrounding context for prediction\n        or correction and for ensuring seamless integration with the surrounding\n        circuitry. By default, a generous padding is applied to accommodate isolated\n        structures.\n\n    Attributes\n    ----------\n    shape : tuple[int, int]\n        The shape of the device array.\n\n    Raises\n    ------\n    ValueError\n        If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n        indicating an invalid device geometry.\n    \"\"\"\n    super().__init__(\n        device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n    )\n    self._initial_processing()\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize","title":"<code>binarize(eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the device geometry based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize(\n        device_array=self.device_array, eta=eta, beta=beta\n    )\n    return self.model_copy(\n        update={\"device_array\": binarized_device_array.astype(np.uint8)}\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_hard","title":"<code>binarize_hard(eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the device geometry. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the threshold-binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n    \"\"\"\n    Apply a hard threshold to binarize the device geometry. The `binarize` function\n    is generally preferred for most use cases, but it can create numerical artifacts\n    for large beta values.\n\n    Parameters\n    ----------\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the threshold-binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_hard(\n        device_array=self.device_array, eta=eta\n    )\n    return self.model_copy(\n        update={\"device_array\": binarized_device_array.astype(np.uint8)}\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_monte_carlo","title":"<code>binarize_monte_carlo(noise_magnitude=2.0, blur_radius=8.0)</code>","text":"<p>Binarize the input ndarray using a dynamic thresholding approach to simulate surfaceroughness.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. Thethreshold is then spatially varied across the array using Gaussian blurring, simulating a potentially more realistic scenario where the threshold is not uniform across the device.</p> Notes <p>This is a temporary solution, where the defaults are chosen based on what looks good. A better, data-driven approach is needed.</p> <p>Parameters:</p> Name Type Description Default <code>noise_magnitude</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold. Defaults to 2.0.</p> <code>2.0</code> <code>blur_radius</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array. Defaults to 9.0.</p> <code>8.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_monte_carlo(\n    self,\n    noise_magnitude: float = 2.0,\n    blur_radius: float = 8.0,\n) -&gt; \"Device\":\n    \"\"\"\n    Binarize the input ndarray using a dynamic thresholding approach to simulate\n    surfaceroughness.\n\n    This function applies a dynamic thresholding technique where the threshold value\n    is determined by a base value perturbed by Gaussian-distributed random noise.\n    Thethreshold is then spatially varied across the array using Gaussian blurring,\n    simulating a potentially more realistic scenario where the threshold is not\n    uniform across the device.\n\n    Notes\n    -----\n    This is a temporary solution, where the defaults are chosen based on what looks\n    good. A better, data-driven approach is needed.\n\n    Parameters\n    ----------\n    noise_magnitude : float\n        The standard deviation of the Gaussian distribution used to generate noise\n        for the threshold values. This controls the amount of randomness in the\n        threshold. Defaults to 2.0.\n    blur_radius : float\n        The standard deviation for the Gaussian kernel used in blurring the\n        threshold map. This controls the spatial variation of the threshold across\n        the array. Defaults to 9.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_monte_carlo(\n        device_array=self.device_array,\n        noise_magnitude=noise_magnitude,\n        blur_radius=blur_radius,\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.blur","title":"<code>blur(sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the device geometry and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the blurred and normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n    \"\"\"\n    Apply Gaussian blur to the device geometry and normalize the result.\n\n    Parameters\n    ----------\n    sigma : float\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the blurred and normalized geometry.\n    \"\"\"\n    blurred_device_array = geometry.blur(\n        device_array=self.device_array, sigma=sigma\n    )\n    return self.model_copy(update={\"device_array\": blurred_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.check_feature_size","title":"<code>check_feature_size(min_feature_size, strel='disk')</code>","text":"<p>Check and visualize the effect of enforcing a minimum feature size on the device geometry.</p> <p>This method enforces a minimum feature size on the device geometry using the specified structuring element, compares the modified geometry with the original, and plots the differences. It also calculates and prints the Hamming distance between the original and modified geometries, providing a measure of the changes introduced by the feature size enforcement.</p> Notes <p>This is not a design-rule-checking function, but it can be useful for quick checks.</p> <p>Parameters:</p> Name Type Description Default <code>min_feature_size</code> <code>int</code> <p>The minimum feature size to enforce, in nanometers.</p> required <code>strel</code> <code>str</code> <p>The type of structuring element to use. Can be either \"disk\" or \"square\". Defaults to \"disk\".</p> <code>'disk'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid structuring element type is specified or if min_feature_size is not a positive integer.</p> Source code in <code>prefab/device.py</code> <pre><code>def check_feature_size(self, min_feature_size: int, strel: str = \"disk\"):\n    \"\"\"\n    Check and visualize the effect of enforcing a minimum feature size on the device\n    geometry.\n\n    This method enforces a minimum feature size on the device geometry using the\n    specified structuring element, compares the modified geometry with the original,\n    and plots the differences. It also calculates and prints the Hamming distance\n    between the original and modified geometries, providing a measure of the changes\n    introduced by the feature size enforcement.\n\n    Notes\n    -----\n    This is not a design-rule-checking function, but it can be useful for quick\n    checks.\n\n    Parameters\n    ----------\n    min_feature_size : int\n        The minimum feature size to enforce, in nanometers.\n    strel : str\n        The type of structuring element to use. Can be either \"disk\" or \"square\".\n        Defaults to \"disk\".\n\n    Raises\n    ------\n    ValueError\n        If an invalid structuring element type is specified or if min_feature_size\n        is not a positive integer.\n    \"\"\"\n    if min_feature_size &lt;= 0:\n        raise ValueError(\"min_feature_size must be a positive integer.\")\n\n    enforced_device = self.enforce_feature_size(min_feature_size, strel)\n\n    difference = np.abs(\n        enforced_device.device_array[:, :, 0] - self.device_array[:, :, 0]\n    )\n    _, ax = self._plot_base(\n        plot_array=difference,\n        show_buffer=False,\n        ax=None,\n        bounds=None,\n        cmap=\"jet\",\n    )\n\n    hamming_distance = compare.hamming_distance(self, enforced_device)\n    print(\n        f\"Feature size check with minimum size {min_feature_size} \"\n        f\"using '{strel}' structuring element resulted in a Hamming \"\n        f\"distance of: {hamming_distance}\"\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.correct","title":"<code>correct(model, binarize=True, gpu=False)</code>","text":"<p>Correct the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless correction service, which uses a specified machine learning model to correct the outcome of the nanofabrication process. The correction aims to adjust the device geometry to compensate for known fabrication errors and improve the accuracy of the final device structure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for correction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the correction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the corrected device geometry will be binarized using a threshold method. This is useful for converting probabilistic corrections into binary geometries. Defaults to True.</p> <code>True</code> <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the corrected geometry.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the correction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def correct(\n    self,\n    model: Model,\n    binarize: bool = True,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Correct the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless correction service, which\n    uses a specified machine learning model to correct the outcome of the\n    nanofabrication process. The correction aims to adjust the device geometry to\n    compensate for known fabrication errors and improve the accuracy of the final\n    device structure.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for correction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the correction\n        is tailored to specific fabrication parameters.\n    binarize : bool\n        If True, the corrected device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic corrections into binary\n        geometries. Defaults to True.\n    gpu : bool\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the corrected geometry.\n\n    Raises\n    ------\n    RuntimeError\n        If the correction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    correction_array = predict_array(\n        device_array=self.device_array,\n        model=model,\n        model_type=\"c\",\n        binarize=binarize,\n        gpu=gpu,\n    )\n    return self.model_copy(update={\"device_array\": correction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.dilate","title":"<code>dilate(kernel_size=3)</code>","text":"<p>Dilate the device geometry by expanding areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the dilated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Dilate the device geometry by expanding areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the dilated geometry.\n    \"\"\"\n    dilated_device_array = geometry.dilate(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": dilated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.enforce_feature_size","title":"<code>enforce_feature_size(min_feature_size, strel='disk')</code>","text":"<p>Enforce a minimum feature size on the device geometry.</p> <p>This method applies morphological operations to ensure that all features in the device geometry are at least the specified minimum size. It uses either a disk or square structuring element for the operations.</p> Notes <p>This function does not guarantee that the minimum feature size is enforced in all cases. A better process is needed.</p> <p>Parameters:</p> Name Type Description Default <code>min_feature_size</code> <code>int</code> <p>The minimum feature size to enforce, in nanometers.</p> required <code>strel</code> <code>str</code> <p>The type of structuring element to use. Can be either \"disk\" or \"square\". Defaults to \"disk\".</p> <code>'disk'</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the modified geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid structuring element type is specified.</p> Source code in <code>prefab/device.py</code> <pre><code>def enforce_feature_size(\n    self, min_feature_size: int, strel: str = \"disk\"\n) -&gt; \"Device\":\n    \"\"\"\n    Enforce a minimum feature size on the device geometry.\n\n    This method applies morphological operations to ensure that all features in the\n    device geometry are at least the specified minimum size. It uses either a disk\n    or square structuring element for the operations.\n\n    Notes\n    -----\n    This function does not guarantee that the minimum feature size is enforced in\n    all cases. A better process is needed.\n\n    Parameters\n    ----------\n    min_feature_size : int\n        The minimum feature size to enforce, in nanometers.\n    strel : str\n        The type of structuring element to use. Can be either \"disk\" or \"square\".\n        Defaults to \"disk\".\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the modified geometry.\n\n    Raises\n    ------\n    ValueError\n        If an invalid structuring element type is specified.\n    \"\"\"\n    modified_geometry = geometry.enforce_feature_size(\n        device_array=self.device_array,\n        min_feature_size=min_feature_size,\n        strel=strel,\n    )\n    return self.model_copy(update={\"device_array\": modified_geometry})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.erode","title":"<code>erode(kernel_size=3)</code>","text":"<p>Erode the device geometry by removing small areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the eroded geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Erode the device geometry by removing small areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the eroded geometry.\n    \"\"\"\n    eroded_device_array = geometry.erode(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": eroded_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.flatten","title":"<code>flatten()</code>","text":"<p>Flatten the device geometry by summing the vertical layers and normalizing the result.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the flattened geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def flatten(self) -&gt; \"Device\":\n    \"\"\"\n    Flatten the device geometry by summing the vertical layers and normalizing the\n    result.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the flattened geometry.\n    \"\"\"\n    flattened_device_array = geometry.flatten(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": flattened_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.get_uncertainty","title":"<code>get_uncertainty()</code>","text":"<p>Calculate the uncertainty in the edge positions of the predicted device.</p> <p>This method computes the uncertainty based on the deviation of the device's geometry values from the midpoint (0.5). The uncertainty is defined as the absolute difference from 0.5, scaled and inverted to provide a measure where higher values indicate greater uncertainty.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing the uncertainty in the edge positions of the device, with higher values indicating greater uncertainty.</p> Source code in <code>prefab/device.py</code> <pre><code>def get_uncertainty(self) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the uncertainty in the edge positions of the predicted device.\n\n    This method computes the uncertainty based on the deviation of the device's\n    geometry values from the midpoint (0.5). The uncertainty is defined as the\n    absolute difference from 0.5, scaled and inverted to provide a measure where\n    higher values indicate greater uncertainty.\n\n    Returns\n    -------\n    np.ndarray\n        An array representing the uncertainty in the edge positions of the device,\n        with higher values indicating greater uncertainty.\n    \"\"\"\n    return 1 - 2 * np.abs(0.5 - self.device_array)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the device geometry.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def normalize(self) -&gt; \"Device\":\n    \"\"\"\n    Normalize the device geometry.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the normalized geometry.\n    \"\"\"\n    normalized_device_array = geometry.normalize(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": normalized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.pad","title":"<code>pad(pad_width)</code>","text":"<p>Pad the device geometry with a specified width on all sides.</p> Source code in <code>prefab/device.py</code> <pre><code>def pad(self, pad_width: int) -&gt; \"Device\":\n    \"\"\"\n    Pad the device geometry with a specified width on all sides.\n    \"\"\"\n    padded_device_array = geometry.pad(\n        device_array=self.device_array, pad_width=pad_width\n    )\n    return self.model_copy(update={\"device_array\": padded_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot","title":"<code>plot(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the device geometry.</p> <p>This method allows for the visualization of the device geometry. The visualization can be customized with various matplotlib parameters and can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device geometry on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: Optional[int] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the device geometry.\n\n    This method allows for the visualization of the device geometry. The\n    visualization can be customized with various matplotlib parameters and can be\n    drawn on an existing matplotlib Axes object or create a new one if none is\n    provided.\n\n    Parameters\n    ----------\n    show_buffer : bool\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the device geometry on. If\n        None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the plot. This object can be used for\n        further plot customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        plot_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        plot_array = self.device_array[:, :, level]\n    _, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_compare","title":"<code>plot_compare(ref_device, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the comparison between the current device geometry and a reference device geometry.</p> <p>Positive values (dilation) and negative values (erosion) are visualized with a color map to indicate areas where the current device has expanded or contracted relative to the reference.</p> <p>Parameters:</p> Name Type Description Default <code>ref_device</code> <code>Device</code> <p>The reference device to compare against.</p> required <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the comparison on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the comparison plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_compare(\n    self,\n    ref_device: \"Device\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: Optional[int] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the comparison between the current device geometry and a reference\n    device geometry.\n\n    Positive values (dilation) and negative values (erosion) are visualized with a\n    color map to indicate areas where the current device has expanded or contracted\n    relative to the reference.\n\n    Parameters\n    ----------\n    ref_device : Device\n        The reference device to compare against.\n    show_buffer : bool\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the comparison on. If None, a new\n        figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the comparison plot. This object can\n        be used for further plot customization or saving the plot after the method\n        returns.\n    \"\"\"\n    plot_array = ref_device.device_array - self.device_array\n\n    if level is None:\n        plot_array = geometry.flatten(plot_array)[:, :, 0]\n    else:\n        plot_array = plot_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        cmap=\"jet\",\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_contour","title":"<code>plot_contour(linewidth=None, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the contour of the device geometry.</p> <p>This method plots the contour of the device geometry, emphasizing the edges and boundaries of the device. The contour plot can be customized with various matplotlib parameters, including line width and color. The plot can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>linewidth</code> <code>Optional[int]</code> <p>The width of the contour lines. If None, the linewidth is automatically determined based on the size of the device array. Defaults to None.</p> <code>None</code> <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device contour on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the contour plot. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_contour(\n    self,\n    linewidth: Optional[int] = None,\n    # label: Optional[str] = \"Device contour\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: Optional[int] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the contour of the device geometry.\n\n    This method plots the contour of the device geometry, emphasizing the edges and\n    boundaries of the device. The contour plot can be customized with various\n    matplotlib parameters, including line width and color. The plot can be drawn on\n    an existing matplotlib Axes object or create a new one if none is provided.\n\n    Parameters\n    ----------\n    linewidth : Optional[int]\n        The width of the contour lines. If None, the linewidth is automatically\n        determined based on the size of the device array. Defaults to None.\n    show_buffer : bool\n        If True, the buffer zones around the device will be visualized. By default,\n        it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the device contour on. If None, a\n        new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the contour plot. This can be used for\n        further customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        device_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        device_array = self.device_array[:, :, level]\n\n    kwargs.setdefault(\"cmap\", \"spring\")\n    if linewidth is None:\n        linewidth = device_array.shape[0] // 100\n\n    contours, _ = cv2.findContours(\n        geometry.binarize_hard(device_array).astype(np.uint8),\n        cv2.RETR_CCOMP,\n        cv2.CHAIN_APPROX_SIMPLE,\n    )\n    contour_array = np.zeros_like(device_array, dtype=np.uint8)\n    cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n    contour_array = np.ma.masked_equal(contour_array, 0)\n\n    _, ax = self._plot_base(\n        plot_array=contour_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n    # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n    # ax.legend([legend_proxy], [label], loc=\"upper right\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_uncertainty","title":"<code>plot_uncertainty(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the uncertainty in the edge positions of the predicted device.</p> <p>This method plots the uncertainty associated with the positions of the edges of the device. The uncertainty is represented as a gradient, with areas of higher uncertainty indicating a greater likelihood of the edge position from run to run (due to inconsistencies in the fabrication process). This visualization can help in identifying areas within the device geometry that may require design adjustments to improve fabrication consistency.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will also be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the uncertainty visualization on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the uncertainty visualization. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_uncertainty(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: Optional[int] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the uncertainty in the edge positions of the predicted device.\n\n    This method plots the uncertainty associated with the positions of the edges of\n    the device. The uncertainty is represented as a gradient, with areas of higher\n    uncertainty indicating a greater likelihood of the edge position from run to run\n    (due to inconsistencies in the fabrication process). This visualization can help\n    in identifying areas within the device geometry that may require design\n    adjustments to improve fabrication consistency.\n\n    Parameters\n    ----------\n    show_buffer : bool\n        If True, the buffer zones around the device will also be visualized. By\n        default, it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the uncertainty visualization on.\n        If None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the uncertainty visualization. This\n        can be used for further customization or saving the plot after the method\n        returns.\n    \"\"\"\n    uncertainty_array = self.get_uncertainty()\n\n    if level is None:\n        uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n    else:\n        uncertainty_array = uncertainty_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=uncertainty_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Uncertainty (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.predict","title":"<code>predict(model, binarize=False, gpu=False)</code>","text":"<p>Predict the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the predicted device geometry will be binarized using a threshold method. This is useful for converting probabilistic predictions into binary geometries. Defaults to False.</p> <code>False</code> <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the predicted geometry.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the prediction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def predict(\n    self,\n    model: Model,\n    binarize: bool = False,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Predict the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless prediction service, which\n    uses a specified machine learning model to predict the outcome of the\n    nanofabrication process.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for prediction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the prediction\n        is tailored to specific fabrication parameters.\n    binarize : bool\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries. Defaults to False.\n    gpu : bool\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the predicted geometry.\n\n    Raises\n    ------\n    RuntimeError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    prediction_array = predict_array(\n        device_array=self.device_array,\n        model=model,\n        model_type=\"p\",\n        binarize=binarize,\n        gpu=gpu,\n    )\n    return self.model_copy(update={\"device_array\": prediction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.rotate","title":"<code>rotate(angle)</code>","text":"<p>Rotate the device geometry by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the rotated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def rotate(self, angle: float) -&gt; \"Device\":\n    \"\"\"\n    Rotate the device geometry by a given angle.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the rotated geometry.\n    \"\"\"\n    rotated_device_array = geometry.rotate(\n        device_array=self.device_array, angle=angle\n    )\n    return self.model_copy(update={\"device_array\": rotated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.segment","title":"<code>segment(model, gpu=False)</code>","text":"<p>Segment a scanning electron microscope (SEM) image into a binary mask.</p> <p>This method applies a specified machine learning model to transform a grayscale SEM image into a binary mask, where 1 represents the device structure and 0 represents the background. This is useful for extracting the device geometry from experimental SEM images for analysis or comparison with design intent.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for segmentation, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the segmentation is tailored to specific fabrication parameters.</p> required <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with its geometry transformed into a binary mask.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the prediction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def segment(\n    self,\n    model: Model,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Segment a scanning electron microscope (SEM) image into a binary mask.\n\n    This method applies a specified machine learning model to transform a grayscale\n    SEM image into a binary mask, where 1 represents the device structure and 0\n    represents the background. This is useful for extracting the device geometry\n    from experimental SEM images for analysis or comparison with design intent.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for segmentation, representing a specific fabrication\n        process and dataset. This model encapsulates details about the fabrication\n        foundry, process, material, technology, thickness, and sidewall presence, as\n        defined in `models.py`. Each model is associated with a version and dataset\n        that detail its creation and the data it was trained on, ensuring the\n        segmentation is tailored to specific fabrication parameters.\n    gpu : bool\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with its geometry transformed into a\n        binary mask.\n\n    Raises\n    ------\n    RuntimeError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    segmented_array = predict_array(\n        device_array=self.normalize().device_array,\n        model=model,\n        model_type=\"b\",\n        binarize=False,\n        gpu=gpu,\n    )\n    return self.model_copy(update={\"device_array\": segmented_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.semulate","title":"<code>semulate(model, gpu=False)</code>","text":"<p>Simulate the appearance of the device as if viewed under a scanning electron microscope (SEM).</p> <p>This method applies a specified machine learning model to transform the device geometry into a style that resembles an SEM image. This can be useful for visualizing how the device might appear under an SEM, which is often used for inspecting the surface and composition of materials at high magnification.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for SEMulation, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the SEMulation is tailored to specific fabrication parameters.</p> required <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> Notes <p>The salt-and-pepper noise is added manually until the model is trained to generate this noise (not a big priority).</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with its geometry transformed to simulate an SEM image style.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the prediction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def semulate(\n    self,\n    model: Model,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Simulate the appearance of the device as if viewed under a scanning electron\n    microscope (SEM).\n\n    This method applies a specified machine learning model to transform the device\n    geometry into a style that resembles an SEM image. This can be useful for\n    visualizing how the device might appear under an SEM, which is often used for\n    inspecting the surface and composition of materials at high magnification.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for SEMulation, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the SEMulation\n        is tailored to specific fabrication parameters.\n    gpu : bool\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Notes\n    -----\n    The salt-and-pepper noise is added manually until the model is trained to\n    generate this noise (not a big priority).\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with its geometry transformed to simulate\n        an SEM image style.\n\n    Raises\n    ------\n    RuntimeError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    semulated_array = predict_array(\n        device_array=self.device_array,\n        model=model,\n        model_type=\"s\",\n        binarize=False,\n        gpu=gpu,\n    )\n    semulated_array += np.random.normal(0, 0.03, semulated_array.shape)\n    return self.model_copy(update={\"device_array\": semulated_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.ternarize","title":"<code>ternarize(eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the device geometry based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the ternarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n    \"\"\"\n    Ternarize the device geometry based on two thresholds. This function is useful\n    for flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    eta1 : float\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the ternarized geometry.\n    \"\"\"\n    ternarized_device_array = geometry.ternarize(\n        device_array=self.flatten().device_array, eta1=eta1, eta2=eta2\n    )\n    return self.model_copy(update={\"device_array\": ternarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_3d","title":"<code>to_3d(thickness_nm)</code>","text":"<p>Convert the 2D device geometry into a 3D representation.</p> <p>This method creates a 3D array by interpolating between the bottom and top layers of the device geometry. The interpolation is linear.</p> <p>Parameters:</p> Name Type Description Default <code>thickness_nm</code> <code>int</code> <p>The thickness of the 3D representation in nanometers.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D narray representing the device geometry with the specified thickness.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_3d(self, thickness_nm: int) -&gt; np.ndarray:\n    \"\"\"\n    Convert the 2D device geometry into a 3D representation.\n\n    This method creates a 3D array by interpolating between the bottom and top\n    layers of the device geometry. The interpolation is linear.\n\n    Parameters\n    ----------\n    thickness_nm : int\n        The thickness of the 3D representation in nanometers.\n\n    Returns\n    -------\n    np.ndarray\n        A 3D narray representing the device geometry with the specified thickness.\n    \"\"\"\n    bottom_layer = self.device_array[:, :, 0]\n    top_layer = self.device_array[:, :, -1]\n    dt_bottom = np.array(distance_transform_edt(bottom_layer)) - np.array(\n        distance_transform_edt(1 - bottom_layer)\n    )\n    dt_top = np.array(distance_transform_edt(top_layer)) - np.array(\n        distance_transform_edt(1 - top_layer)\n    )\n    weights = np.linspace(0, 1, thickness_nm)\n    layered_array = np.zeros(\n        (bottom_layer.shape[0], bottom_layer.shape[1], thickness_nm)\n    )\n    for i, w in enumerate(weights):\n        dt_interp = (1 - w) * dt_bottom + w * dt_top\n        layered_array[:, :, i] = dt_interp &gt;= 0\n    return layered_array\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gds","title":"<code>to_gds(gds_path='prefab_device.gds', cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2, origin=(0.0, 0.0))</code>","text":"<p>Exports the device geometry as a GDSII file.</p> <p>This method converts the device geometry into a format suitable for GDSII files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The path where the GDSII file will be saved. If not specified, the file is saved as \"prefab_device.gds\" in the current directory.</p> <code>'prefab_device.gds'</code> <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDSII file. If not specified, defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSII file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> <code>origin</code> <code>tuple[float, float]</code> <p>The x and y coordinates of the origin in \u00b5m for the GDSII export. Defaults to (0.0, 0.0).</p> <code>(0.0, 0.0)</code> Source code in <code>prefab/device.py</code> <pre><code>def to_gds(\n    self,\n    gds_path: str = \"prefab_device.gds\",\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n    origin: tuple[float, float] = (0.0, 0.0),\n):\n    \"\"\"\n    Exports the device geometry as a GDSII file.\n\n    This method converts the device geometry into a format suitable for GDSII files.\n    The conversion involves contour approximation to simplify the geometry while\n    preserving essential features.\n\n    Parameters\n    ----------\n    gds_path : str\n        The path where the GDSII file will be saved. If not specified, the file is\n        saved as \"prefab_device.gds\" in the current directory.\n    cell_name : str\n        The name of the cell within the GDSII file. If not specified, defaults to\n        \"prefab_device\".\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n    contour_approx_mode : int\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    origin : tuple[float, float]\n        The x and y coordinates of the origin in \u00b5m for the GDSII export. Defaults\n        to (0.0, 0.0).\n    \"\"\"\n    gdstk_cell = self.flatten()._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n        origin=origin,\n    )\n    print(f\"Saving GDS to '{gds_path}'...\")\n    gdstk_library = gdstk.Library()\n    gdstk_library.add(gdstk_cell)\n    gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gdsfactory","title":"<code>to_gdsfactory()</code>","text":"<p>Convert the device geometry to a gdsfactory Component.</p> <p>Returns:</p> Type Description <code>Component</code> <p>A gdsfactory Component object representing the device geometry.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the gdsfactory package is not installed.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdsfactory(self) -&gt; \"gf.Component\":\n    \"\"\"\n    Convert the device geometry to a gdsfactory Component.\n\n    Returns\n    -------\n    gf.Component\n        A gdsfactory Component object representing the device geometry.\n\n    Raises\n    ------\n    ImportError\n        If the gdsfactory package is not installed.\n    \"\"\"\n    try:\n        import gdsfactory as gf\n    except ImportError:\n        raise ImportError(\n            \"The gdsfactory package is required to use this function; \"\n            \"try `pip install gdsfactory`.\"\n        ) from None\n\n    device_array = np.rot90(self.to_ndarray(), k=-1)\n    return gf.read.from_np(device_array, nm_per_pixel=1)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gdstk","title":"<code>to_gdstk(cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2, origin=(0.0, 0.0))</code>","text":"<p>Converts the device geometry to a GDSTK cell object.</p> <p>This method prepares the device geometry for GDSII file export by converting it into a GDSTK cell object. GDSTK is a Python module for creating and manipulating GDSII layout files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>The name of the cell to be created. Defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> <code>origin</code> <code>tuple[float, float]</code> <p>The x and y coordinates of the origin in \u00b5m for the GDSTK cell. Defaults to (0.0, 0.0).</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Type Description <code>Cell</code> <p>The GDSTK cell object representing the device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdstk(\n    self,\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n    origin: tuple[float, float] = (0.0, 0.0),\n):\n    \"\"\"\n    Converts the device geometry to a GDSTK cell object.\n\n    This method prepares the device geometry for GDSII file export by converting it\n    into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n    GDSII layout files. The conversion involves contour approximation to simplify\n    the geometry while preserving essential features.\n\n    Parameters\n    ----------\n    cell_name : str\n        The name of the cell to be created. Defaults to \"prefab_device\".\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    contour_approx_mode : int\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    origin : tuple[float, float]\n        The x and y coordinates of the origin in \u00b5m for the GDSTK cell. Defaults\n        to (0.0, 0.0).\n\n    Returns\n    -------\n    gdstk.Cell\n        The GDSTK cell object representing the device geometry.\n    \"\"\"\n    # print(f\"Creating cell '{cell_name}'...\")\n    gdstk_cell = self.flatten()._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n        origin=origin,\n    )\n    return gdstk_cell\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_img","title":"<code>to_img(img_path='prefab_device.png')</code>","text":"<p>Exports the device geometry as an image file.</p> <p>This method converts the device geometry to an ndarray using <code>to_ndarray</code>, scales the values to the range [0, 255] for image representation, and saves the result as an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path where the image file will be saved. If not specified, the image is saved as \"prefab_device.png\" in the current directory.</p> <code>'prefab_device.png'</code> Source code in <code>prefab/device.py</code> <pre><code>def to_img(self, img_path: str = \"prefab_device.png\"):\n    \"\"\"\n    Exports the device geometry as an image file.\n\n    This method converts the device geometry to an ndarray using `to_ndarray`,\n    scales the values to the range [0, 255] for image representation, and saves the\n    result as an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path where the image file will be saved. If not specified, the image is\n        saved as \"prefab_device.png\" in the current directory.\n    \"\"\"\n    cv2.imwrite(img_path, 255 * self.flatten().to_ndarray())\n    print(f\"Saved Device image to '{img_path}'\")\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_ndarray","title":"<code>to_ndarray()</code>","text":"<p>Converts the device geometry to an ndarray.</p> <p>This method applies the buffer specifications to crop the device array if necessary, based on the buffer mode ('edge' or 'constant'). It then returns the resulting ndarray representing the device geometry.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ndarray representation of the device geometry, with any applied buffer cropping.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_ndarray(self) -&gt; np.ndarray:\n    \"\"\"\n    Converts the device geometry to an ndarray.\n\n    This method applies the buffer specifications to crop the device array if\n    necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n    resulting ndarray representing the device geometry.\n\n    Returns\n    -------\n    np.ndarray\n        The ndarray representation of the device geometry, with any applied buffer\n        cropping.\n    \"\"\"\n    device_array = np.copy(self.device_array)\n    buffer_thickness = self.buffer_spec.thickness\n\n    crop_top = buffer_thickness[\"top\"]\n    crop_bottom = buffer_thickness[\"bottom\"]\n    crop_left = buffer_thickness[\"left\"]\n    crop_right = buffer_thickness[\"right\"]\n\n    ndarray = device_array[\n        crop_top : device_array.shape[0] - crop_bottom,\n        crop_left : device_array.shape[1] - crop_right,\n    ]\n    return ndarray\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_stl","title":"<code>to_stl(thickness_nm, filename='prefab_device.stl')</code>","text":"<p>Export the device geometry as an STL file.</p> <p>Parameters:</p> Name Type Description Default <code>thickness_nm</code> <code>int</code> <p>The thickness of the 3D representation in nanometers.</p> required <code>filename</code> <code>str</code> <p>The name of the STL file to save. Defaults to \"prefab_device.stl\".</p> <code>'prefab_device.stl'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the thickness is not a positive integer.</p> <code>ImportError</code> <p>If the numpy-stl package is not installed.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_stl(self, thickness_nm: int, filename: str = \"prefab_device.stl\"):\n    \"\"\"\n    Export the device geometry as an STL file.\n\n    Parameters\n    ----------\n    thickness_nm : int\n        The thickness of the 3D representation in nanometers.\n    filename : str\n        The name of the STL file to save. Defaults to \"prefab_device.stl\".\n\n    Raises\n    ------\n    ValueError\n        If the thickness is not a positive integer.\n    ImportError\n        If the numpy-stl package is not installed.\n    \"\"\"\n    try:\n        from stl import mesh  # type: ignore\n    except ImportError:\n        raise ImportError(\n            \"The stl package is required to use this function; \"\n            \"try `pip install numpy-stl`.\"\n        ) from None\n\n    if thickness_nm &lt;= 0:\n        raise ValueError(\"Thickness must be a positive integer.\")\n\n    layered_array = self.to_3d(thickness_nm)\n    layered_array = np.pad(\n        layered_array, ((0, 0), (0, 0), (10, 10)), mode=\"constant\"\n    )\n    verts, faces, _, _ = measure.marching_cubes(layered_array, level=0.5)\n    cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))\n    for i, f in enumerate(faces):\n        for j in range(3):\n            cube.vectors[i][j] = verts[f[j], :]\n    cube.save(filename)\n    print(f\"Saved Device to '{filename}'\")\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_tidy3d","title":"<code>to_tidy3d(eps0, thickness)</code>","text":"<p>Convert the device geometry to a Tidy3D Structure.</p> <p>Parameters:</p> Name Type Description Default <code>eps0</code> <code>float</code> <p>The permittivity value to assign to the device array.</p> required <code>thickness</code> <code>float</code> <p>The thickness of the device in the z-direction.</p> required <p>Returns:</p> Type Description <code>Structure</code> <p>A Tidy3D Structure object representing the device geometry.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the tidy3d package is not installed.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_tidy3d(\n    self,\n    eps0: float,\n    thickness: float,\n) -&gt; \"td.Structure\":\n    \"\"\"\n    Convert the device geometry to a Tidy3D Structure.\n\n    Parameters\n    ----------\n    eps0 : float\n        The permittivity value to assign to the device array.\n    thickness : float\n        The thickness of the device in the z-direction.\n\n    Returns\n    -------\n    td.Structure\n        A Tidy3D Structure object representing the device geometry.\n\n    Raises\n    ------\n    ImportError\n        If the tidy3d package is not installed.\n    \"\"\"\n    try:\n        from tidy3d import Box, CustomMedium, SpatialDataArray, Structure, inf\n    except ImportError:\n        raise ImportError(\n            \"The tidy3d package is required to use this function; \"\n            \"try `pip install tidy3d`.\"\n        ) from None\n\n    X = np.linspace(-self.shape[1] / 2000, self.shape[1] / 2000, self.shape[1])\n    Y = np.linspace(-self.shape[0] / 2000, self.shape[0] / 2000, self.shape[0])\n    Z = np.array([0])\n\n    device_array = np.rot90(np.fliplr(self.device_array), k=1)\n    eps_array = np.where(device_array &gt;= 1.0, eps0, device_array)\n    eps_array = np.where(eps_array &lt; 1.0, 1.0, eps_array)\n    eps_dataset = SpatialDataArray(eps_array, coords=dict(x=X, y=Y, z=Z))\n    medium = CustomMedium.from_eps_raw(eps_dataset)\n    return Structure(\n        geometry=Box(center=(0, 0, 0), size=(inf, inf, thickness), attrs={}),\n        medium=medium,\n        name=\"device\",\n        attrs={},\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.trim","title":"<code>trim()</code>","text":"<p>Trim the device geometry by removing empty space around it.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the trimmed geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def trim(self) -&gt; \"Device\":\n    \"\"\"\n    Trim the device geometry by removing empty space around it.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the trimmed geometry.\n    \"\"\"\n    trimmed_device_array = geometry.trim(\n        device_array=self.device_array,\n        buffer_thickness=self.buffer_spec.thickness,\n    )\n    return self.model_copy(update={\"device_array\": trimmed_device_array})\n</code></pre>"},{"location":"reference/geometry/","title":"Geometry","text":"<p>Provides functions for manipulating ndarrays of device geometries.</p>"},{"location":"reference/geometry/#prefab.geometry.binarize","title":"<code>binarize(device_array, eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the input ndarray based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize(\n    device_array: np.ndarray, eta: float = 0.5, beta: float = np.inf\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input ndarray based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements scaled to 0 or 1.\n    \"\"\"\n    return (np.tanh(beta * eta) + np.tanh(beta * (device_array - eta))) / (\n        np.tanh(beta * eta) + np.tanh(beta * (1 - eta))\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_hard","title":"<code>binarize_hard(device_array, eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the input ndarray. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements set to 0 or 1 based on the threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_hard(device_array: np.ndarray, eta: float = 0.5) -&gt; np.ndarray:\n    \"\"\"\n    Apply a hard threshold to binarize the input ndarray. The `binarize` function is\n    generally preferred for most use cases, but it can create numerical artifacts for\n    large beta values.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the threshold.\n    \"\"\"\n    return np.where(device_array &lt; eta, 0.0, 1.0)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_monte_carlo","title":"<code>binarize_monte_carlo(device_array, noise_magnitude, blur_radius)</code>","text":"<p>Binarize the input ndarray using a dynamic thresholding approach to simulate surface roughness.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the array using Gaussian blurring, simulating a potentially more realistic scenario where the threshold is not uniform across the device.</p> Notes <p>This is a temporary solution, where the defaults are chosen based on what looks good. A better, data-driven approach is needed.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>noise_magnitude</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold.</p> required <code>blur_radius</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements set to 0 or 1 based on the dynamically generated threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_monte_carlo(\n    device_array: np.ndarray,\n    noise_magnitude: float,\n    blur_radius: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input ndarray using a dynamic thresholding approach to simulate surface\n    roughness.\n\n    This function applies a dynamic thresholding technique where the threshold value is\n    determined by a base value perturbed by Gaussian-distributed random noise. The\n    threshold is then spatially varied across the array using Gaussian blurring,\n    simulating a potentially more realistic scenario where the threshold is not uniform\n    across the device.\n\n    Notes\n    -----\n    This is a temporary solution, where the defaults are chosen based on what looks\n    good. A better, data-driven approach is needed.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    noise_magnitude : float\n        The standard deviation of the Gaussian distribution used to generate noise for\n        the threshold values. This controls the amount of randomness in the threshold.\n    blur_radius : float\n        The standard deviation for the Gaussian kernel used in blurring the threshold\n        map. This controls the spatial variation of the threshold across the array.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the dynamically\n        generated threshold.\n    \"\"\"\n    device_array = np.squeeze(device_array)\n    base_threshold = np.random.normal(loc=0.5, scale=0.1)\n    threshold_noise = np.random.normal(\n        loc=0, scale=noise_magnitude, size=device_array.shape\n    )\n    spatial_threshold = cv2.GaussianBlur(\n        threshold_noise, ksize=(0, 0), sigmaX=blur_radius\n    )\n    dynamic_threshold = base_threshold + spatial_threshold\n    binarized_array = np.where(device_array &lt; dynamic_threshold, 0.0, 1.0)\n    binarized_array = np.expand_dims(binarized_array, axis=-1)\n    return binarized_array\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_sem","title":"<code>binarize_sem(sem_array)</code>","text":"<p>Binarize a grayscale scanning electron microscope (SEM) image.</p> <p>This function applies Otsu's method to automatically determine the optimal threshold value for binarization of a grayscale SEM image.</p> <p>Parameters:</p> Name Type Description Default <code>sem_array</code> <code>ndarray</code> <p>The input SEM image array to be binarized.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized SEM image array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_sem(sem_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Binarize a grayscale scanning electron microscope (SEM) image.\n\n    This function applies Otsu's method to automatically determine the optimal threshold\n    value for binarization of a grayscale SEM image.\n\n    Parameters\n    ----------\n    sem_array : np.ndarray\n        The input SEM image array to be binarized.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized SEM image array with elements scaled to 0 or 1.\n    \"\"\"\n    return cv2.threshold(\n        sem_array.astype(\"uint8\"), 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU\n    )[1]\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.blur","title":"<code>blur(device_array, sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the input ndarray and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be blurred.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The blurred and normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def blur(device_array: np.ndarray, sigma: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Apply Gaussian blur to the input ndarray and normalize the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be blurred.\n    sigma : float\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        The blurred and normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return np.expand_dims(\n        normalize(cv2.GaussianBlur(device_array, ksize=(0, 0), sigmaX=sigma)), axis=-1\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.dilate","title":"<code>dilate(device_array, kernel_size)</code>","text":"<p>Dilate the input ndarray using a specified kernel size.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry to be dilated.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The dilated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def dilate(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Dilate the input ndarray using a specified kernel size.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be dilated.\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    np.ndarray\n        The dilated array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return np.expand_dims(cv2.dilate(device_array, kernel=kernel), axis=-1)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.enforce_feature_size","title":"<code>enforce_feature_size(device_array, min_feature_size, strel='disk')</code>","text":"<p>Enforce a minimum feature size on the device geometry.</p> <p>This function applies morphological operations to ensure that all features in the device geometry are at least the specified minimum size. It uses either a disk or square structuring element for the operations.</p> Notes <p>This function does not guarantee that the minimum feature size is enforced in all cases. A better process is needed.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry.</p> required <code>min_feature_size</code> <code>int</code> <p>The minimum feature size to enforce, in nanometers.</p> required <code>strel</code> <code>str</code> <p>The type of structuring element to use. Can be either \"disk\" or \"square\". Defaults to \"disk\".</p> <code>'disk'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The modified device array with enforced feature size.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid structuring element type is specified.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def enforce_feature_size(\n    device_array: np.ndarray, min_feature_size: int, strel: str = \"disk\"\n) -&gt; np.ndarray:\n    \"\"\"\n    Enforce a minimum feature size on the device geometry.\n\n    This function applies morphological operations to ensure that all features in the\n    device geometry are at least the specified minimum size. It uses either a disk\n    or square structuring element for the operations.\n\n    Notes\n    -----\n    This function does not guarantee that the minimum feature size is enforced in all\n    cases. A better process is needed.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry.\n    min_feature_size : int\n        The minimum feature size to enforce, in nanometers.\n    strel : str\n        The type of structuring element to use. Can be either \"disk\" or \"square\".\n        Defaults to \"disk\".\n\n    Returns\n    -------\n    np.ndarray\n        The modified device array with enforced feature size.\n\n    Raises\n    ------\n    ValueError\n        If an invalid structuring element type is specified.\n    \"\"\"\n    if strel == \"disk\":\n        kernel = cv2.getStructuringElement(\n            cv2.MORPH_ELLIPSE, (min_feature_size, min_feature_size)\n        )\n    elif strel == \"square\":\n        kernel = cv2.getStructuringElement(\n            cv2.MORPH_RECT, (min_feature_size, min_feature_size)\n        )\n    else:\n        raise ValueError(f\"Invalid structuring element: {strel}\")\n\n    device_array_2d = (device_array[:, :, 0] * 255).astype(np.uint8)\n    modified_geometry = cv2.morphologyEx(device_array_2d, cv2.MORPH_CLOSE, kernel)\n    modified_geometry = cv2.morphologyEx(modified_geometry, cv2.MORPH_OPEN, kernel)\n\n    return np.expand_dims(modified_geometry.astype(float) / 255, axis=-1)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.erode","title":"<code>erode(device_array, kernel_size)</code>","text":"<p>Erode the input ndarray using a specified kernel size and number of iterations.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry to be eroded.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The eroded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def erode(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Erode the input ndarray using a specified kernel size and number of iterations.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be eroded.\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    np.ndarray\n        The eroded array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return np.expand_dims(cv2.erode(device_array, kernel=kernel), axis=-1)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.flatten","title":"<code>flatten(device_array)</code>","text":"<p>Flatten the input ndarray by summing the vertical layers and normalizing the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be flattened.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The flattened array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def flatten(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Flatten the input ndarray by summing the vertical layers and normalizing the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be flattened.\n\n    Returns\n    -------\n    np.ndarray\n        The flattened array with values scaled between 0 and 1.\n    \"\"\"\n    return normalize(np.sum(device_array, axis=-1, keepdims=True))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.normalize","title":"<code>normalize(device_array)</code>","text":"<p>Normalize the input ndarray to have values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be normalized.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def normalize(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Normalize the input ndarray to have values between 0 and 1.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be normalized.\n\n    Returns\n    -------\n    np.ndarray\n        The normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return (device_array - np.min(device_array)) / (\n        np.max(device_array) - np.min(device_array)\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.pad","title":"<code>pad(device_array, pad_width)</code>","text":"<p>Pad the input ndarray uniformly with a specified width on all sides.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be padded.</p> required <code>pad_width</code> <code>int</code> <p>The number of pixels to pad on each side.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The padded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def pad(device_array: np.ndarray, pad_width: int) -&gt; np.ndarray:\n    \"\"\"\n    Pad the input ndarray uniformly with a specified width on all sides.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be padded.\n    pad_width : int\n        The number of pixels to pad on each side.\n\n    Returns\n    -------\n    np.ndarray\n        The padded array.\n    \"\"\"\n    return np.pad(\n        device_array,\n        pad_width=((pad_width, pad_width), (pad_width, pad_width), (0, 0)),\n        mode=\"constant\",\n        constant_values=0,\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.rotate","title":"<code>rotate(device_array, angle)</code>","text":"<p>Rotate the input ndarray by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be rotated.</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rotated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def rotate(device_array: np.ndarray, angle: float) -&gt; np.ndarray:\n    \"\"\"\n    Rotate the input ndarray by a given angle.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be rotated.\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    np.ndarray\n        The rotated array.\n    \"\"\"\n    center = (device_array.shape[1] / 2, device_array.shape[0] / 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center=center, angle=angle, scale=1)\n    return np.expand_dims(\n        cv2.warpAffine(\n            device_array,\n            M=rotation_matrix,\n            dsize=(device_array.shape[1], device_array.shape[0]),\n        ),\n        axis=-1,\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.ternarize","title":"<code>ternarize(device_array, eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the input ndarray based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be ternarized.</p> required <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def ternarize(\n    device_array: np.ndarray, eta1: float = 1 / 3, eta2: float = 2 / 3\n) -&gt; np.ndarray:\n    \"\"\"\n    Ternarize the input ndarray based on two thresholds. This function is useful for\n    flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be ternarized.\n    eta1 : float\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    np.ndarray\n        The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.\n    \"\"\"\n    return np.where(device_array &lt; eta1, 0.0, np.where(device_array &gt;= eta2, 1.0, 0.5))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.trim","title":"<code>trim(device_array, buffer_thickness=None)</code>","text":"<p>Trim the input ndarray by removing rows and columns that are completely zero.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be trimmed.</p> required <code>buffer_thickness</code> <code>Optional[dict[str, int]]</code> <p>A dictionary specifying the thickness of the buffer to leave around the non-zero elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'. Defaults to None, which means no buffer is added.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The trimmed array, potentially with a buffer around the non-zero elements.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def trim(\n    device_array: np.ndarray, buffer_thickness: Optional[dict[str, int]] = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Trim the input ndarray by removing rows and columns that are completely zero.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be trimmed.\n    buffer_thickness : Optional[dict[str, int]]\n        A dictionary specifying the thickness of the buffer to leave around the non-zero\n        elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'.\n        Defaults to None, which means no buffer is added.\n\n    Returns\n    -------\n    np.ndarray\n        The trimmed array, potentially with a buffer around the non-zero elements.\n    \"\"\"\n    if buffer_thickness is None:\n        buffer_thickness = {\"top\": 0, \"bottom\": 0, \"left\": 0, \"right\": 0}\n\n    nonzero_rows, nonzero_cols = np.nonzero(np.squeeze(device_array))\n    row_min = max(nonzero_rows.min() - buffer_thickness.get(\"top\", 0), 0)\n    row_max = min(\n        nonzero_rows.max() + buffer_thickness.get(\"bottom\", 0) + 1,\n        device_array.shape[0],\n    )\n    col_min = max(nonzero_cols.min() - buffer_thickness.get(\"left\", 0), 0)\n    col_max = min(\n        nonzero_cols.max() + buffer_thickness.get(\"right\", 0) + 1,\n        device_array.shape[1],\n    )\n    return device_array[\n        row_min:row_max,\n        col_min:col_max,\n    ]\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>Models for the PreFab library.</p>"},{"location":"reference/models/#prefab.models.Fab","title":"<code>Fab</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a fabrication process in the PreFab model library.</p> <p>Attributes:</p> Name Type Description <code>foundry</code> <code>str</code> <p>The name of the foundry where the fabrication process takes place.</p> <code>process</code> <code>str</code> <p>The specific process used in the fabrication.</p> <code>material</code> <code>str</code> <p>The material used in the fabrication process.</p> <code>technology</code> <code>str</code> <p>The technology used in the fabrication process.</p> <code>thickness</code> <code>int</code> <p>The thickness of the material used, measured in nanometers.</p> <code>has_sidewall</code> <code>bool</code> <p>Indicates whether the fabrication has angled sidewalls.</p> Source code in <code>prefab/models.py</code> <pre><code>class Fab(BaseModel):\n    \"\"\"\n    Represents a fabrication process in the PreFab model library.\n\n    Attributes\n    ----------\n    foundry : str\n        The name of the foundry where the fabrication process takes place.\n    process : str\n        The specific process used in the fabrication.\n    material : str\n        The material used in the fabrication process.\n    technology : str\n        The technology used in the fabrication process.\n    thickness : int\n        The thickness of the material used, measured in nanometers.\n    has_sidewall : bool\n        Indicates whether the fabrication has angled sidewalls.\n    \"\"\"\n\n    foundry: str\n    process: str\n    material: str\n    technology: str\n    thickness: int\n    has_sidewall: bool\n</code></pre>"},{"location":"reference/models/#prefab.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a model of a fabrication process including versioning and dataset detail.</p> <p>Attributes:</p> Name Type Description <code>fab</code> <code>Fab</code> <p>An instance of the Fab class representing the fabrication details.</p> <code>version</code> <code>str</code> <p>The version identifier of the model.</p> <code>version_date</code> <code>date</code> <p>The release date of this version of the model.</p> <code>dataset</code> <code>str</code> <p>The identifier for the dataset used in this model.</p> <code>dataset_date</code> <code>date</code> <p>The date when the dataset was last updated or released.</p> <code>tag</code> <code>str</code> <p>An optional tag for additional categorization or notes.</p> <p>Methods:</p> Name Description <code>to_json</code> <p>Serializes the model instance to a JSON formatted string.</p> Source code in <code>prefab/models.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Represents a model of a fabrication process including versioning and dataset detail.\n\n    Attributes\n    ----------\n    fab : Fab\n        An instance of the Fab class representing the fabrication details.\n    version : str\n        The version identifier of the model.\n    version_date : date\n        The release date of this version of the model.\n    dataset : str\n        The identifier for the dataset used in this model.\n    dataset_date : date\n        The date when the dataset was last updated or released.\n    tag : str\n        An optional tag for additional categorization or notes.\n\n    Methods\n    -------\n    to_json()\n        Serializes the model instance to a JSON formatted string.\n    \"\"\"\n\n    fab: Fab\n    version: str\n    version_date: date\n    dataset: str\n    dataset_date: date\n    tag: str\n\n    def to_json(self):\n        return json.dumps(self.dict(), default=str)\n</code></pre>"},{"location":"reference/predict/","title":"Predict","text":"<p>Prediction functions for ndarrays of device geometries.</p>"},{"location":"reference/predict/#prefab.predict.predict_array","title":"<code>predict_array(device_array, model, model_type, binarize, gpu=False)</code>","text":"<p>Predict the nanofabrication outcome of a device array using a specified model.</p> <p>This function sends the device array to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process. The prediction can be performed on a GPU if specified.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device. This array undergoes various transformations to predict the nanofabrication process.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>model_type</code> <code>str</code> <p>The type of model to use (e.g., 'p' for prediction, 'c' for correction, or 's' for SEMulate).</p> required <code>binarize</code> <code>bool</code> <p>If True, the predicted device geometry will be binarized using a threshold method. This is useful for converting probabilistic predictions into binary geometries.</p> required <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more startup overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The predicted output array.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the request to the prediction service fails.</p> Source code in <code>prefab/predict.py</code> <pre><code>def predict_array(\n    device_array: np.ndarray,\n    model: Model,\n    model_type: str,\n    binarize: bool,\n    gpu: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"\n    Predict the nanofabrication outcome of a device array using a specified model.\n\n    This function sends the device array to a serverless prediction service, which uses\n    a specified machine learning model to predict the outcome of the nanofabrication\n    process. The prediction can be performed on a GPU if specified.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array undergoes\n        various transformations to predict the nanofabrication process.\n    model : Model\n        The model to use for prediction, representing a specific fabrication process and\n        dataset. This model encapsulates details about the fabrication foundry, process,\n        material, technology, thickness, and sidewall presence, as defined in\n        `models.py`. Each model is associated with a version and dataset that detail its\n        creation and the data it was trained on, ensuring the prediction is tailored to\n        specific fabrication parameters.\n    model_type : str\n        The type of model to use (e.g., 'p' for prediction, 'c' for correction, or 's'\n        for SEMulate).\n    binarize : bool\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries.\n    gpu : bool\n        If True, the prediction will be performed on a GPU. Defaults to False. Note: The\n        GPU option has more startup overhead and will take longer for small devices, but\n        will be faster for larger devices.\n\n    Returns\n    -------\n    np.ndarray\n        The predicted output array.\n\n    Raises\n    ------\n    RuntimeError\n        If the request to the prediction service fails.\n    \"\"\"\n    headers = _prepare_headers()\n    predict_data = _prepare_predict_data(device_array, model, model_type, binarize)\n    endpoint_url = (\n        f\"{BASE_ENDPOINT_URL}-gpu-v{ENDPOINT_VERSION}.modal.run\"\n        if gpu\n        else f\"{BASE_ENDPOINT_URL}-v{ENDPOINT_VERSION}.modal.run\"\n    )\n\n    try:\n        with requests.post(\n            endpoint_url,\n            data=json.dumps(predict_data),\n            headers=headers,\n            stream=True,\n        ) as response:\n            response.raise_for_status()\n            result = _process_response(response, model_type, binarize)\n            if result is None:\n                raise RuntimeError(\"No prediction result received.\")\n            return result\n    except requests.RequestException as e:\n        raise RuntimeError(f\"Request failed: {e}\") from e\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_array_with_grad","title":"<code>predict_array_with_grad(device_array, model)</code>","text":"<p>Predict the nanofabrication outcome of a device array and compute its gradient.</p> <p>This function predicts the outcome of the nanofabrication process for a given device array using a specified model. It also computes the gradient of the prediction with respect to the input device array, making it suitable for use in automatic differentiation applications (e.g., autograd).</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The predicted output array.</p> Source code in <code>prefab/predict.py</code> <pre><code>@primitive\ndef predict_array_with_grad(device_array: np.ndarray, model: Model) -&gt; np.ndarray:\n    \"\"\"\n    Predict the nanofabrication outcome of a device array and compute its gradient.\n\n    This function predicts the outcome of the nanofabrication process for a given\n    device array using a specified model. It also computes the gradient of the\n    prediction with respect to the input device array, making it suitable for use in\n    automatic differentiation applications (e.g., autograd).\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device.\n    model : Model\n        The model to use for prediction, representing a specific fabrication process.\n\n    Returns\n    -------\n    np.ndarray\n        The predicted output array.\n    \"\"\"\n    prediction_array, gradient_array = _predict_array_with_grad(\n        device_array=device_array, model=model\n    )\n    predict_array_with_grad.gradient_array = gradient_array  # type: ignore\n    return prediction_array\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_array_with_grad_vjp","title":"<code>predict_array_with_grad_vjp(ans, device_array, *args)</code>","text":"<p>Define the vector-Jacobian product (VJP) for the prediction function.</p> <p>Parameters:</p> Name Type Description Default <code>ans</code> <code>ndarray</code> <p>The output of the <code>predict_array_with_grad</code> function.</p> required <code>device_array</code> <code>ndarray</code> <p>The input device array for which the gradient is computed.</p> required <code>*args</code> <p>Additional arguments that aren't used in the VJP computation.</p> <code>()</code> <p>Returns:</p> Type Description <code>function</code> <p>A function that computes the VJP given an upstream gradient <code>g</code>.</p> Source code in <code>prefab/predict.py</code> <pre><code>def predict_array_with_grad_vjp(ans: np.ndarray, device_array: np.ndarray, *args):\n    \"\"\"\n    Define the vector-Jacobian product (VJP) for the prediction function.\n\n    Parameters\n    ----------\n    ans : np.ndarray\n        The output of the `predict_array_with_grad` function.\n    device_array : np.ndarray\n        The input device array for which the gradient is computed.\n    *args :\n        Additional arguments that aren't used in the VJP computation.\n\n    Returns\n    -------\n    function\n        A function that computes the VJP given an upstream gradient `g`.\n    \"\"\"\n    grad_x = predict_array_with_grad.gradient_array  # type: ignore\n\n    def vjp(g: np.ndarray) -&gt; np.ndarray:\n        return g * grad_x\n\n    return vjp\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_gdstk","title":"<code>predict_gdstk(gdstk_cell, model, model_type, gds_layer=(1, 0), eta=0.5)</code>","text":"<p>Predict the nanofabrication outcome of a gdstk cell using a specified model.</p> <p>This function extracts polygons from a gdstk cell, sends them to the prediction server, and returns a new cell containing the predicted polygons.</p> <p>Parameters:</p> Name Type Description Default <code>gdstk_cell</code> <code>Cell</code> <p>The gdstk.Cell object containing polygons to predict.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>model_type</code> <code>str</code> <p>The type of model to use ('p' for prediction, 'c' for correction).</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5. Because intermediate values cannot be preserved in the polygon data, the predicted polygons are binarized using a threshold value of eta.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Cell</code> <p>A new gdstk cell containing the predicted polygons. For multi-level predictions, each level's polygons will be placed on a different layer: - Level 0: (layer, 99) - Level 1: (layer, 100)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no polygons are found in the specified layer.</p> Source code in <code>prefab/predict.py</code> <pre><code>def predict_gdstk(\n    gdstk_cell: gdstk.Cell,\n    model: Model,\n    model_type: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    eta: float = 0.5,\n) -&gt; gdstk.Cell:\n    \"\"\"\n    Predict the nanofabrication outcome of a gdstk cell using a specified model.\n\n    This function extracts polygons from a gdstk cell, sends them to the prediction\n    server, and returns a new cell containing the predicted polygons.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object containing polygons to predict.\n    model : Model\n        The model to use for prediction, representing a specific fabrication process and\n        dataset. This model encapsulates details about the fabrication foundry, process,\n        material, technology, thickness, and sidewall presence, as defined in\n        `models.py`. Each model is associated with a version and dataset that detail its\n        creation and the data it was trained on, ensuring the prediction is tailored to\n        specific fabrication parameters.\n    model_type : str\n        The type of model to use ('p' for prediction, 'c' for correction).\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    eta : float\n        The threshold value for binarization. Defaults to 0.5. Because intermediate\n        values cannot be preserved in the polygon data, the predicted polygons are\n        binarized using a threshold value of eta.\n\n    Returns\n    -------\n    gdstk.Cell\n        A new gdstk cell containing the predicted polygons. For multi-level\n        predictions, each level's polygons will be placed on a different layer:\n        - Level 0: (layer, 99)\n        - Level 1: (layer, 100)\n\n    Raises\n    ------\n    ValueError\n        If no polygons are found in the specified layer.\n    \"\"\"\n    polygons = gdstk_cell.get_polygons(layer=gds_layer[0], datatype=gds_layer[1])\n    if not polygons:\n        raise ValueError(\"No polygons found in the specified layer\")\n\n    polygon_points = [polygon.points.tolist() for polygon in polygons]\n\n    predicted_polygon_data = _predict_poly(\n        polygon_points=polygon_points,\n        model=model,\n        model_type=model_type,\n        eta=eta,\n    )\n\n    result_cell = gdstk.Cell(f\"{gdstk_cell.name}_predicted\")\n\n    polygons_by_channel = {}\n    for polygon_data in predicted_polygon_data:\n        channel = polygon_data.get(\"channel\", 0)\n        points = polygon_data.get(\"points\", [])\n\n        if channel not in polygons_by_channel:\n            polygons_by_channel[channel] = []\n\n        polygons_by_channel[channel].append(points)\n\n    for channel, points_list in polygons_by_channel.items():\n        layer = gds_layer[0]\n        datatype = 99 + channel\n\n        for points in points_list:\n            points_array = np.array(points)\n            polygon = gdstk.Polygon(points_array, layer=layer, datatype=datatype)\n            result_cell.add(polygon)\n\n    return result_cell\n</code></pre>"},{"location":"reference/read/","title":"Read","text":"<p>Functions to create a Device from various data sources.</p>"},{"location":"reference/read/#prefab.read.from_gds","title":"<code>from_gds(gds_path, cell_name, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a GDS cell.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The file path to the GDS file.</p> required <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDS file to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the GDS file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>Optional[tuple[tuple[float, float], tuple[float, float]]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the specified cell from the GDS file, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gds(\n    gds_path: str,\n    cell_name: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: Optional[tuple[tuple[float, float], tuple[float, float]]] = None,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a GDS cell.\n\n    Parameters\n    ----------\n    gds_path : str\n        The file path to the GDS file.\n    cell_name : str\n        The name of the cell within the GDS file to be converted into a Device object.\n    gds_layer : tuple[int, int]\n        A tuple specifying the layer and datatype to be used from the GDS file. Defaults\n        to (1, 0).\n    bounds : Optional[tuple[tuple[float, float], tuple[float, float]]]\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the specified cell from the GDS file, after\n        processing based on the specified layer.\n    \"\"\"\n    gdstk_library = gdstk.read_gds(gds_path)\n    gdstk_cell = gdstk_library[cell_name]  # type: ignore\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_gdsfactory","title":"<code>from_gdsfactory(component, **kwargs)</code>","text":"<p>Create a Device from a gdsfactory component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The gdsfactory component to be converted into a Device object.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the gdsfactory component.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the gdsfactory package is not installed.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdsfactory(\n    component: \"gf.Component\",\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a gdsfactory component.\n\n    Parameters\n    ----------\n    component : gf.Component\n        The gdsfactory component to be converted into a Device object.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdsfactory component.\n\n    Raises\n    ------\n    ImportError\n        If the gdsfactory package is not installed.\n    \"\"\"\n    try:\n        import gdsfactory as gf  # noqa: F401\n    except ImportError:\n        raise ImportError(\n            \"The gdsfactory package is required to use this function; \"\n            \"try `pip install gdsfactory`.\"\n        ) from None\n\n    bounds = (\n        (component.xmin * 1000, component.ymin * 1000),\n        (component.xmax * 1000, component.ymax * 1000),\n    )\n\n    polygons = [\n        polygon\n        for polygons_list in component.get_polygons_points().values()\n        for polygon in polygons_list\n    ]\n\n    contours = [\n        np.array(\n            [\n                [[int(1000 * x - bounds[0][0]), int(1000 * y - bounds[0][1])]]\n                for x, y in polygon  # type: ignore\n            ]\n        )\n        for polygon in polygons\n    ]\n\n    device_array = np.zeros(\n        (int(bounds[1][1] - bounds[0][1]), int(bounds[1][0] - bounds[0][0])),\n        dtype=np.uint8,\n    )\n    cv2.fillPoly(img=device_array, pts=contours, color=(1, 1, 1))\n    device_array = np.flipud(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_gdstk","title":"<code>from_gdstk(gdstk_cell, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a gdstk cell.</p> <p>Parameters:</p> Name Type Description Default <code>gdstk_cell</code> <code>Cell</code> <p>The gdstk.Cell object to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>tuple[tuple[float, float], tuple[float, float]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS cell. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the gdstk.Cell, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdstk(\n    gdstk_cell: gdstk.Cell,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: Optional[tuple[tuple[float, float], tuple[float, float]]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a gdstk cell.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object to be converted into a Device object.\n    gds_layer : tuple[int, int]\n        A tuple specifying the layer and datatype to be used from the cell. Defaults to\n        (1, 0).\n    bounds : tuple[tuple[float, float], tuple[float, float]]\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS cell. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdstk.Cell, after processing based on the\n        specified layer.\n    \"\"\"\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_img","title":"<code>from_img(img_path, img_width_nm=None, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path to the image file to be converted into a Device object.</p> required <code>img_width_nm</code> <code>Optional[int]</code> <p>The width of the image in nanometers. If specified, the Device will be resized to this width while maintaining aspect ratio. If None, no resizing is performed.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the image will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale images into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed image, after optional resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_img(\n    img_path: str, img_width_nm: Optional[int] = None, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path to the image file to be converted into a Device object.\n    img_width_nm : Optional[int]\n        The width of the image in nanometers. If specified, the Device will be resized\n        to this width while maintaining aspect ratio. If None, no resizing is performed.\n    binarize : bool\n        If True, the image will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed image, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = cv2.imread(img_path, flags=cv2.IMREAD_GRAYSCALE) / 255\n    if img_width_nm is not None:\n        resolution = img_width_nm / device_array.shape[1]\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=resolution, fy=resolution\n        )\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_ndarray","title":"<code>from_ndarray(ndarray, resolution=1.0, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <code>ndarray</code> <p>The input array representing the device geometry.</p> required <code>resolution</code> <code>float</code> <p>The resolution of the ndarray in nanometers per pixel, defaulting to 1.0 nm per pixel. If specified, the input array will be resized based on this resolution to match the desired physical size.</p> <code>1.0</code> <code>binarize</code> <code>bool</code> <p>If True, the input array will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale arrays into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the input array, after resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_ndarray(\n    ndarray: np.ndarray, resolution: float = 1.0, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an ndarray.\n\n    Parameters\n    ----------\n    ndarray : np.ndarray\n        The input array representing the device geometry.\n    resolution : float\n        The resolution of the ndarray in nanometers per pixel, defaulting to 1.0 nm per\n        pixel. If specified, the input array will be resized based on this resolution to\n        match the desired physical size.\n    binarize : bool\n        If True, the input array will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale arrays\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the input array, after resizing and binarization.\n    \"\"\"\n    device_array = ndarray\n    if resolution != 1.0:\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=resolution, fy=resolution\n        )\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_sem","title":"<code>from_sem(sem_path, sem_resolution=None, sem_resolution_key=None, binarize=False, bounds=None, **kwargs)</code>","text":"<p>Create a Device from a scanning electron microscope (SEM) image file.</p> <p>Parameters:</p> Name Type Description Default <code>sem_path</code> <code>str</code> <p>The file path to the SEM image.</p> required <code>sem_resolution</code> <code>Optional[float]</code> <p>The resolution of the SEM image in nanometers per pixel. If not provided, it will be extracted from the image metadata using the <code>sem_resolution_key</code>.</p> <code>None</code> <code>sem_resolution_key</code> <code>Optional[str]</code> <p>The key to look for in the SEM image metadata to extract the resolution. Required if <code>sem_resolution</code> is not provided.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the SEM image will be binarized (converted to binary values) before conversion to a Device object. This is needed for processing grayscale images into binary masks. Defaults to False.</p> <code>False</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>A tuple specifying the bounds in nm for cropping the image before conversion, formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed SEM image.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>sem_resolution</code> nor <code>sem_resolution_key</code> is provided.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_sem(\n    sem_path: str,\n    sem_resolution: Optional[float] = None,\n    sem_resolution_key: Optional[str] = None,\n    binarize: bool = False,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a scanning electron microscope (SEM) image file.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution : Optional[float]\n        The resolution of the SEM image in nanometers per pixel. If not provided, it\n        will be extracted from the image metadata using the `sem_resolution_key`.\n    sem_resolution_key : Optional[str]\n        The key to look for in the SEM image metadata to extract the resolution.\n        Required if `sem_resolution` is not provided.\n    binarize : bool\n        If True, the SEM image will be binarized (converted to binary values) before\n        conversion to a Device object. This is needed for processing grayscale images\n        into binary masks. Defaults to False.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        A tuple specifying the bounds in nm for cropping the image before conversion,\n        formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is\n        used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed SEM image.\n\n    Raises\n    ------\n    ValueError\n        If neither `sem_resolution` nor `sem_resolution_key` is provided.\n    \"\"\"\n    if sem_resolution is None and sem_resolution_key is not None:\n        sem_resolution = get_sem_resolution(sem_path, sem_resolution_key)\n    elif sem_resolution is None:\n        raise ValueError(\"Either sem_resolution or resolution_key must be provided.\")\n\n    device_array = cv2.imread(sem_path, flags=cv2.IMREAD_GRAYSCALE)\n    device_array = cv2.resize(\n        device_array, dsize=(0, 0), fx=sem_resolution, fy=sem_resolution\n    )\n\n    if bounds is not None:\n        pad_left = max(0, -bounds[0][0])\n        pad_right = max(0, bounds[1][0] - device_array.shape[1])\n        pad_bottom = max(0, -bounds[0][1])\n        pad_top = max(0, bounds[1][1] - device_array.shape[0])\n\n        if pad_left or pad_right or pad_top or pad_bottom:\n            device_array = np.pad(\n                device_array,\n                ((pad_top, pad_bottom), (pad_left, pad_right)),\n                mode=\"constant\",\n                constant_values=0,\n            )\n\n        start_x = max(0, bounds[0][0] + pad_left)\n        end_x = min(device_array.shape[1], bounds[1][0] + pad_left)\n        start_y = max(0, device_array.shape[0] - (bounds[1][1] + pad_top))\n        end_y = min(\n            device_array.shape[0], device_array.shape[0] - (bounds[0][1] + pad_top)\n        )\n\n        if start_x &gt;= end_x or start_y &gt;= end_y:\n            raise ValueError(\n                \"Invalid bounds resulted in zero-size array: \"\n                f\"x=[{start_x}, {end_x}], \"\n                f\"y=[{start_y}, {end_y}]\"\n            )\n\n        device_array = device_array[start_y:end_y, start_x:end_x]\n\n    if binarize:\n        device_array = geometry.binarize_sem(device_array)\n\n    buffer_spec = BufferSpec(\n        mode={\n            \"top\": \"none\",\n            \"bottom\": \"none\",\n            \"left\": \"none\",\n            \"right\": \"none\",\n        },\n        thickness={\n            \"top\": 0,\n            \"bottom\": 0,\n            \"left\": 0,\n            \"right\": 0,\n        },\n    )\n    return Device(device_array=device_array, buffer_spec=buffer_spec, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_tidy3d","title":"<code>from_tidy3d(tidy3d_sim, eps, z, freq, buffer_width=0.1, **kwargs)</code>","text":"<p>Create a Device from a Tidy3D simulation.</p> <p>Parameters:</p> Name Type Description Default <code>tidy3d_sim</code> <code>Simulation</code> <p>The Tidy3D simulation object.</p> required <code>eps</code> <code>float</code> <p>The permittivity of the layer to extract from the simulation.</p> required <code>z</code> <code>float</code> <p>The z-coordinate of the layer to extract from the simulation.</p> required <code>freq</code> <code>float</code> <p>The frequency at which to extract the permittivity.</p> required <code>buffer_width</code> <code>float</code> <p>The width of the buffer region around the layer to extract from the simulation. Defaults to 0.1 \u00b5m. This is useful for ensuring the inputs/outputs of the simulation are not affected by prediction.</p> <code>0.1</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the permittivity cross-section at the specified z-coordinate for the Tidy3D simulation.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the tidy3d package is not installed.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_tidy3d(\n    tidy3d_sim: \"td.Simulation\",\n    eps: float,\n    z: float,\n    freq: float,\n    buffer_width: float = 0.1,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a Tidy3D simulation.\n\n    Parameters\n    ----------\n    tidy3d_sim : tidy3d.Simulation\n        The Tidy3D simulation object.\n    eps : float\n        The permittivity of the layer to extract from the simulation.\n    z : float\n        The z-coordinate of the layer to extract from the simulation.\n    freq : float\n        The frequency at which to extract the permittivity.\n    buffer_width : float\n        The width of the buffer region around the layer to extract from the\n        simulation. Defaults to 0.1 \u00b5m. This is useful for ensuring the inputs/outputs\n        of the simulation are not affected by prediction.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the permittivity cross-section at the specified\n        z-coordinate for the Tidy3D simulation.\n\n    Raises\n    ------\n    ImportError\n        If the tidy3d package is not installed.\n    \"\"\"\n    try:\n        from tidy3d import Coords, Grid\n    except ImportError:\n        raise ImportError(\n            \"The tidy3d package is required to use this function; \"\n            \"try `pip install tidy3d`.\"\n        ) from None\n\n    X = np.arange(\n        tidy3d_sim.bounds[0][0] - buffer_width,\n        tidy3d_sim.bounds[1][0] + buffer_width,\n        0.001,\n    )\n    Y = np.arange(\n        tidy3d_sim.bounds[0][1] - buffer_width,\n        tidy3d_sim.bounds[1][1] + buffer_width,\n        0.001,\n    )\n    Z = np.array([z])\n\n    grid = Grid(attrs={}, boundaries=Coords(attrs={}, x=X, y=Y, z=Z))\n    eps_array = np.real(\n        tidy3d_sim.epsilon_on_grid(grid=grid, coord_key=\"boundaries\", freq=freq).values\n    )\n    device_array = geometry.binarize_hard(device_array=eps_array, eta=eps - 0.1)[\n        :, :, 0\n    ]\n    device_array = np.rot90(device_array, k=1)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.get_sem_resolution","title":"<code>get_sem_resolution(sem_path, sem_resolution_key)</code>","text":"<p>Extracts the resolution of a scanning electron microscope (SEM) image from its metadata.</p> Notes <p>This function is used internally and may not be useful for most users.</p> <p>Parameters:</p> Name Type Description Default <code>sem_path</code> <code>str</code> <p>The file path to the SEM image.</p> required <code>sem_resolution_key</code> <code>str</code> <p>The key to look for in the SEM image metadata to extract the resolution.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the SEM image in nanometers per pixel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the resolution key is not found in the SEM image metadata.</p> Source code in <code>prefab/read.py</code> <pre><code>def get_sem_resolution(sem_path: str, sem_resolution_key: str) -&gt; float:\n    \"\"\"\n    Extracts the resolution of a scanning electron microscope (SEM) image from its\n    metadata.\n\n    Notes\n    -----\n    This function is used internally and may not be useful for most users.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution_key : str\n        The key to look for in the SEM image metadata to extract the resolution.\n\n    Returns\n    -------\n    float\n        The resolution of the SEM image in nanometers per pixel.\n\n    Raises\n    ------\n    ValueError\n        If the resolution key is not found in the SEM image metadata.\n    \"\"\"\n    with open(sem_path, \"rb\") as file:\n        resolution_key_bytes = sem_resolution_key.encode(\"utf-8\")\n        for line in file:\n            if resolution_key_bytes in line:\n                line_str = line.decode(\"utf-8\")\n                match = re.search(r\"-?\\d+(\\.\\d+)?\", line_str)\n                if match:\n                    value = float(match.group())\n                    if value &gt; 100:\n                        value /= 1000\n                    return value\n    raise ValueError(f\"Resolution key '{sem_resolution_key}' not found in {sem_path}.\")\n</code></pre>"},{"location":"reference/shapes/","title":"Shapes","text":"<p>Contains functions for creating various shapes as Device objects.</p>"},{"location":"reference/shapes/#prefab.shapes.cross","title":"<code>cross(width=200, height=None, arm_width=60, **kwargs)</code>","text":"<p>Create a Device object with a cross shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the cross. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The overall height of the cross. Defaults to the value of width.</p> <code>None</code> <code>arm_width</code> <code>int</code> <p>The width of the cross arms. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the cross shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def cross(\n    width: int = 200, height: Optional[int] = None, arm_width: int = 60, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a cross shape.\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the cross. Defaults to 200.\n    height : Optional[int]\n        The overall height of the cross. Defaults to the value of width.\n    arm_width : int\n        The width of the cross arms. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the cross shape.\n    \"\"\"\n    if height is None:\n        height = width\n    cross = np.zeros((height, width))\n    center_x = width // 2\n    center_y = height // 2\n    half_arm_width = arm_width // 2\n    cross[center_y - half_arm_width : center_y + half_arm_width + 1, :] = 1\n    cross[:, center_x - half_arm_width : center_x + half_arm_width + 1] = 1\n    return Device(device_array=cross, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disk","title":"<code>disk(width=200, height=None, **kwargs)</code>","text":"<p>Create a Device object with an elliptical shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the ellipse. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The height of the ellipse. Defaults to the value of width.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the elliptical shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disk(width: int = 200, height: Optional[int] = None, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with an elliptical shape.\n\n    Parameters\n    ----------\n    width : int\n        The width of the ellipse. Defaults to 200.\n    height : Optional[int]\n        The height of the ellipse. Defaults to the value of width.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the elliptical shape.\n    \"\"\"\n    if height is None:\n        height = width\n    radius_x = width // 2\n    radius_y = height // 2\n    y, x = np.ogrid[-radius_y:radius_y, -radius_x:radius_x]\n    mask = (x**2 / radius_x**2) + (y**2 / radius_y**2) &lt;= 1\n    ellipse = np.zeros((height, width))\n    ellipse[mask] = 1\n    return Device(device_array=ellipse, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disk_wavy","title":"<code>disk_wavy(width=200, wave_amplitude=10, wave_frequency=10, **kwargs)</code>","text":"<p>Create a Device object with a circular shape with wavy edges.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the wavy circle. Defaults to 200.</p> <code>200</code> <code>wave_amplitude</code> <code>float</code> <p>The amplitude of the waves. Defaults to 10.</p> <code>10</code> <code>wave_frequency</code> <code>float</code> <p>The frequency of the waves. Defaults to 10.</p> <code>10</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the wavy circular shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disk_wavy(\n    width: int = 200, wave_amplitude: float = 10, wave_frequency: float = 10, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a circular shape with wavy edges.\n\n    Parameters\n    ----------\n    width : int\n        The overall width and height of the wavy circle. Defaults to 200.\n    wave_amplitude : float\n        The amplitude of the waves. Defaults to 10.\n    wave_frequency : float\n        The frequency of the waves. Defaults to 10.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the wavy circular shape.\n    \"\"\"\n    effective_radius = (width // 2) - wave_amplitude\n    y, x = np.ogrid[-width // 2 : width // 2, -width // 2 : width // 2]\n    distance_from_center = np.sqrt(x**2 + y**2)\n    sinusoidal_boundary = effective_radius + wave_amplitude * np.sin(\n        wave_frequency * np.arctan2(y, x)\n    )\n    mask = distance_from_center &lt;= sinusoidal_boundary\n    circle_wavy = np.zeros((width, width))\n    circle_wavy[mask] = 1\n    return Device(device_array=circle_wavy, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disks","title":"<code>disks(rows=5, cols=5, disk_radius=30, spacing=60, **kwargs)</code>","text":"<p>Create a Device object with a grid of uniform disks.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>disk_radius</code> <code>int</code> <p>The radius of each disk. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between disk centers. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of disks.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disks(\n    rows: int = 5, cols: int = 5, disk_radius: int = 30, spacing: int = 60, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of uniform disks.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    disk_radius : int\n        The radius of each disk. Defaults to 30.\n    spacing : int\n        The spacing between disk centers. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of disks.\n    \"\"\"\n    grid_height = rows * (2 * disk_radius + spacing) - spacing\n    grid_width = cols * (2 * disk_radius + spacing) - spacing\n    disks = np.zeros((grid_height, grid_width))\n    y, x = np.ogrid[-disk_radius:disk_radius, -disk_radius:disk_radius]\n    mask = x**2 + y**2 &lt;= disk_radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * disk_radius + spacing) + disk_radius\n            center_x = col * (2 * disk_radius + spacing) + disk_radius\n            disks[\n                center_y - disk_radius : center_y + disk_radius,\n                center_x - disk_radius : center_x + disk_radius,\n            ][mask] = 1\n    return Device(device_array=disks, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disks_offset","title":"<code>disks_offset(rows=5, cols=5, disk_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with an offset grid of disks.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>disk_radius</code> <code>int</code> <p>The radius of each disk. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between disk centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing an offset grid of disks.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disks_offset(\n    rows: int = 5, cols: int = 5, disk_radius: int = 30, spacing: int = 30, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grid of disks.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    disk_radius : int\n        The radius of each disk. Defaults to 30.\n    spacing : int\n        The spacing between disk centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing an offset grid of disks.\n    \"\"\"\n    grid_height = rows * (2 * disk_radius + spacing) - spacing\n    grid_width = (\n        cols * (2 * disk_radius + spacing) - spacing + (disk_radius + spacing // 2)\n    )\n    disks_offset = np.zeros((grid_height, grid_width))\n    y, x = np.ogrid[-disk_radius:disk_radius, -disk_radius:disk_radius]\n    mask = x**2 + y**2 &lt;= disk_radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * disk_radius + spacing) + disk_radius\n            center_x = (\n                col * (2 * disk_radius + spacing)\n                + disk_radius\n                + (disk_radius + spacing // 2 if row % 2 == 1 else 0)\n            )\n            disks_offset[\n                center_y - disk_radius : center_y + disk_radius,\n                center_x - disk_radius : center_x + disk_radius,\n            ][mask] = 1\n    return Device(device_array=disks_offset, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disks_varying","title":"<code>disks_varying(rows=5, cols=5, min_disk_radius=10, max_disk_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of disks with varying radii.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>min_disk_radius</code> <code>int</code> <p>The minimum radius of the disks. Defaults to 10.</p> <code>10</code> <code>max_disk_radius</code> <code>int</code> <p>The maximum radius of the disks. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between disk centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of disks with varying radii.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disks_varying(\n    rows: int = 5,\n    cols: int = 5,\n    min_disk_radius: int = 10,\n    max_disk_radius: int = 30,\n    spacing: int = 30,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of disks with varying radii.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    min_disk_radius : int\n        The minimum radius of the disks. Defaults to 10.\n    max_disk_radius : int\n        The maximum radius of the disks. Defaults to 30.\n    spacing : int\n        The spacing between disk centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of disks with varying radii.\n    \"\"\"\n    grid_height = rows * (2 * max_disk_radius + spacing) - spacing\n    grid_width = cols * (2 * max_disk_radius + spacing) - spacing\n    disks_varying = np.zeros((grid_height, grid_width))\n    radius_range = np.linspace(min_disk_radius, max_disk_radius, rows * cols).reshape(\n        rows, cols\n    )\n    for row in range(rows):\n        for col in range(cols):\n            disk_radius = int(radius_range[row, col])\n            y, x = np.ogrid[-disk_radius:disk_radius, -disk_radius:disk_radius]\n            mask = x**2 + y**2 &lt;= disk_radius**2\n            center_y = row * (2 * max_disk_radius + spacing) + max_disk_radius\n            center_x = col * (2 * max_disk_radius + spacing) + max_disk_radius\n            disks_varying[\n                center_y - disk_radius : center_y + disk_radius,\n                center_x - disk_radius : center_x + disk_radius,\n            ][mask] = 1\n    return Device(device_array=disks_varying, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.grating","title":"<code>grating(height=200, pitch=120, duty_cycle=0.5, num_gratings=3, **kwargs)</code>","text":"<p>Create a Device object with a grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height of the grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the grating. Defaults to 120.</p> <code>120</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the grating. Defaults to 0.5.</p> <code>0.5</code> <code>num_gratings</code> <code>int</code> <p>The number of grating periods. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def grating(\n    height: int = 200,\n    pitch: int = 120,\n    duty_cycle: float = 0.5,\n    num_gratings: int = 3,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grating pattern.\n\n    Parameters\n    ----------\n    height : int\n        The height of the grating. Defaults to 200.\n    pitch : int\n        The pitch (period) of the grating. Defaults to 120.\n    duty_cycle : float\n        The duty cycle of the grating. Defaults to 0.5.\n    num_gratings : int\n        The number of grating periods. Defaults to 3.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the grating pattern.\n    \"\"\"\n    width = pitch * num_gratings - pitch // 2\n    grating = np.zeros((height, width))\n    grating_width = int(pitch * duty_cycle)\n    for i in range(num_gratings):\n        start = i * pitch\n        grating[:, start : start + grating_width] = 1\n    return Device(device_array=grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes","title":"<code>holes(rows=5, cols=5, hole_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of uniform circular holes.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>hole_radius</code> <code>int</code> <p>The radius of each hole. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circular holes.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes(\n    rows: int = 5, cols: int = 5, hole_radius: int = 30, spacing: int = 30, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of uniform circular holes.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    hole_radius : int\n        The radius of each hole. Defaults to 30.\n    spacing : int\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circular holes.\n    \"\"\"\n    grid_height = rows * (2 * hole_radius + spacing) - spacing\n    grid_width = cols * (2 * hole_radius + spacing) - spacing\n    holes = np.ones((grid_height, grid_width))\n    y, x = np.ogrid[-hole_radius:hole_radius, -hole_radius:hole_radius]\n    mask = x**2 + y**2 &lt;= hole_radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * hole_radius + spacing) + hole_radius\n            center_x = col * (2 * hole_radius + spacing) + hole_radius\n            holes[\n                center_y - hole_radius : center_y + hole_radius,\n                center_x - hole_radius : center_x + hole_radius,\n            ][mask] = 0\n    return Device(device_array=holes, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes_offset","title":"<code>holes_offset(rows=5, cols=5, hole_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with an offset grid of circular holes.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>hole_radius</code> <code>int</code> <p>The radius of each hole. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing an offset grid of circular holes.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes_offset(\n    rows: int = 5, cols: int = 5, hole_radius: int = 30, spacing: int = 30, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grid of circular holes.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    hole_radius : int\n        The radius of each hole. Defaults to 30.\n    spacing : int\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing an offset grid of circular holes.\n    \"\"\"\n    grid_height = rows * (2 * hole_radius + spacing) - spacing\n    grid_width = (\n        cols * (2 * hole_radius + spacing) - spacing + (hole_radius + spacing // 2)\n    )\n    holes_offset = np.ones((grid_height, grid_width))\n    y, x = np.ogrid[-hole_radius:hole_radius, -hole_radius:hole_radius]\n    mask = x**2 + y**2 &lt;= hole_radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * hole_radius + spacing) + hole_radius\n            center_x = (\n                col * (2 * hole_radius + spacing)\n                + hole_radius\n                + (hole_radius + spacing // 2 if row % 2 == 1 else 0)\n            )\n            holes_offset[\n                center_y - hole_radius : center_y + hole_radius,\n                center_x - hole_radius : center_x + hole_radius,\n            ][mask] = 0\n    return Device(device_array=holes_offset, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes_varying","title":"<code>holes_varying(rows=5, cols=5, min_hole_radius=10, max_hole_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of circular holes with varying radii.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>min_hole_radius</code> <code>int</code> <p>The minimum radius of the holes. Defaults to 10.</p> <code>10</code> <code>max_hole_radius</code> <code>int</code> <p>The maximum radius of the holes. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circular holes with varying radii.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes_varying(\n    rows: int = 5,\n    cols: int = 5,\n    min_hole_radius: int = 10,\n    max_hole_radius: int = 30,\n    spacing: int = 30,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of circular holes with varying radii.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    min_hole_radius : int\n        The minimum radius of the holes. Defaults to 10.\n    max_hole_radius : int\n        The maximum radius of the holes. Defaults to 30.\n    spacing : int\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circular holes with varying radii.\n    \"\"\"\n    grid_height = rows * (2 * max_hole_radius + spacing) - spacing\n    grid_width = cols * (2 * max_hole_radius + spacing) - spacing\n    holes_varying = np.ones((grid_height, grid_width))\n    radius_range = np.linspace(min_hole_radius, max_hole_radius, rows * cols).reshape(\n        rows, cols\n    )\n    for row in range(rows):\n        for col in range(cols):\n            hole_radius = int(radius_range[row, col])\n            y, x = np.ogrid[-hole_radius:hole_radius, -hole_radius:hole_radius]\n            mask = x**2 + y**2 &lt;= hole_radius**2\n            center_y = row * (2 * max_hole_radius + spacing) + max_hole_radius\n            center_x = col * (2 * max_hole_radius + spacing) + max_hole_radius\n            holes_varying[\n                center_y - hole_radius : center_y + hole_radius,\n                center_x - hole_radius : center_x + hole_radius,\n            ][mask] = 0\n    return Device(device_array=holes_varying, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.l_grating","title":"<code>l_grating(width=200, height=None, pitch=100, duty_cycle=0.5, **kwargs)</code>","text":"<p>Create a Device object with an L-shaped grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the L-grating. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The height of the L-grating. Defaults to the value of width.</p> <code>None</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the L-shapes. Defaults to 100.</p> <code>100</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the L-shapes. Defaults to 0.5.</p> <code>0.5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the L-shaped grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def l_grating(\n    width: int = 200,\n    height: Optional[int] = None,\n    pitch: int = 100,\n    duty_cycle: float = 0.5,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an L-shaped grating pattern.\n\n    Parameters\n    ----------\n    width : int\n        The width of the L-grating. Defaults to 200.\n    height : Optional[int]\n        The height of the L-grating. Defaults to the value of width.\n    pitch : int\n        The pitch (period) of the L-shapes. Defaults to 100.\n    duty_cycle : float\n        The duty cycle of the L-shapes. Defaults to 0.5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the L-shaped grating pattern.\n    \"\"\"\n    if height is None:\n        height = width\n    L_grating = np.zeros((height, width))\n    num_L_shapes = min(height, width) // pitch\n    L_width = int(pitch * duty_cycle)\n    for i in range(num_L_shapes):\n        start = i * pitch\n        L_grating[start : start + L_width, start:] = 1\n        L_grating[start:, start : start + L_width] = 1\n    return Device(device_array=L_grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.offset_grating","title":"<code>offset_grating(height=200, pitch=120, duty_cycle=0.5, num_gratings=3, **kwargs)</code>","text":"<p>Create a Device object with an offset grating pattern (alternating rows).</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height of the grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the grating. Defaults to 120.</p> <code>120</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the grating. Defaults to 0.5.</p> <code>0.5</code> <code>num_gratings</code> <code>int</code> <p>The number of grating periods. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the offset grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def offset_grating(\n    height: int = 200,\n    pitch: int = 120,\n    duty_cycle: float = 0.5,\n    num_gratings: int = 3,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grating pattern (alternating rows).\n\n    Parameters\n    ----------\n    height : int\n        The height of the grating. Defaults to 200.\n    pitch : int\n        The pitch (period) of the grating. Defaults to 120.\n    duty_cycle : float\n        The duty cycle of the grating. Defaults to 0.5.\n    num_gratings : int\n        The number of grating periods. Defaults to 3.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the offset grating pattern.\n    \"\"\"\n    width = pitch * num_gratings\n    grating = np.zeros((height, width))\n    grating_width = int(pitch * duty_cycle)\n    half_height = height // 2\n    for i in range(num_gratings):\n        start = i * pitch\n        grating[half_height:, start : start + grating_width] = 1\n    for i in range(num_gratings):\n        start = i * pitch + pitch // 2\n        grating[:half_height, start : start + grating_width] = 1\n    return Device(device_array=grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.pie","title":"<code>pie(width=200, height=None, arc_angle=270, **kwargs)</code>","text":"<p>Create a Device object with a pie shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the pie. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The height of the pie. Defaults to the value of width.</p> <code>None</code> <code>arc_angle</code> <code>float</code> <p>The angle of the pie slice in degrees. Defaults to 270.</p> <code>270</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the pie shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def pie(\n    width: int = 200, height: Optional[int] = None, arc_angle: float = 270, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a pie shape.\n\n    Parameters\n    ----------\n    width : int\n        The width of the pie. Defaults to 200.\n    height : Optional[int]\n        The height of the pie. Defaults to the value of width.\n    arc_angle : float\n        The angle of the pie slice in degrees. Defaults to 270.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the pie shape.\n    \"\"\"\n    if height is None:\n        height = width\n    radius_x = width // 2\n    radius_y = height // 2\n    y, x = np.ogrid[-radius_y:radius_y, -radius_x:radius_x]\n    angle = np.arctan2(y, x) * 180 / np.pi\n    angle = (angle + 360) % 360\n    mask = (x**2 / radius_x**2 + y**2 / radius_y**2 &lt;= 1) &amp; (angle &lt;= arc_angle)\n    pie = np.zeros((height, width))\n    pie[mask] = 1\n    return Device(device_array=pie, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.poly","title":"<code>poly(width=200, num_points=5, **kwargs)</code>","text":"<p>Create a Device object with a regular polygon shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the polygon. Defaults to 200.</p> <code>200</code> <code>num_points</code> <code>int</code> <p>The number of sides of the polygon. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the regular polygon shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def poly(width: int = 200, num_points: int = 5, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a regular polygon shape.\n\n    Parameters\n    ----------\n    width : int\n        The overall width and height of the polygon. Defaults to 200.\n    num_points : int\n        The number of sides of the polygon. Defaults to 5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the regular polygon shape.\n    \"\"\"\n    radius = width // 2\n    angles = np.linspace(0, 2 * np.pi, num_points, endpoint=False) - np.pi / 2\n    x = (radius * np.cos(angles) + radius).astype(int)\n    y = (radius * np.sin(angles) + radius).astype(int)\n    poly = np.zeros((width, width))\n    rr, cc = polygon(y, x)\n    rr = np.clip(rr, 0, width - 1)\n    cc = np.clip(cc, 0, width - 1)\n    poly[rr, cc] = 1\n    return Device(device_array=poly, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.radial_grating","title":"<code>radial_grating(width=200, grating_skew=0, num_gratings=6, **kwargs)</code>","text":"<p>Create a Device object with a radial grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the radial grating. Defaults to 200.</p> <code>200</code> <code>grating_skew</code> <code>int</code> <p>The skew angle of the grating arms. Defaults to 0.</p> <code>0</code> <code>num_gratings</code> <code>int</code> <p>The number of grating arms. Defaults to 6.</p> <code>6</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the radial grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def radial_grating(\n    width: int = 200, grating_skew: int = 0, num_gratings: int = 6, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a radial grating pattern.\n\n    Parameters\n    ----------\n    width : int\n        The overall width and height of the radial grating. Defaults to 200.\n    grating_skew : int\n        The skew angle of the grating arms. Defaults to 0.\n    num_gratings : int\n        The number of grating arms. Defaults to 6.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the radial grating pattern.\n    \"\"\"\n    radial_grating = np.zeros((width, width))\n    center = width // 2\n    radius = center\n    theta = np.linspace(0, 2 * np.pi, num_gratings, endpoint=False)\n    for angle in theta:\n        x0, y0 = center, center\n        x1 = int(center + radius * np.cos(angle))\n        y1 = int(center + radius * np.sin(angle))\n        x2 = int(\n            center + (radius - grating_skew) * np.cos(angle + np.pi / num_gratings)\n        )\n        y2 = int(\n            center + (radius - grating_skew) * np.sin(angle + np.pi / num_gratings)\n        )\n        rr, cc = polygon([y0, y1, y2], [x0, x1, x2])\n        rr = np.clip(rr, 0, width - 1)\n        cc = np.clip(cc, 0, width - 1)\n        radial_grating[rr, cc] = 1\n    return Device(device_array=radial_grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.rectangle","title":"<code>rectangle(width=200, height=None, **kwargs)</code>","text":"<p>Create a Device object with a rectangular shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the rectangle. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The height of the rectangle. Defaults to the value of width if None.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the rectangular shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def rectangle(width: int = 200, height: Optional[int] = None, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a rectangular shape.\n\n    Parameters\n    ----------\n    width : int\n        The width of the rectangle. Defaults to 200.\n    height : Optional[int]\n        The height of the rectangle. Defaults to the value of width if None.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the rectangular shape.\n    \"\"\"\n    if height is None:\n        height = width\n    rectangle = np.ones((height, width))\n    return Device(device_array=rectangle, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.ring","title":"<code>ring(width=200, height=None, border_width=60, **kwargs)</code>","text":"<p>Create a Device object with a ring shape (hollow ellipse).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the ring. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The overall height of the ring. Defaults to the value of width.</p> <code>None</code> <code>border_width</code> <code>int</code> <p>The width of the ring border. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the ring shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def ring(\n    width: int = 200, height: Optional[int] = None, border_width: int = 60, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a ring shape (hollow ellipse).\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the ring. Defaults to 200.\n    height : Optional[int]\n        The overall height of the ring. Defaults to the value of width.\n    border_width : int\n        The width of the ring border. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the ring shape.\n    \"\"\"\n    if height is None:\n        height = width\n    radius_x = width // 2\n    radius_y = height // 2\n    inner_radius_x = radius_x - border_width\n    inner_radius_y = radius_y - border_width\n    y, x = np.ogrid[-radius_y:radius_y, -radius_x:radius_x]\n    outer_mask = x**2 / radius_x**2 + y**2 / radius_y**2 &lt;= 1\n    inner_mask = x**2 / inner_radius_x**2 + y**2 / inner_radius_y**2 &lt;= 1\n    ring = np.zeros((height, width))\n    ring[outer_mask &amp; ~inner_mask] = 1\n    return Device(device_array=ring, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.star","title":"<code>star(width=200, num_points=5, **kwargs)</code>","text":"<p>Create a Device object with a star shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the star. Defaults to 200.</p> <code>200</code> <code>num_points</code> <code>int</code> <p>The number of points on the star. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the star shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def star(width: int = 200, num_points: int = 5, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a star shape.\n\n    Parameters\n    ----------\n    width : int\n        The overall width and height of the star. Defaults to 200.\n    num_points : int\n        The number of points on the star. Defaults to 5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the star shape.\n    \"\"\"\n    radius_outer = width // 2\n    radius_inner = radius_outer // 2\n    angles_outer = np.linspace(0, 2 * np.pi, num_points, endpoint=False) - np.pi / 2\n    angles_inner = angles_outer + np.pi / num_points\n    x_outer = (radius_outer * np.cos(angles_outer) + radius_outer).astype(int)\n    y_outer = (radius_outer * np.sin(angles_outer) + radius_outer).astype(int)\n    x_inner = (radius_inner * np.cos(angles_inner) + radius_outer).astype(int)\n    y_inner = (radius_inner * np.sin(angles_inner) + radius_outer).astype(int)\n    x = np.empty(2 * num_points, dtype=int)\n    y = np.empty(2 * num_points, dtype=int)\n    x[0::2] = x_outer\n    x[1::2] = x_inner\n    y[0::2] = y_outer\n    y[1::2] = y_inner\n    star = np.zeros((width, width))\n    rr, cc = polygon(y, x)\n    rr = np.clip(rr, 0, width - 1)\n    cc = np.clip(cc, 0, width - 1)\n    star[rr, cc] = 1\n    return Device(device_array=star, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.target","title":"<code>target(width=200, height=None, arm_width=60, **kwargs)</code>","text":"<p>Create a Device object with a target shape (cross with center removed).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the target. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The overall height of the target. Defaults to the value of width.</p> <code>None</code> <code>arm_width</code> <code>int</code> <p>The width of the target arms. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the target shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def target(\n    width: int = 200, height: Optional[int] = None, arm_width: int = 60, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a target shape (cross with center removed).\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the target. Defaults to 200.\n    height : Optional[int]\n        The overall height of the target. Defaults to the value of width.\n    arm_width : int\n        The width of the target arms. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the target shape.\n    \"\"\"\n    if height is None:\n        height = width\n    target = np.zeros((height, width))\n    center_x = width // 2\n    center_y = height // 2\n    half_arm_width = arm_width // 2\n    target[center_y - half_arm_width : center_y + half_arm_width + 1, :] = 1\n    target[:, center_x - half_arm_width : center_x + half_arm_width + 1] = 1\n    target[\n        center_y - half_arm_width : center_y + half_arm_width + 1,\n        center_x - half_arm_width : center_x + half_arm_width + 1,\n    ] = 0\n    return Device(device_array=target, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.window","title":"<code>window(width=200, height=None, border_width=60, **kwargs)</code>","text":"<p>Create a Device object with a window shape (hollow rectangle).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the window. Defaults to 200.</p> <code>200</code> <code>height</code> <code>Optional[int]</code> <p>The overall height of the window. Defaults to the value of width.</p> <code>None</code> <code>border_width</code> <code>int</code> <p>The width of the window border. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the window shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def window(\n    width: int = 200, height: Optional[int] = None, border_width: int = 60, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a window shape (hollow rectangle).\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the window. Defaults to 200.\n    height : Optional[int]\n        The overall height of the window. Defaults to the value of width.\n    border_width : int\n        The width of the window border. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the window shape.\n    \"\"\"\n    if height is None:\n        height = width\n    window = np.zeros((height, width))\n    window[:border_width, :] = 1\n    window[-border_width:, :] = 1\n    window[:, :border_width] = 1\n    window[:, -border_width:] = 1\n    return Device(device_array=window, **kwargs)\n</code></pre>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}