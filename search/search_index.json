{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Most photonic designs fail on the first fab run. PreFab eliminates costly design-fabrication iteration cycles by predicting manufacturing outcomes before tape-out. Using foundry-accurate models trained on real fabrication data, PreFab captures how lithography, etching, and process variations transform your designs during manufacturing.</p>"},{"location":"#prediction","title":"Prediction","text":"<p>Simulate exactly how your designs will fabricate. PreFab predicts the structural variations that matter: corner rounding, feature erosion, gap filling, sidewall angles, and stochastic effects. Compare ideal versus fabricated performance before committing to manufacturing.</p> <p></p>"},{"location":"#correction","title":"Correction","text":"<p>Pre-compensate designs to counteract known fabrication effects. PreFab's correction models automatically adjust layouts so fabricated structures match your target specifications, recovering performance lost to manufacturing variations.</p> <p></p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Quick links</p> <ol> <li>Setup guide 2. Learn about fabrication-aware design 3. Explore example notebooks</li> </ol> <p>Try Rosette (beta)</p> <p>Want a more visual experience? Try the Rosette beta - our new layout tool with PreFab built in, designed for rapid chip design.</p>"},{"location":"#get-in-touch","title":"Get in touch","text":"<p>PreFab is continuously evolving to serve the photonics community. Reach out to discuss support for your fabrication process, report issues on GitHub, or follow updates on LinkedIn.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#160-2026-02-04","title":"1.6.0 - 2026-02-04","text":"<ul> <li>Fixed VJP upstream gradient encoding to use full float32 precision instead of 8-bit PNG.</li> <li>Small gradient values (&lt; 0.004) are no longer quantized to zero.</li> <li>Large gradient values (&gt; 1.0) no longer overflow.</li> <li>Users no longer need to manually scale gradients for VJP computation.</li> <li>VJP gradient shape now matches input device array shape.</li> <li>Added <code>predict.differentiable(model)</code> for cleaner autograd integration without tuple unpacking.</li> </ul>"},{"location":"CHANGELOG/#150-2025-12-31","title":"1.5.0 - 2025-12-31","text":"<ul> <li>Added <code>predict.predict_array_diff</code> for differentiable fab prediction with exact gradient computation via server-side VJP.</li> <li>Replaced approximate diagonal Jacobian gradients with exact gradients computed through CNN backpropagation.</li> <li>Cleaned up endpoint configuration in <code>predict</code> module.</li> <li>Updated auth setup welcome message.</li> </ul>"},{"location":"CHANGELOG/#142-2025-12-08","title":"1.4.2 - 2025-12-08","text":"<ul> <li>Added ability to authenticate using an API key. See <code>docs/setup.md</code> for more information.</li> </ul>"},{"location":"CHANGELOG/#141-2025-11-27","title":"1.4.1 - 2025-11-27","text":"<ul> <li>Change to the <code>models.py</code> module to allow easy expandability (for custom/future models).</li> </ul>"},{"location":"CHANGELOG/#140-2025-11-11","title":"1.4.0 - 2025-11-11","text":"<ul> <li>Migrated to uv for dependency management.</li> <li>Removing unused dependencies.</li> <li>Removing many unused functions throughout multiple modules.</li> <li>Fixing many type issues throughout multiple modules.</li> <li>Rename <code>binarize_monte_carlo</code> to <code>binarize_with_roughness</code>.</li> <li>Updating and cleaning up documentation.</li> </ul>"},{"location":"CHANGELOG/#130-2025-07-15","title":"1.3.0 - 2025-07-15","text":"<ul> <li>Many changes on the server-side to significantly improve performance and accuracy. Some client-side changes to the prediction functions in <code>prefab.predict</code> to handle the updated server-side changes.</li> <li>Added <code>predict.predict_gds</code> to predict directly on a GDS file.</li> <li>Add small amount of clipping to binarization with roughness to avoid artifacts.</li> </ul>"},{"location":"CHANGELOG/#120-2025-03-19","title":"1.2.0 - 2025-03-19","text":"<ul> <li>Added <code>Device.segment</code> method to segment an SEM image into a binary mask. Some more testing to be done.</li> <li>Added <code>predict.predict_gdstk</code> to predict directly on a <code>gdstk.Cell</code>. This is useful for predicting very large devices that won't fit into memory.</li> </ul>"},{"location":"CHANGELOG/#119-2025-01-22","title":"1.1.9 - 2025-01-22","text":"<ul> <li>Fix cropping issue with <code>device.to_ndarray</code>.</li> <li>Add example of sidewall angle simulation and correction to docs.</li> </ul>"},{"location":"CHANGELOG/#118-2025-01-16","title":"1.1.8 - 2025-01-16","text":"<ul> <li>Added <code>prefab</code> command to the <code>pyproject.toml</code> file so that <code>prefab</code> can be run from the command line (e.g., <code>prefab setup</code>).</li> <li>Change to callback address for successful authentication.</li> </ul>"},{"location":"CHANGELOG/#117-2025-01-14","title":"1.1.7 - 2025-01-14","text":"<ul> <li>Added <code>autograd</code> and <code>pydantic</code> (version requirement) dependencies in <code>pyproject.toml</code>.</li> <li>Server-side improvements (update endpoint version number to 2).</li> </ul>"},{"location":"CHANGELOG/#116-2024-12-30","title":"1.1.6 - 2024-12-30","text":"<ul> <li>Added Tidy3D fabrication-aware inverse design (FAID) example notebook.</li> <li>Remove buffer from <code>Device</code> created with <code>read.from_sem</code> method.</li> <li>Handling of extended bounds in <code>read.from_sem</code> method.</li> <li>Use OpenCV for morphological operations in <code>geometry.enforce_feature_size</code>.</li> <li>Add handling for <code>None</code> casee for <code>BufferSpec</code> in <code>Device</code> constructor.</li> </ul>"},{"location":"CHANGELOG/#115-2024-11-05","title":"1.1.5 - 2024-11-05","text":"<ul> <li>Fix alignment issue in <code>Device._device_to_gdstk</code> method, which is used in <code>Device.to_gdstk</code> and <code>Device.to_gds</code>.</li> <li>Minor linting fixes.</li> </ul>"},{"location":"CHANGELOG/#114-2024-11-01","title":"1.1.4 - 2024-11-01","text":"<ul> <li>Added custom vector-Jacobian product (VJP) for the <code>predict.predict_array_with_grad</code> function.</li> <li>Changed some of the docstrings in <code>prefab.predict</code> to be more consistent and clear.</li> </ul>"},{"location":"CHANGELOG/#113-2024-10-26","title":"1.1.3 - 2024-10-26","text":"<ul> <li>Moved prediction logic to <code>prefab.predict</code> module.</li> <li>First version of <code>predict.predict_array_with_grad</code>, which returns both the predicted array and its gradient. This is useful to fabrication-aware inverse design (FAID). More to come.</li> <li>Added <code>origin</code> parameter to GDS-related export methods.</li> <li>Small docstring fixes.</li> </ul>"},{"location":"CHANGELOG/#112-2024-10-10","title":"1.1.2 - 2024-10-10","text":"<ul> <li>User warning if <code>compare.intersection_over_union</code>, <code>compare.hamming_distance</code>, or <code>compare.dice_coefficient</code> are called with non-binarized devices.</li> <li>Added <code>height</code> parameter to many shape constructors in <code>prefab.shapes</code> to give more flexibility.</li> <li>Updates to the <code>README.md</code> to keep current.</li> <li><code>Device.is_binary</code> is now a property.</li> <li>Moved <code>Device.enforce_feature_size</code> logic to <code>prefab.geometry</code> module.</li> <li>Added required version of <code>gdstk</code> to <code>pyproject.toml</code>.</li> <li>Removed leftover return statement in <code>geometry.rotate</code>.</li> </ul>"},{"location":"CHANGELOG/#111-2024-09-24","title":"1.1.1 - 2024-09-24","text":"<ul> <li>Manually adding small random noise to the \"SEMulated\" images to better match the real data. This is ideally included in the model training, but for now this is a quick fix.</li> <li>Added z-padding to the device array before exporting to STL with <code>Device.to_stl</code> to ensure that the exported device is closed.</li> <li>Removed buffer from <code>Device.device_array</code> before exporting to with <code>Device.to_gdsfactory</code>.</li> <li>The additions from <code>1.0.3</code> and <code>1.0.4</code> releases, which should be considered part of this release. Release planning a work in progress.</li> <li>Import and export from/to Tidy3D simulations with <code>Device.to_tidy3d</code> and <code>read.from_tidy3d</code>.</li> <li>Import and export from/to gdsfactory components with <code>Device.to_gdsfactory</code> and <code>read.from_gdsfactory</code>.</li> <li>Convert 2D device structures into 3D arrays or STL files with <code>Device.to_3d</code> and <code>Device.to_stl</code>. This is useful for simulating processes with angled sidewalls.</li> <li>Check and visualize the effect of enforcing a minimum feature size on the device geometry with <code>Device.check_feature_size</code> and <code>Device.enforce_feature_size</code>.</li> </ul>"},{"location":"CHANGELOG/#104-2024-09-19","title":"1.0.4 - 2024-09-19","text":"<ul> <li>Option to specify GPU or CPU in <code>predict</code>, <code>correct</code>, and <code>semulate</code> functions. GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</li> <li>Improve clarity of messaging for authentication errors.</li> </ul>"},{"location":"CHANGELOG/#103-2024-09-14","title":"1.0.3 - 2024-09-14","text":"<ul> <li>Added this <code>CHANGELOG.md</code> file.</li> <li>Added <code>prefab.shapes</code> module to replace the now removed <code>devices</code> directory. This module contains helpful device constructors for testing PreFab models on.</li> <li>Added <code>__version__</code> class attribute to <code>prefab</code> package.</li> <li>Added <code>ANT_NanoSOI_ANF1-d8</code> and <code>ANT_NanoSOI_ANF1-d10</code> models (see <code>prefab.models</code> and <code>docs/models.md</code>).</li> <li>Updated notebook examples to use <code>prefab.shapes</code> module and newest models.</li> <li>Updated dependencies in <code>pyproject.toml</code>.</li> <li>Simplified <code>.gitignore</code> and <code>.gitattributes</code> files.</li> <li>Docstring improvements to <code>prefab.compare</code> module.</li> <li>Ability to specify thickness to all four sides of buffer thickness in <code>prefab.device.BufferSpec</code>.</li> <li>Changed some of the array resizing logic in <code>prefab.read</code> module to be more robust.</li> <li>Minor fixes to <code>prefab.device</code> module.</li> <li>Minor fixes to <code>prefab.geometry</code> module.</li> <li>Removed <code>devices</code> directory from the repository. Effectively replaced with <code>prefab.shapes</code> module.</li> <li>Remove <code>requirements.txt</code> file as <code>pyproject.toml</code> contains all dependencies.</li> </ul>"},{"location":"fab_aware_design/","title":"Fab-aware design","text":"<p>The gap between designed and fabricated photonic circuits is well-known: corners round, features erode, and structures deviate from their ideal geometries. Traditional approaches handle this with conservative design margins, effectively trading performance headroom for fabrication tolerance.</p> <p>Fabrication-aware design offers a different approach. By predicting how designs will actually fabricate, you can verify performance before manufacturing, correct designs to compensate for known effects, or optimize directly for fabricated structures rather than idealized ones.</p> <p>Note</p> <p>While our general documentation focuses on planar geometric variations, the same principles extend to other critical fabrication effects. PreFab supports or is developing support for other effects such as sidewall angle, material thickness variations, and surface roughness - all of which significantly impact photonic device performance.</p>"},{"location":"fab_aware_design/#how-it-works","title":"How it works","text":"<p>PreFab provides trained prediction and correction models for various fabrication processes. These models have learned the relationship between designs and fabricated outcomes, enabling accurate predictions of how specific layouts will transform during manufacturing.</p> <p>The models work in two directions:</p> <p>Prediction: Design \u2192 Fabricated structure Correction: Desired structure \u2192 Design that fabricates correctly</p> <p>Reach out to us if you'd like support for your fabrication process.</p> <p>These models enable three complementary workflows:</p> <ol> <li>Design verification \u2014 Predict and validate before fabrication</li> <li>Design correction \u2014 Compensate for fabrication effects</li> <li>Fabrication-aware inverse design \u2014 Optimize for fabricated performance</li> </ol>"},{"location":"fab_aware_design/#design-verification","title":"Design verification","text":"<pre><code>flowchart LR\n    A[Device&lt;br&gt;Design] --&gt; B[Prediction&lt;br&gt;Model]\n    B --&gt; C[Predicted&lt;br&gt;Design]\n    C --&gt; D[EM&lt;br&gt;Simulation]\n    D --&gt; E[Compare&lt;br&gt;Results]\n    A --&gt; D\n    E -.-&gt; |Manual Design Iteration| A\n    style B stroke:#4ade80,stroke-width:2px\n    style D stroke:#fbbf24,stroke-width:2px</code></pre> <p>Design verification uses prediction models to assess how fabrication will affect device performance before committing to manufacturing.</p> <p>For a simplified example, see our prediction notebook.</p> <p>The workflow is straightforward: run your design through the prediction model to generate the expected fabricated structure, then simulate both the ideal and predicted geometries. Comparing the results reveals whether fabrication effects will significantly impact your performance targets.</p> <p>This is particularly valuable for complex devices or those pushing fabrication limits. Rather than relying on intuition or design rules alone, you can make data-driven decisions about whether to proceed with fabrication, iterate the design, or apply corrections.</p>"},{"location":"fab_aware_design/#stochastic-effects-and-yield-analysis","title":"Stochastic effects and yield analysis","text":"<p>Because our models are trained on real fabrication data with natural process variations, they capture stochastic effects inherent to manufacturing. This enables a more sophisticated form of verification: running multiple predictions on the same design to simulate different fabrication outcomes.</p> <p>By generating and simulating many possible fabricated versions of a single design, you can assess performance variability and estimate yield. This is especially valuable for understanding how sensitive a design is to process variations\u2014a critical consideration for production-scale deployment where manufacturing tolerances directly impact device yield and cost.</p>"},{"location":"fab_aware_design/#design-correction","title":"Design correction","text":"<pre><code>flowchart LR\n    A[Device&lt;br&gt;Design] --&gt; B[Correction&lt;br&gt;Model]\n    B --&gt; C[Corrected&lt;br&gt;Design]\n    C -.-&gt; D[Design&lt;br&gt;Verification]\n    style B stroke:#4ade80,stroke-width:2px</code></pre> <p>Design correction automatically compensates for fabrication effects by pre-distorting layouts to account for known manufacturing variations.</p> <p>For a simplified example, see our correction notebook.</p> <p>The correction model works in reverse from prediction. Instead of predicting what a design will fabricate into, it generates a design that will fabricate into your target structure. The model adjusts geometries by adding material where erosion is expected and removing it where dilation occurs.</p> <p>The corrected design can go directly to fabrication or through verification first for additional confidence. While correction cannot achieve perfect results\u2014some features like sharp 90\u00b0 corners remain physically constrained\u2014it consistently produces significant improvements, often recovering much of the performance loss from fabrication effects.</p> <p>A key advantage: correction can improve existing designs without requiring a complete redesign. For circuits that are functionally working but underperforming due to fabrication variations, correction offers a practical path to better performance.</p>"},{"location":"fab_aware_design/#fabrication-aware-inverse-design","title":"Fabrication-aware inverse design","text":"<pre><code>flowchart LR\n    A[Device&lt;br&gt;Design] --&gt; B[Prediction&lt;br&gt;Model]\n    B --&gt; C[Predicted&lt;br&gt;Design]\n    C --&gt; D[EM&lt;br&gt;Simulation]\n    D --&gt; E[Gradient&lt;br&gt;Calculation]\n    E --&gt; |Optimization| A\n    style B stroke:#4ade80,stroke-width:2px\n    style D stroke:#fbbf24,stroke-width:2px</code></pre> <p>Fabrication-aware inverse design (FAID) integrates fabrication effects directly into the optimization process rather than treating them as a post-processing step.</p> <p>In this approach, the prediction model operates within the optimization loop itself. Each design iteration is predicted, simulated, and evaluated based on its expected fabricated form rather than its idealized geometry. The optimizer receives gradients based on fabricated performance, naturally guiding the design toward structures that work well after manufacturing.</p> <p>This is particularly valuable for fabrication effects that cannot be easily corrected through geometric pre-distortion, such as stochastic roughness or certain etching behaviors. By optimizing with these effects in the loop, the design process can work around fundamental constraints rather than fighting them.</p> <p>The tradeoff: FAID requires more computational resources and setup compared to verification or correction workflows. However, for high-performance devices where marginal gains matter, it offers a path to extracting maximum performance from a given fabrication process.</p> <p>For a detailed example, see this fabrication-aware inverse design tutorial.</p>"},{"location":"fab_aware_design/#choosing-an-approach","title":"Choosing an approach","text":"<p>These three workflows are complementary rather than mutually exclusive. Many design processes benefit from combining them:</p> <ul> <li>Start with verification to understand how fabrication will affect your existing designs and identify which devices need attention.</li> <li>Use correction to improve existing designs or as a fast path to better performance without full redesign.</li> <li>Deploy FAID for new designs where maximum performance is critical and computational resources permit.</li> </ul> <p>The common thread: all three approaches use the same underlying prediction and correction models, making it straightforward to move between workflows as your needs evolve.</p> <p>Interested in applying fabrication-aware design to your process? Reach out to us to discuss how these approaches can work for your specific devices and fabrication requirements.</p>"},{"location":"models/","title":"Models","text":"Foundry Process Latest Version Latest Dataset Model Name Model Tag Generic SOI ANF1 (Nov 7 2025) d0 (Nov 7 2025) Generic_SOI ANF1-d0 <p>Please contact us at hi@prefabphotonics.com for additional foundry and process models.</p>"},{"location":"python-for-photonics/","title":"Python for Photonics Development","text":"<p>Python has become the standard platform for photonics simulation, modeling, and analysis. Its ecosystem of scientific computing libraries and integration with major simulation tools makes it the practical choice for streamlining photonic device development workflows.</p> <p>This guide covers environment setup, essential libraries, development tools, and resources for Python-based photonics work.</p> <p>Note</p> <p>PreFab is built with Python. This guide reflects tools and practices that have proven effective in production photonics development.</p>"},{"location":"python-for-photonics/#essential-python-libraries-for-photonics","title":"Essential Python Libraries for Photonics","text":"<p>Simulation and electromagnetics:</p> <ul> <li> <p>Tidy3D: Commercial cloud-based FDTD solver with high-performance simulations and Python API integration.</p> </li> <li> <p>Meep: Open-source FDTD package with extensive Python bindings. Strong documentation covers both software usage and electromagnetic fundamentals.</p> </li> </ul> <p>Layout and design:</p> <ul> <li> <p>gdsfactory: Industry-standard open-source library for photonic integrated circuit design, layout generation, and simulation tool integration.</p> </li> <li> <p>KLayout: 2D mask layout viewer and editor with Python scripting capabilities for automation in chip manufacturing workflows.</p> </li> <li> <p>SiEPIC: Comprehensive PIC design suite with KLayout integration. Includes component libraries, circuit simulation, and verification tools for silicon photonics.</p> </li> <li> <p>gdstk: Library for creating and manipulating GDS files with support for complex geometric operations.</p> </li> </ul> <p>Resources:</p> <ul> <li>Awesome Photonics: Curated repository of photonics tools and resources, including Python-compatible frameworks.</li> </ul>"},{"location":"python-for-photonics/#setting-up-your-development-environment","title":"Setting up Your Development Environment","text":""},{"location":"python-for-photonics/#choosing-an-ide","title":"Choosing an IDE","text":"<p>Visual Studio Code: Free, open-source IDE with extensive extension support, code completion, debugging tools, and Git integration.</p> <p>Cursor: VS Code fork with integrated AI coding assistance. Provides code completion, analysis, and refactoring through language model integration.</p> <p>Zed: High-performance IDE optimized for speed and responsive editing. Still in active development with limited platform support.</p> <p>This guide uses VS Code as the reference environment.</p>"},{"location":"python-for-photonics/#essential-vs-code-extensions","title":"Essential VS Code Extensions","text":"<p>Python: Core Python support including IntelliSense, linting, debugging, and code formatting.</p> <p>Jupyter: Run Jupyter Notebooks directly in VS Code for interactive development and data analysis.</p> <p>Ruff: Fast Python linter and formatter. Enforces consistent code style automatically on save.</p>"},{"location":"python-for-photonics/#installing-extensions","title":"Installing Extensions","text":"<ol> <li>Open VS Code Extensions view: Click the Extensions icon or press <code>Ctrl+Shift+X</code> (<code>Cmd+Shift+X</code> on macOS)</li> <li>Search for the extension name</li> <li>Click Install</li> <li>Reload VS Code if prompted</li> </ol>"},{"location":"python-for-photonics/#configuring-vs-code-for-python","title":"Configuring VS Code for Python","text":"<p>Open your VS Code settings file:</p> <ul> <li><code>File</code> &gt; <code>Preferences</code> &gt; <code>Settings</code> (<code>Ctrl+,</code> / <code>Cmd+,</code>), then click the <code>{}</code> icon (upper right)</li> <li>Or use Command Palette (<code>Ctrl+Shift+P</code> / <code>Cmd+Shift+P</code>) and search for <code>Open User Settings (JSON)</code></li> </ul> <p>Add or merge the following configuration:</p> <pre><code>{\n  \"editor\": {\n    \"formatOnSave\": true,\n    \"codeActionsOnSave\": {\n      \"source.fixAll\": \"explicit\",\n      \"source.organizeImports\": \"explicit\"\n    },\n    \"defaultFormatter\": \"charliermarsh.ruff\"\n  },\n  \"notebook\": {\n    \"formatOnSave\": {\n      \"enabled\": true\n    },\n    \"codeActionsOnSave\": {\n      \"notebook.source.fixAll\": true,\n      \"notebook.source.organizeImports\": true\n    },\n    \"defaultFormatter\": \"charliermarsh.ruff\"\n  },\n  \"jupyter.runStartupCommands\": [\"%load_ext autoreload\", \"%autoreload 2\"]\n}\n</code></pre> <p>This configuration enables:</p> <ul> <li>Automatic code formatting on save using Ruff</li> <li>Automatic import organization and linting fixes</li> <li>Jupyter auto-reload to eliminate stale import issues during development</li> </ul>"},{"location":"python-for-photonics/#virtual-environment-management","title":"Virtual Environment Management","text":"<p>Virtual environments isolate project dependencies and Python versions, preventing conflicts between projects and system installations.</p> <p>Environment managers:</p> <ul> <li> <p>uv: High-performance environment and package manager from Astral (creators of Ruff). Significantly faster than traditional tools with modern dependency resolution.</p> </li> <li> <p>Conda: Cross-platform manager supporting both Python and non-Python dependencies. Use when projects require compiled scientific libraries or complex system dependencies.</p> </li> <li> <p>venv: Built-in Python 3 module for basic virtual environment creation.</p> </li> </ul> <p>This guide uses uv for its performance and simplicity.</p>"},{"location":"python-for-photonics/#setting-up-uv","title":"Setting Up uv","text":"<p>1. Install uv</p> <p>macOS/Linux:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Windows:</p> <pre><code>powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>2. Create and activate an environment</p> <p>Open the VS Code terminal (<code>View</code> &gt; <code>Terminal</code> or <code>Ctrl+`</code> / <code>Cmd+`</code>):</p> <pre><code>uv venv\nsource .venv/bin/activate  # macOS/Linux\n# or\n.venv\\Scripts\\activate  # Windows\n</code></pre> <p>3. Install packages</p> <pre><code>uv pip install prefab numpy scipy\n</code></pre> <p>uv handles package installation significantly faster than pip while maintaining compatibility with the PyPI ecosystem.</p>"},{"location":"python-for-photonics/#selecting-the-environment-in-vs-code","title":"Selecting the Environment in VS Code","text":"<p>For Python files:</p> <ol> <li>Open a <code>.py</code> file</li> <li>Click the Python version in the status bar (bottom right)</li> <li>Select the environment from your project directory (<code>.venv</code>)</li> </ol> <p>For Jupyter notebooks:</p> <ol> <li>Open a <code>.ipynb</code> file</li> <li>Click the kernel name (top right)</li> <li>Select the Python interpreter from <code>.venv</code></li> </ol> <p>Troubleshooting:</p> <p>If your environment doesn't appear in the kernel list:</p> <pre><code>uv pip install ipykernel\npython -m ipykernel install --user --name=myenv\n</code></pre> <p>Restart VS Code after installation.</p>"},{"location":"python-for-photonics/#cloud-and-remote-computing","title":"Cloud and Remote Computing","text":"<p>Photonics simulations often require significant computational resources. Cloud platforms provide access to GPUs and high-performance compute without local hardware investment.</p> <p>Google Colab: Free cloud-based Jupyter environment with GPU and TPU access. Browser-based with no setup required.</p> <p>GitHub Codespaces: Full cloud development environment integrated with GitHub repositories. Runs VS Code in the browser.</p> <p>Modal: Serverless computing platform for running Python functions in the cloud with minimal configuration.</p> <p>SSH VS Code Extension: Connect VS Code to remote servers and cloud instances for development on remote hardware.</p>"},{"location":"python-for-photonics/#terminal-tools","title":"Terminal Tools","text":"<p>Git: Distributed version control system. Essential for code management and collaboration. See this introduction for Git fundamentals.</p> <p>lazygit: Terminal UI for Git operations. Provides an intuitive interface for staging, committing, branching, and managing repositories without memorizing commands.</p> <p>htop: Interactive process viewer showing real-time CPU and memory usage. Particularly useful for monitoring remote compute instances.</p> <p>nvtop: GPU process viewer for NVIDIA hardware. Similar to htop but for GPU monitoring.</p> <p>Oh My Zsh: Framework for managing Zsh shell configuration. Provides plugins and themes for enhanced terminal functionality.</p> <p>Claude Code: Terminal-based AI coding assistant from Anthropic. Integrates with your development workflow for code generation, debugging, and technical explanations directly in the command line.</p>"},{"location":"python-for-photonics/#ai-coding-assistants","title":"AI Coding Assistants","text":"<p>AI coding assistants provide code completion, debugging help, and technical explanations. Useful for both learning Python and exploring new libraries.</p> <p>ChatGPT: OpenAI's language model with broad programming knowledge. Regular model improvements and feature updates.</p> <p>Claude: Anthropic's language model. Different training approach may provide complementary capabilities to ChatGPT.</p> <p>Cursor: AI-enhanced IDE with multi-model support. Choose between different language models based on task requirements.</p> <p>GitHub Copilot: AI code completion integrated into VS Code. Provides inline suggestions during coding.</p> <p>Research indicates measurable productivity improvements from AI assistant usage in development workflows.</p>"},{"location":"python-for-photonics/#additional-resources","title":"Additional Resources","text":"<p>Community and support:</p> <ul> <li> <p>Stack Overflow: Q&amp;A platform for specific coding issues and technical problems.</p> </li> <li> <p>GitHub: Many photonics projects host issues and discussions on GitHub. Contributing to open-source projects provides direct engagement with tool developers.</p> </li> </ul> <p>Books:</p> <ul> <li> <p>\"Think Python: How to Think Like a Computer Scientist\" by Allen B. Downey: Introduction to Python focused on computational thinking fundamentals.</p> </li> <li> <p>\"Effective Computation in Physics: Field Guide to Research with Python\" by Anthony Scopatz and Kathryn D. Huff: Python for scientific computing and physics research workflows.</p> </li> </ul> <p>Podcasts:</p> <ul> <li>\"Talk Python to Me\": Interviews with Python community contributors covering language evolution and ecosystem developments.</li> </ul>"},{"location":"python-for-photonics/#next-steps","title":"Next Steps","text":"<ol> <li> <p>Run simulations: Work through examples in Meep and Tidy3D documentation.</p> </li> <li> <p>Contribute to open source: Engage with projects like gdsfactory and SiEPIC.</p> </li> <li> <p>Try PreFab: Run example notebooks demonstrating fabrication-aware photonics design with virtual nanofabrication models.</p> </li> </ol>"},{"location":"setup/","title":"Setup","text":"<p>Follow the steps below to install and authenticate the PreFab Python package.</p> <p>Python</p> <p>If you are newer to Python, we recommend reading our Python for Photonics guide.</p>"},{"location":"setup/#install-prefab","title":"Install PreFab","text":""},{"location":"setup/#from-pypi-for-users","title":"From PyPI (for users)","text":"<p>You can install PreFab using pip, which is the Python package installer. This method is suitable for most users.</p> <pre><code>pip install prefab\n</code></pre>"},{"location":"setup/#from-github-for-contributors","title":"From GitHub (for contributors)","text":"<p>For those who wish to contribute to PreFab or make changes to the source code, we recommend using uv for development, which provides faster dependency resolution and better reproducibility.</p> <p>Using uv (recommended):</p> <pre><code># Install uv (if not already installed)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone and set up the project\ngit clone https://github.com/PreFab-Photonics/PreFab.git\ncd PreFab\nuv sync\n</code></pre> <p>Using pip (alternative):</p> <pre><code>git clone https://github.com/PreFab-Photonics/PreFab.git\ncd PreFab\npip install -e .\n</code></pre>"},{"location":"setup/#sign-up","title":"Sign up","text":"<p>Before you can make PreFab requests, you will need to create an account. Sign up here.</p>"},{"location":"setup/#authenticate-prefab-token-easiest","title":"Authenticate PreFab token (easiest)","text":"<p>To link your PreFab account to the API, you will need to create an authentication token. You can do this by running the following shell command. This will open a browser window where you can log in and generate a token.</p> <pre><code>prefab setup\n</code></pre>"},{"location":"setup/#remote-server-authentication-alternative","title":"Remote server authentication (alternative)","text":"<p>For remote servers, CI/CD pipelines, or environments without browser access, you can use an API key instead of the browser-based setup above.</p>"},{"location":"setup/#generate-an-api-key","title":"Generate an API key","text":"<ol> <li>Log in to your account dashboard</li> <li>Find the API Keys section</li> <li>Click Generate and copy the key (it will only be shown once)</li> </ol>"},{"location":"setup/#set-the-environment-variable","title":"Set the environment variable","text":"<p>Set the <code>PREFAB_API_KEY</code> environment variable with your key:</p> <pre><code>export PREFAB_API_KEY=&lt;your_key_here&gt;\n</code></pre> <p>For persistent configuration, add the above line to your shell profile (<code>~/.bashrc</code>, <code>~/.zshrc</code>, etc.) or your deployment environment's secrets configuration.</p>"},{"location":"setup/#verify-installation","title":"Verify installation","text":"<p>To verify that PreFab is setup correctly, you can run the following Python code.</p> <pre><code>import prefab as pf\n\ndevice = pf.shapes.target()\nprediction = device.predict(model=pf.models[\"Generic_SOI\"])\n</code></pre> <p>If the code runs without errors, you have successfully installed and authenticated PreFab. If not, please reach out to us at support@prefabphotonics.com.</p>"},{"location":"examples/1_prediction/","title":"Making a prediction","text":""},{"location":"examples/1_prediction/#introduction","title":"Introduction","text":"<p>See how your designs will actually fabricate. This example demonstrates PreFab's prediction model on a 500 nm target structure, showing corner rounding, feature erosion, and gap filling - the structural variations that affect device performance.</p> <p>Import the library: <pre><code>import prefab as pf\n</code></pre></p>"},{"location":"examples/1_prediction/#loading-a-device","title":"Loading a device","text":"<p>Create a device to predict. The <code>Device</code> class represents photonic geometries in PreFab - load from GDS, images, or numpy arrays with binary pixel values (0 or 1). We'll use a target structure here, but explore other shapes in <code>shapes.py</code> or add your own. <pre><code>device = pf.shapes.target(width=500, arm_width=60)\ndevice.plot(show_buffer=False)\n</code></pre></p> <p></p>"},{"location":"examples/1_prediction/#predicting-a-device","title":"Predicting a device","text":"<p>Run a prediction using a specific fabrication model. Reach out if you'd like a model trained for your fabrication process.</p> <p>Predictions include fuzzy edges representing stochastic fabrication variations. The raw output shows the uncertainty range across different runs; binarization extracts the most probable outcome (50% threshold). You can binarize during or after prediction:</p> <p>Note</p> <p>Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"Generic_SOI\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</code></pre> <p></p> <p></p>"},{"location":"examples/1_prediction/#analyzing-a-prediction","title":"Analyzing a prediction","text":"<p>Compare the predicted structure against your design. The 60 nm arms show erosion and corner rounding at convex corners. Concave corners in the center show dilation, and the center opening fills completely - typical fabrication effects that impact device performance. <pre><code>prediction_bin.plot_compare(ref_device=device, show_buffer=False)\n</code></pre></p> <p></p> <p>Quantify the deviation using Intersection over Union (IoU). This metric measures geometric overlap: 1.0 is a perfect match, 0.0 is no overlap. <pre><code>print(\n    f\"Prediction IoU: {pf.compare.intersection_over_union(device, prediction_bin):.2f}\"\n)\n</code></pre></p> <pre><code>Prediction IoU: 0.83\n</code></pre> <p>83% overlap reflects the challenging 60 nm feature size. Try different <code>arm_width</code> values to see how feature size affects fabrication accuracy. Visualize prediction uncertainty through the fuzzy edge regions. These areas show where stochastic fabrication variations cause device-to-device differences. While correction can't eliminate stochastic effects, understanding uncertainty helps identify high-variance features in your designs. <pre><code>prediction.plot_uncertainty(show_buffer=False)\n</code></pre></p> <p></p> <p>Next, see how to restore this structure using PreFab's correction capabilities.</p>"},{"location":"examples/2_correction/","title":"Making a correction","text":""},{"location":"examples/2_correction/#introduction","title":"Introduction","text":"<p>Pre-compensate designs to counteract fabrication effects. This example shows how to correct the same 500 nm target structure, automatically adjusting the layout so the fabricated result matches your target specifications.</p> <p>Import the library: <pre><code>import prefab as pf\n</code></pre></p>"},{"location":"examples/2_correction/#loading-a-device","title":"Loading a device","text":"<p>Create your target device - the structure you want to fabricate. The <code>Device</code> class represents photonic geometries in PreFab - load from GDS, images, or numpy arrays with binary pixel values (0 or 1). <pre><code>device = pf.shapes.target(width=500, arm_width=60)\ndevice.plot(show_buffer=False)\n</code></pre></p> <p></p>"},{"location":"examples/2_correction/#correcting-a-device","title":"Correcting a device","text":"<p>Run a correction using a specific fabrication model. Reach out if you'd like a model trained for your fabrication process.</p> <p>Note</p> <p>Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"Generic_SOI\"\ncorrection = device.correct(model=pf.models[MODEL_NAME])\ncorrection.plot(show_buffer=False)\n</code></pre> <p></p> <p>The correction model pre-distorts the layout to compensate for fabrication effects - adding material where erosion is expected, removing it where dilation occurs. <pre><code>correction.plot_compare(ref_device=device, show_buffer=False)\n</code></pre></p> <p></p>"},{"location":"examples/2_correction/#making-a-prediction-of-the-correction","title":"Making a prediction of the correction","text":"<p>Verify the correction by predicting the fabrication outcome. The corrected design shows sharper corners and better-resolved features. The IoU score improves from 83% to 95% - meaning the fabricated device will match your target specifications far more closely. <pre><code>outcome = correction.predict(model=pf.models[MODEL_NAME])\noutcome_bin = outcome.binarize()\n\noutcome.plot(show_buffer=False)\noutcome_bin.plot(show_buffer=False)\noutcome_bin.plot_compare(ref_device=device, show_buffer=False)\n</code></pre></p> <p></p> <p></p> <p></p> <pre><code>print(f\"Corrected IoU: {pf.compare.intersection_over_union(device, outcome_bin):.2f}\")\n</code></pre> <pre><code>Corrected IoU: 0.95\n</code></pre> <p>While perfect restoration isn't always achievable due to physical constraints, correction consistently recovers significant performance. Stay updated with the latest models as we continue improving accuracy.</p>"},{"location":"reference/compare/","title":"Compare","text":"<p>Similarity metrics for comparing device structures.</p> <p>This module provides various metrics for quantifying the similarity between two Device objects, including general-purpose metrics (MSE) and binary-specific metrics (IoU, Hamming distance, Dice coefficient).</p>"},{"location":"reference/compare/#prefab.compare.dice_coefficient","title":"<code>dice_coefficient(device_a, device_b)</code>","text":"<p>Calculate the Dice coefficient between two binary devices.</p> <p>Also known as the S\u00f8rensen-Dice coefficient or F1 score. The Dice coefficient measures similarity as twice the intersection divided by the sum of the sizes of both sets. Higher values indicate greater similarity.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (should be binarized for meaningful results).</p> required <code>device_b</code> <code>Device</code> <p>The second device (should be binarized for meaningful results).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Dice coefficient. Range: [0, 1], where 1 indicates perfect overlap.</p> Source code in <code>prefab/compare.py</code> <pre><code>def dice_coefficient(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the Dice coefficient between two binary devices.\n\n    Also known as the S\u00f8rensen-Dice coefficient or F1 score. The Dice coefficient\n    measures similarity as twice the intersection divided by the sum of the sizes of\n    both sets. Higher values indicate greater similarity.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (should be binarized for meaningful results).\n    device_b : Device\n        The second device (should be binarized for meaningful results).\n\n    Returns\n    -------\n    float\n        The Dice coefficient. Range: [0, 1], where 1 indicates perfect overlap.\n    \"\"\"\n    intersection_sum = float(\n        np.sum(np.logical_and(device_a.device_array, device_b.device_array))\n    )\n    size_a_sum = float(np.sum(device_a.device_array))\n    size_b_sum = float(np.sum(device_b.device_array))\n    return (2.0 * intersection_sum) / (size_a_sum + size_b_sum)\n</code></pre>"},{"location":"reference/compare/#prefab.compare.hamming_distance","title":"<code>hamming_distance(device_a, device_b)</code>","text":"<p>Calculate the Hamming distance between two binary devices.</p> <p>The Hamming distance is the count of positions where corresponding pixels differ. Lower values indicate greater similarity, with 0 representing identical devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (should be binarized for meaningful results).</p> required <code>device_b</code> <code>Device</code> <p>The second device (should be binarized for meaningful results).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of differing pixels. Range: [0, total_pixels], where 0 indicates identical devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def hamming_distance(device_a: Device, device_b: Device) -&gt; int:\n    \"\"\"\n    Calculate the Hamming distance between two binary devices.\n\n    The Hamming distance is the count of positions where corresponding pixels differ.\n    Lower values indicate greater similarity, with 0 representing identical devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (should be binarized for meaningful results).\n    device_b : Device\n        The second device (should be binarized for meaningful results).\n\n    Returns\n    -------\n    int\n        The number of differing pixels. Range: [0, total_pixels], where 0 indicates\n        identical devices.\n    \"\"\"\n    diff_array = device_a.device_array != device_b.device_array\n    return int(np.sum(diff_array))\n</code></pre>"},{"location":"reference/compare/#prefab.compare.intersection_over_union","title":"<code>intersection_over_union(device_a, device_b)</code>","text":"<p>Calculate the Intersection over Union (IoU) between two binary devices.</p> <p>Also known as the Jaccard index. IoU measures the overlap between two binary masks as the ratio of their intersection to their union. Higher values indicate greater similarity.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (should be binarized for meaningful results).</p> required <code>device_b</code> <code>Device</code> <p>The second device (should be binarized for meaningful results).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The IoU score. Range: [0, 1], where 1 indicates perfect overlap.</p> Source code in <code>prefab/compare.py</code> <pre><code>def intersection_over_union(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the Intersection over Union (IoU) between two binary devices.\n\n    Also known as the Jaccard index. IoU measures the overlap between two binary masks\n    as the ratio of their intersection to their union. Higher values indicate greater\n    similarity.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (should be binarized for meaningful results).\n    device_b : Device\n        The second device (should be binarized for meaningful results).\n\n    Returns\n    -------\n    float\n        The IoU score. Range: [0, 1], where 1 indicates perfect overlap.\n    \"\"\"\n    intersection_sum = float(\n        np.sum(np.logical_and(device_a.device_array, device_b.device_array))\n    )\n    union_sum = float(\n        np.sum(np.logical_or(device_a.device_array, device_b.device_array))\n    )\n    return intersection_sum / union_sum\n</code></pre>"},{"location":"reference/compare/#prefab.compare.mean_squared_error","title":"<code>mean_squared_error(device_a, device_b)</code>","text":"<p>Calculate the mean squared error (MSE) between two devices.</p> <p>MSE quantifies the average squared difference between corresponding pixels. Lower values indicate greater similarity, with 0 representing identical devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device.</p> required <code>device_b</code> <code>Device</code> <p>The second device.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean squared error. Range: [0, \u221e), where 0 indicates identical devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def mean_squared_error(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between two devices.\n\n    MSE quantifies the average squared difference between corresponding pixels. Lower\n    values indicate greater similarity, with 0 representing identical devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The mean squared error. Range: [0, \u221e), where 0 indicates identical devices.\n    \"\"\"\n    return float(np.mean((device_a.device_array - device_b.device_array) ** 2))\n</code></pre>"},{"location":"reference/device/","title":"Device","text":"<p>Core device representation and manipulation for photonic geometries.</p> <p>This module provides the Device class for representing planar photonic device geometries and performing operations on them. It includes buffer zone management, prediction and correction of nanofabrication outcomes, visualization capabilities, and export functions to various formats. The module also supports geometric transformations (rotation, dilation, erosion), image processing operations (blur, binarization), and comparison tools for analyzing fabrication deviations.</p>"},{"location":"reference/device/#prefab.device.BufferSpec","title":"<code>BufferSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the specifications for a buffer zone around a device.</p> <p>This class is used to specify the mode and thickness of a buffer zone that is added around the device geometry. The buffer zone can be used for various purposes such as providing extra space for device fabrication processes or for ensuring that the device is isolated from surrounding structures.</p> <p>Attributes:</p> Name Type Description <code>mode</code> <code>dict[str, str]</code> <p>A dictionary that defines the buffer mode for each side of the device ('top', 'bottom', 'left', 'right'), where: - 'constant' is used for isolated structures - 'edge' is utilized for preserving the edge, such as for waveguide connections - 'none' for no buffer on that side</p> <code>thickness</code> <code>dict[str, int]</code> <p>A dictionary that defines the thickness of the buffer zone for each side of the device ('top', 'bottom', 'left', 'right'). Each value must be greater than or equal to 0.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the modes specified in the 'mode' dictionary are not one of the allowed values ('constant', 'edge', 'none'). Or if any of the thickness values are negative.</p> <p>Examples:</p> <pre><code>import prefab as pf\n\nbuffer_spec = pf.BufferSpec(\n    mode={\n        \"top\": \"constant\",\n        \"bottom\": \"none\",\n        \"left\": \"constant\",\n        \"right\": \"edge\",\n    },\n    thickness={\n        \"top\": 150,\n        \"bottom\": 0,\n        \"left\": 200,\n        \"right\": 250,\n    },\n)\n</code></pre> Source code in <code>prefab/device.py</code> <pre><code>class BufferSpec(BaseModel):\n    \"\"\"\n    Defines the specifications for a buffer zone around a device.\n\n    This class is used to specify the mode and thickness of a buffer zone that is added\n    around the device geometry. The buffer zone can be used for various purposes such as\n    providing extra space for device fabrication processes or for ensuring that the\n    device is isolated from surrounding structures.\n\n    Attributes\n    ----------\n    mode : dict[str, str]\n        A dictionary that defines the buffer mode for each side of the device\n        ('top', 'bottom', 'left', 'right'), where:\n        - 'constant' is used for isolated structures\n        - 'edge' is utilized for preserving the edge, such as for waveguide connections\n        - 'none' for no buffer on that side\n    thickness : dict[str, int]\n        A dictionary that defines the thickness of the buffer zone for each side of the\n        device ('top', 'bottom', 'left', 'right'). Each value must be greater than or\n        equal to 0.\n\n    Raises\n    ------\n    ValueError\n        If any of the modes specified in the 'mode' dictionary are not one of the\n        allowed values ('constant', 'edge', 'none'). Or if any of the thickness values\n        are negative.\n\n    Examples\n    --------\n        import prefab as pf\n\n        buffer_spec = pf.BufferSpec(\n            mode={\n                \"top\": \"constant\",\n                \"bottom\": \"none\",\n                \"left\": \"constant\",\n                \"right\": \"edge\",\n            },\n            thickness={\n                \"top\": 150,\n                \"bottom\": 0,\n                \"left\": 200,\n                \"right\": 250,\n            },\n        )\n    \"\"\"\n\n    mode: dict[str, Literal[\"constant\", \"edge\", \"none\"]] = Field(\n        default_factory=lambda: {\n            \"top\": \"constant\",\n            \"bottom\": \"constant\",\n            \"left\": \"constant\",\n            \"right\": \"constant\",\n        }\n    )\n    thickness: dict[str, int] = Field(\n        default_factory=lambda: {\n            \"top\": 128,\n            \"bottom\": 128,\n            \"left\": 128,\n            \"right\": 128,\n        }\n    )\n\n    @field_validator(\"mode\", mode=\"before\")\n    @classmethod\n    def check_mode(cls, v: dict[str, str]) -&gt; dict[str, str]:\n        allowed_modes = [\"constant\", \"edge\", \"none\"]\n        if not all(mode in allowed_modes for mode in v.values()):\n            raise ValueError(f\"Buffer mode must be one of {allowed_modes}, got '{v}'.\")\n        return v\n\n    @field_validator(\"thickness\")\n    @classmethod\n    def check_thickness(cls, v: dict[str, int]) -&gt; dict[str, int]:\n        if not all(t &gt;= 0 for t in v.values()):\n            raise ValueError(\"All thickness values must be greater than or equal to 0.\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def check_none_thickness(self) -&gt; \"BufferSpec\":\n        mode = self.mode\n        thickness = self.thickness\n        for side in mode:\n            if mode[side] == \"none\" and thickness[side] != 0:\n                raise ValueError(\n                    f\"Thickness must be 0 when mode is 'none' for {side} side\"\n                )\n            if mode[side] != \"none\" and thickness[side] == 0:\n                raise ValueError(\n                    f\"Mode must be 'none' when thickness is 0 for {side} side\"\n                )\n        return self\n</code></pre>"},{"location":"reference/device/#prefab.device.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>prefab/device.py</code> <pre><code>class Device(BaseModel):\n    device_array: npt.NDArray[Any] = Field(...)\n    buffer_spec: BufferSpec = Field(default_factory=BufferSpec)\n\n    class Config:\n        arbitrary_types_allowed: bool = True\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        return tuple(self.device_array.shape)\n\n    def __init__(\n        self, device_array: npt.NDArray[Any], buffer_spec: BufferSpec | None = None\n    ):\n        \"\"\"\n        Represents the planar geometry of a photonic device design that will have its\n        nanofabrication outcome predicted and/or corrected.\n\n        This class is designed to encapsulate the geometric representation of a photonic\n        device, facilitating operations such as padding, normalization, binarization,\n        erosion/dilation, trimming, and blurring. These operations are useful for\n        preparingthe device design for prediction or correction. Additionally, the class\n        providesmethods for exporting the device representation to various formats,\n        includingndarray, image files, and GDSII files, supporting a range of analysis\n        and fabrication workflows.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            A 2D array representing the planar geometry of the device. This array\n            undergoes various transformations to predict or correct the nanofabrication\n            process.\n        buffer_spec : Optional[BufferSpec]\n            Defines the parameters for adding a buffer zone around the device geometry.\n            This buffer zone is needed for providing surrounding context for prediction\n            or correction and for ensuring seamless integration with the surrounding\n            circuitry. By default, a generous padding is applied to accommodate isolated\n            structures.\n\n        Attributes\n        ----------\n        shape : tuple[int, int]\n            The shape of the device array.\n\n        Raises\n        ------\n        ValueError\n            If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n            indicating an invalid device geometry.\n        \"\"\"\n        super().__init__(\n            device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n        )\n        self._initial_processing()\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Axes:\n        return self.plot(*args, **kwargs)\n\n    def _initial_processing(self) -&gt; None:\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        if buffer_mode[\"top\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((buffer_thickness[\"top\"], 0), (0, 0)),\n                mode=buffer_mode[\"top\"],\n            )\n\n        if buffer_mode[\"bottom\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((0, buffer_thickness[\"bottom\"]), (0, 0)),\n                mode=buffer_mode[\"bottom\"],\n            )\n\n        if buffer_mode[\"left\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((0, 0), (buffer_thickness[\"left\"], 0)),\n                mode=buffer_mode[\"left\"],\n            )\n\n        if buffer_mode[\"right\"] != \"none\":\n            self.device_array = np.pad(\n                self.device_array,\n                pad_width=((0, 0), (0, buffer_thickness[\"right\"])),\n                mode=buffer_mode[\"right\"],\n            )\n\n        self.device_array = np.expand_dims(self.device_array, axis=-1)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_device_array(cls, values: dict[str, Any]) -&gt; dict[str, Any]:\n        device_array = values.get(\"device_array\")\n        if not isinstance(device_array, np.ndarray):\n            raise ValueError(\"device_array must be a numpy ndarray.\")\n        if device_array.ndim != 2:\n            raise ValueError(\"device_array must be a 2D array.\")\n        return values\n\n    @property\n    def is_binary(self) -&gt; bool:\n        \"\"\"\n        Check if the device geometry is binary.\n\n        Returns\n        -------\n        bool\n            True if the device geometry is binary, False otherwise.\n        \"\"\"\n        unique_values = np.unique(self.device_array)\n        return (\n            np.array_equal(unique_values, [0, 1])\n            or np.array_equal(unique_values, [1, 0])\n            or np.array_equal(unique_values, [0])\n            or np.array_equal(unique_values, [1])\n        )\n\n    def predict(\n        self,\n        model: Model,\n        binarize: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Predict the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless prediction service, which\n        uses a specified machine learning model to predict the outcome of the\n        nanofabrication process.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for prediction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry\n            and process, as defined in `models.py`. Each model is associated with a\n            version and dataset that detail its creation and the data it was trained on,\n            ensuring the prediction is tailored to specific fabrication parameters.\n        binarize : bool\n            If True, the predicted device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic predictions into binary\n            geometries. Defaults to False.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the predicted geometry.\n\n        Raises\n        ------\n        RuntimeError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        prediction_array = predict_array(\n            device_array=self.device_array,\n            model=model,\n            model_type=\"p\",\n            binarize=binarize,\n        )\n        return self.model_copy(update={\"device_array\": prediction_array})\n\n    def correct(\n        self,\n        model: Model,\n        binarize: bool = True,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Correct the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless correction service, which\n        uses a specified machine learning model to correct the outcome of the\n        nanofabrication process. The correction aims to adjust the device geometry to\n        compensate for known fabrication errors and improve the accuracy of the final\n        device structure.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for correction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry\n            and process, as defined in `models.py`. Each model is associated with a\n            version and dataset that detail its creation and the data it was trained on,\n            ensuring the correction is tailored to specific fabrication parameters.\n        binarize : bool\n            If True, the corrected device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic corrections into binary\n            geometries. Defaults to True.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the corrected geometry.\n\n        Raises\n        ------\n        RuntimeError\n            If the correction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        correction_array = predict_array(\n            device_array=self.device_array,\n            model=model,\n            model_type=\"c\",\n            binarize=binarize,\n        )\n        return self.model_copy(update={\"device_array\": correction_array})\n\n    def to_ndarray(self) -&gt; npt.NDArray[Any]:\n        \"\"\"\n        Converts the device geometry to an ndarray.\n\n        This method applies the buffer specifications to crop the device array if\n        necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n        resulting ndarray representing the device geometry.\n\n        Returns\n        -------\n        np.ndarray\n            The ndarray representation of the device geometry, with any applied buffer\n            cropping.\n        \"\"\"\n        device_array = np.copy(self.device_array)\n        buffer_thickness = self.buffer_spec.thickness\n\n        crop_top = buffer_thickness[\"top\"]\n        crop_bottom = buffer_thickness[\"bottom\"]\n        crop_left = buffer_thickness[\"left\"]\n        crop_right = buffer_thickness[\"right\"]\n\n        ndarray = device_array[\n            crop_top : device_array.shape[0] - crop_bottom,\n            crop_left : device_array.shape[1] - crop_right,\n        ]\n        return ndarray\n\n    def to_img(\n        self,\n        img_path: str = \"prefab_device.png\",\n        bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Exports the device geometry as an image file.\n\n        This method converts the device geometry to an ndarray using `to_ndarray`,\n        scales the values to the range [0, 255] for image representation, and saves the\n        result as an image file.\n\n        Parameters\n        ----------\n        img_path : str\n            The path where the image file will be saved. If not specified, the image is\n            saved as \"prefab_device.png\" in the current directory.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for cropping the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n            (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n            to \"end\", it will be replaced with the corresponding dimension size of the\n            device array. If None, the entire device geometry is exported.\n        \"\"\"\n        device_array = self.flatten().to_ndarray()\n\n        if bounds is not None:\n            min_x, min_y = bounds[0]\n            max_x, max_y = bounds[1]\n\n            # Handle negative indices (count from end)\n            if min_x &lt; 0:\n                min_x = device_array.shape[1] + min_x\n            if min_y &lt; 0:\n                min_y = device_array.shape[0] + min_y\n            if max_x != \"end\" and max_x &lt; 0:\n                max_x = device_array.shape[1] + max_x\n            if max_y != \"end\" and max_y &lt; 0:\n                max_y = device_array.shape[0] + max_y\n\n            # Clamp to valid range\n            min_x = max(min_x, 0)\n            min_y = max(min_y, 0)\n            max_x = \"end\" if max_x == \"end\" else min(max_x, device_array.shape[1])\n            max_y = \"end\" if max_y == \"end\" else min(max_y, device_array.shape[0])\n            max_x = device_array.shape[1] if max_x == \"end\" else max_x\n            max_y = device_array.shape[0] if max_y == \"end\" else max_y\n\n            if min_x &gt;= max_x or min_y &gt;= max_y:\n                raise ValueError(\n                    \"Invalid bounds: min values must be less than max values. \"\n                    + f\"Got min_x={min_x}, max_x={max_x}, min_y={min_y}, max_y={max_y}\"\n                )\n\n            device_array = device_array[\n                device_array.shape[0] - max_y : device_array.shape[0] - min_y,\n                min_x:max_x,\n            ]\n\n        _ = cv2.imwrite(img_path, (255 * device_array).astype(np.uint8))\n        print(f\"Saved Device image to '{img_path}'\")\n\n    def to_gds(\n        self,\n        gds_path: str = \"prefab_device.gds\",\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ) -&gt; None:\n        \"\"\"\n        Exports the device geometry as a GDSII file.\n\n        This method converts the device geometry into a format suitable for GDSII files.\n        The conversion involves contour approximation to simplify the geometry while\n        preserving essential features.\n\n        Parameters\n        ----------\n        gds_path : str\n            The path where the GDSII file will be saved. If not specified, the file is\n            saved as \"prefab_device.gds\" in the current directory.\n        cell_name : str\n            The name of the cell within the GDSII file. If not specified, defaults to\n            \"prefab_device\".\n        gds_layer : tuple[int, int]\n            The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n        contour_approx_mode : int\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        origin : tuple[float, float]\n            The x and y coordinates of the origin in \u00b5m for the GDSII export. Defaults\n            to (0.0, 0.0).\n        \"\"\"\n        gdstk_cell = self.flatten()._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n            origin=origin,\n        )\n        print(f\"Saving GDS to '{gds_path}'...\")\n        gdstk_library = gdstk.Library()\n        _ = gdstk_library.add(gdstk_cell)\n        gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n\n    def to_gdstk(\n        self,\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ) -&gt; gdstk.Cell:\n        \"\"\"\n        Converts the device geometry to a GDSTK cell object.\n\n        This method prepares the device geometry for GDSII file export by converting it\n        into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n        GDSII layout files. The conversion involves contour approximation to simplify\n        the geometry while preserving essential features.\n\n        Parameters\n        ----------\n        cell_name : str\n            The name of the cell to be created. Defaults to \"prefab_device\".\n        gds_layer : tuple[int, int]\n            The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n        contour_approx_mode : int\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        origin : tuple[float, float]\n            The x and y coordinates of the origin in \u00b5m for the GDSTK cell. Defaults\n            to (0.0, 0.0).\n\n        Returns\n        -------\n        gdstk.Cell\n            The GDSTK cell object representing the device geometry.\n        \"\"\"\n        # print(f\"Creating cell '{cell_name}'...\")\n        gdstk_cell = self.flatten()._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n            origin=origin,\n        )\n        return gdstk_cell\n\n    def _device_to_gdstk(\n        self,\n        cell_name: str,\n        gds_layer: tuple[int, int],\n        contour_approx_mode: int,\n        origin: tuple[float, float],\n    ) -&gt; gdstk.Cell:\n        approx_mode_mapping = {\n            1: cv2.CHAIN_APPROX_NONE,\n            2: cv2.CHAIN_APPROX_SIMPLE,\n            3: cv2.CHAIN_APPROX_TC89_L1,\n            4: cv2.CHAIN_APPROX_TC89_KCOS,\n        }\n\n        contours, hierarchy = cv2.findContours(\n            np.flipud(self.to_ndarray()).astype(np.uint8),\n            cv2.RETR_TREE,\n            approx_mode_mapping[contour_approx_mode],\n        )\n\n        hierarchy_polygons = {}\n        for idx, contour in enumerate(contours):\n            level = 0\n            current_idx = idx\n            while hierarchy[0][current_idx][3] != -1:\n                level += 1\n                current_idx = hierarchy[0][current_idx][3]\n\n            if len(contour) &gt; 2:\n                contour = contour / 1000\n                points = [tuple(point) for point in contour.squeeze().tolist()]\n                if level not in hierarchy_polygons:\n                    hierarchy_polygons[level] = []\n                hierarchy_polygons[level].append(points)\n\n        cell = gdstk.Cell(cell_name)\n        processed_polygons = []\n        for level in sorted(hierarchy_polygons.keys()):\n            operation = \"or\" if level % 2 == 0 else \"xor\"\n            polygons_to_process = hierarchy_polygons[level]\n\n            if polygons_to_process:\n                buffer_thickness = self.buffer_spec.thickness\n\n                center_x_nm = (\n                    self.device_array.shape[1]\n                    - buffer_thickness[\"left\"]\n                    - buffer_thickness[\"right\"]\n                ) / 2\n                center_y_nm = (\n                    self.device_array.shape[0]\n                    - buffer_thickness[\"top\"]\n                    - buffer_thickness[\"bottom\"]\n                ) / 2\n\n                center_x_um = center_x_nm / 1000\n                center_y_um = center_y_nm / 1000\n\n                adjusted_polygons = [\n                    gdstk.Polygon(\n                        [\n                            (x - center_x_um + origin[0], y - center_y_um + origin[1])\n                            for x, y in polygon\n                        ]\n                    )\n                    for polygon in polygons_to_process\n                ]\n                processed_polygons = gdstk.boolean(\n                    adjusted_polygons,\n                    processed_polygons,\n                    operation,\n                    layer=gds_layer[0],\n                    datatype=gds_layer[1],\n                )\n        for polygon in processed_polygons:\n            _ = cell.add(polygon)\n\n        return cell\n\n    def to_3d(self, thickness_nm: int) -&gt; npt.NDArray[Any]:\n        \"\"\"\n        Convert the 2D device geometry into a 3D representation.\n\n        This method creates a 3D array by interpolating between the bottom and top\n        layers of the device geometry. The interpolation is linear.\n\n        Parameters\n        ----------\n        thickness_nm : int\n            The thickness of the 3D representation in nanometers.\n\n        Returns\n        -------\n        np.ndarray\n            A 3D narray representing the device geometry with the specified thickness.\n        \"\"\"\n        bottom_layer = self.device_array[:, :, 0]\n        top_layer = self.device_array[:, :, -1]\n        dt_bottom = np.array(distance_transform_edt(bottom_layer)) - np.array(\n            distance_transform_edt(1 - bottom_layer)\n        )\n        dt_top = np.array(distance_transform_edt(top_layer)) - np.array(\n            distance_transform_edt(1 - top_layer)\n        )\n        weights = np.linspace(0, 1, thickness_nm)\n        layered_array = np.zeros(\n            (bottom_layer.shape[0], bottom_layer.shape[1], thickness_nm)\n        )\n        for i, w in enumerate(weights):\n            dt_interp = (1 - w) * dt_bottom + w * dt_top\n            layered_array[:, :, i] = dt_interp &gt;= 0\n        return layered_array\n\n    def _plot_base(\n        self,\n        plot_array: npt.NDArray[Any],\n        show_buffer: bool,\n        bounds: tuple[tuple[int, int], tuple[int, int]] | None,\n        ax: Axes | None,\n        **kwargs: Any,\n    ) -&gt; tuple[plt.cm.ScalarMappable, Axes]:\n        if ax is None:\n            _, ax = plt.subplots()\n        _ = ax.set_ylabel(\"y (nm)\")\n        _ = ax.set_xlabel(\"x (nm)\")\n\n        min_x, min_y = (0, 0) if bounds is None else bounds[0]\n        max_x, max_y = plot_array.shape[::-1] if bounds is None else bounds[1]\n\n        # Handle negative indices (count from end)\n        if min_x &lt; 0:\n            min_x = plot_array.shape[1] + min_x\n        if min_y &lt; 0:\n            min_y = plot_array.shape[0] + min_y\n        if max_x != \"end\" and max_x &lt; 0:\n            max_x = plot_array.shape[1] + max_x\n        if max_y != \"end\" and max_y &lt; 0:\n            max_y = plot_array.shape[0] + max_y\n\n        # Clamp to valid range\n        min_x = max(min_x, 0)\n        min_y = max(min_y, 0)\n        max_x = \"end\" if max_x == \"end\" else min(max_x, plot_array.shape[1])\n        max_y = \"end\" if max_y == \"end\" else min(max_y, plot_array.shape[0])\n        max_x = plot_array.shape[1] if max_x == \"end\" else max_x\n        max_y = plot_array.shape[0] if max_y == \"end\" else max_y\n        plot_array = plot_array[\n            plot_array.shape[0] - max_y : plot_array.shape[0] - min_y,\n            min_x:max_x,\n        ]\n\n        if not np.ma.is_masked(plot_array):\n            max_size = (1000, 1000)\n            scale_x = min(1, max_size[0] / plot_array.shape[1])\n            scale_y = min(1, max_size[1] / plot_array.shape[0])\n            fx = min(scale_x, scale_y)\n            fy = fx\n\n            plot_array = cv2.resize(\n                plot_array,\n                dsize=(0, 0),\n                fx=fx,\n                fy=fy,\n                interpolation=cv2.INTER_NEAREST,\n            )\n\n        mappable = ax.imshow(\n            plot_array,\n            extent=(\n                float(min_x),\n                float(max_x),\n                float(min_y),\n                float(max_y),\n            ),\n            **kwargs,\n        )\n\n        if show_buffer:\n            self._add_buffer_visualization(ax)\n\n        # # Adjust colorbar font size if a colorbar is added\n        # if \"cmap\" in kwargs:\n        #     cbar = plt.colorbar(mappable, ax=ax)\n        #     cbar.ax.tick_params(labelsize=14)\n        #     if \"label\" in kwargs:\n        #         cbar.set_label(kwargs[\"label\"], fontsize=16)\n\n        return mappable, ax\n\n    def plot(\n        self,\n        show_buffer: bool = True,\n        bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n        level: int | None = None,\n        ax: Axes | None = None,\n        **kwargs: Any,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the device geometry.\n\n        This method allows for the visualization of the device geometry. The\n        visualization can be customized with various matplotlib parameters and can be\n        drawn on an existing matplotlib Axes object or create a new one if none is\n        provided.\n\n        Parameters\n        ----------\n        show_buffer : bool\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n            (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n            to \"end\", it will be replaced with the corresponding dimension size of the\n            device array. If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the device geometry on. If\n            None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the plot. This object can be used for\n            further plot customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            plot_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            plot_array = self.device_array[:, :, level]\n        _, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        return ax\n\n    def plot_contour(\n        self,\n        linewidth: int | None = None,\n        # label: str | None = \"Device contour\",\n        show_buffer: bool = True,\n        bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n        level: int | None = None,\n        ax: Axes | None = None,\n        **kwargs: Any,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the contour of the device geometry.\n\n        This method plots the contour of the device geometry, emphasizing the edges and\n        boundaries of the device. The contour plot can be customized with various\n        matplotlib parameters, including line width and color. The plot can be drawn on\n        an existing matplotlib Axes object or create a new one if none is provided.\n\n        Parameters\n        ----------\n        linewidth : Optional[int]\n            The width of the contour lines. If None, the linewidth is automatically\n            determined based on the size of the device array. Defaults to None.\n        show_buffer : bool\n            If True, the buffer zones around the device will be visualized. By default,\n            it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n            (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n            to \"end\", it will be replaced with the corresponding dimension size of the\n            device array. If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the device contour on. If None, a\n            new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the contour plot. This can be used for\n            further customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            device_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            device_array = self.device_array[:, :, level]\n\n        kwargs.setdefault(\"cmap\", \"spring\")\n        linewidth_value = (\n            linewidth if linewidth is not None else device_array.shape[0] // 100\n        )\n\n        contours, _ = cv2.findContours(\n            geometry.binarize_hard(device_array).astype(np.uint8),\n            cv2.RETR_CCOMP,\n            cv2.CHAIN_APPROX_SIMPLE,\n        )\n        contour_array = np.zeros_like(device_array, dtype=np.uint8)\n        _ = cv2.drawContours(contour_array, contours, -1, (255,), linewidth_value)\n        contour_array = np.ma.masked_equal(contour_array, 0)\n\n        _, ax = self._plot_base(\n            plot_array=contour_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n        # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n        # ax.legend([legend_proxy], [label], loc=\"upper right\")\n        return ax\n\n    def plot_uncertainty(\n        self,\n        show_buffer: bool = True,\n        bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n        level: int | None = None,\n        ax: Axes | None = None,\n        **kwargs: Any,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the uncertainty in the edge positions of the predicted device.\n\n        This method plots the uncertainty associated with the positions of the edges of\n        the device. The uncertainty is represented as a gradient, with areas of higher\n        uncertainty indicating a greater likelihood of the edge position from run to run\n        (due to inconsistencies in the fabrication process). This visualization can help\n        in identifying areas within the device geometry that may require design\n        adjustments to improve fabrication consistency.\n\n        Parameters\n        ----------\n        show_buffer : bool\n            If True, the buffer zones around the device will also be visualized. By\n            default, it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n            (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n            to \"end\", it will be replaced with the corresponding dimension size of the\n            device array. If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the uncertainty visualization on.\n            If None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the uncertainty visualization. This\n            can be used for further customization or saving the plot after the method\n            returns.\n        \"\"\"\n        uncertainty_array = self.get_uncertainty()\n\n        if level is None:\n            uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n        else:\n            uncertainty_array = uncertainty_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=uncertainty_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Uncertainty (a.u.)\")\n        return ax\n\n    def plot_compare(\n        self,\n        ref_device: \"Device\",\n        show_buffer: bool = True,\n        bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n        level: int | None = None,\n        ax: Axes | None = None,\n        **kwargs: Any,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the comparison between the current device geometry and a reference\n        device geometry.\n\n        Positive values (dilation) and negative values (erosion) are visualized with a\n        color map to indicate areas where the current device has expanded or contracted\n        relative to the reference.\n\n        Parameters\n        ----------\n        ref_device : Device\n            The reference device to compare against.\n        show_buffer : bool\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n            (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n            to \"end\", it will be replaced with the corresponding dimension size of the\n            device array. If None, the entire device geometry is visualized.\n        level : int\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes]\n            An existing matplotlib Axes object to draw the comparison on. If None, a new\n            figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the comparison plot. This object can\n            be used for further plot customization or saving the plot after the method\n            returns.\n        \"\"\"\n        plot_array = ref_device.device_array - self.device_array\n\n        if level is None:\n            plot_array = geometry.flatten(plot_array)[:, :, 0]\n        else:\n            plot_array = plot_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            cmap=\"jet\",\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n        return ax\n\n    def _add_buffer_visualization(self, ax: Axes) -&gt; None:\n        plot_array = self.device_array\n\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_fill = (0, 1, 0, 0.2)\n        buffer_hatch = \"/\"\n\n        mid_rect = Rectangle(\n            (buffer_thickness[\"left\"], buffer_thickness[\"top\"]),\n            plot_array.shape[1] - buffer_thickness[\"left\"] - buffer_thickness[\"right\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=\"none\",\n            edgecolor=\"black\",\n            linewidth=1,\n        )\n        _ = ax.add_patch(mid_rect)\n\n        top_rect = Rectangle(\n            (0, 0),\n            plot_array.shape[1],\n            buffer_thickness[\"top\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        _ = ax.add_patch(top_rect)\n\n        bottom_rect = Rectangle(\n            (0, plot_array.shape[0] - buffer_thickness[\"bottom\"]),\n            plot_array.shape[1],\n            buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        _ = ax.add_patch(bottom_rect)\n\n        left_rect = Rectangle(\n            (0, buffer_thickness[\"top\"]),\n            buffer_thickness[\"left\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        _ = ax.add_patch(left_rect)\n\n        right_rect = Rectangle(\n            (\n                plot_array.shape[1] - buffer_thickness[\"right\"],\n                buffer_thickness[\"top\"],\n            ),\n            buffer_thickness[\"right\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        _ = ax.add_patch(right_rect)\n\n    def normalize(self) -&gt; \"Device\":\n        \"\"\"\n        Normalize the device geometry.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the normalized geometry.\n        \"\"\"\n        normalized_device_array = geometry.normalize(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": normalized_device_array})\n\n    def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry based on a threshold and a scaling factor.\n\n        Parameters\n        ----------\n        eta : float\n            The threshold value for binarization. Defaults to 0.5.\n        beta : float\n            The scaling factor for the binarization process. A higher value makes the\n            transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize(\n            device_array=self.device_array, eta=eta, beta=beta\n        )\n        return self.model_copy(\n            update={\"device_array\": binarized_device_array.astype(np.uint8)}\n        )\n\n    def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n        \"\"\"\n        Apply a hard threshold to binarize the device geometry. The `binarize` function\n        is generally preferred for most use cases, but it can create numerical artifacts\n        for large beta values.\n\n        Parameters\n        ----------\n        eta : float\n            The threshold value for binarization. Defaults to 0.5.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the threshold-binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_hard(\n            device_array=self.device_array, eta=eta\n        )\n        return self.model_copy(\n            update={\"device_array\": binarized_device_array.astype(np.uint8)}\n        )\n\n    def binarize_with_roughness(\n        self,\n        noise_magnitude: float = 2.0,\n        blur_radius: float = 8.0,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Binarize the input ndarray using a dynamic thresholding approach to simulate\n        surfaceroughness.\n\n        This function applies a dynamic thresholding technique where the threshold value\n        is determined by a base value perturbed by Gaussian-distributed random noise.\n        Thethreshold is then spatially varied across the array using Gaussian blurring,\n        simulating a potentially more realistic scenario where the threshold is not\n        uniform across the device.\n\n        Notes\n        -----\n        This is a temporary solution, where the defaults are chosen based on what looks\n        good. A better, data-driven approach is needed.\n\n        Parameters\n        ----------\n        noise_magnitude : float\n            The standard deviation of the Gaussian distribution used to generate noise\n            for the threshold values. This controls the amount of randomness in the\n            threshold. Defaults to 2.0.\n        blur_radius : float\n            The standard deviation for the Gaussian kernel used in blurring the\n            threshold map. This controls the spatial variation of the threshold across\n            the array. Defaults to 9.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_with_roughness(\n            device_array=self.device_array,\n            noise_magnitude=noise_magnitude,\n            blur_radius=blur_radius,\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n        \"\"\"\n        Ternarize the device geometry based on two thresholds. This function is useful\n        for flattened devices with angled sidewalls (i.e., three segments).\n\n        Parameters\n        ----------\n        eta1 : float\n            The first threshold value for ternarization. Defaults to 1/3.\n        eta2 : float\n            The second threshold value for ternarization. Defaults to 2/3.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the ternarized geometry.\n        \"\"\"\n        ternarized_device_array = geometry.ternarize(\n            device_array=self.flatten().device_array, eta1=eta1, eta2=eta2\n        )\n        return self.model_copy(update={\"device_array\": ternarized_device_array})\n\n    def trim(self) -&gt; \"Device\":\n        \"\"\"\n        Trim the device geometry by removing empty space around it.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the trimmed geometry.\n        \"\"\"\n        trimmed_device_array = geometry.trim(\n            device_array=self.device_array,\n            buffer_thickness=self.buffer_spec.thickness,\n        )\n        return self.model_copy(update={\"device_array\": trimmed_device_array})\n\n    def pad(self, pad_width: int) -&gt; \"Device\":\n        \"\"\"\n        Pad the device geometry with a specified width on all sides.\n        \"\"\"\n        padded_device_array = geometry.pad(\n            device_array=self.device_array, pad_width=pad_width\n        )\n        return self.model_copy(update={\"device_array\": padded_device_array})\n\n    def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n        \"\"\"\n        Apply Gaussian blur to the device geometry and normalize the result.\n\n        Parameters\n        ----------\n        sigma : float\n            The standard deviation for the Gaussian kernel. This controls the amount of\n            blurring. Defaults to 1.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the blurred and normalized geometry.\n        \"\"\"\n        blurred_device_array = geometry.blur(\n            device_array=self.device_array, sigma=sigma\n        )\n        return self.model_copy(update={\"device_array\": blurred_device_array})\n\n    def rotate(self, angle: float) -&gt; \"Device\":\n        \"\"\"\n        Rotate the device geometry by a given angle.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation in degrees. Positive values mean counter-clockwise\n            rotation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the rotated geometry.\n        \"\"\"\n        rotated_device_array = geometry.rotate(\n            device_array=self.device_array, angle=angle\n        )\n        return self.model_copy(update={\"device_array\": rotated_device_array})\n\n    def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Erode the device geometry by removing small areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for erosion.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the eroded geometry.\n        \"\"\"\n        eroded_device_array = geometry.erode(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": eroded_device_array})\n\n    def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Dilate the device geometry by expanding areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for dilation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the dilated geometry.\n        \"\"\"\n        dilated_device_array = geometry.dilate(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": dilated_device_array})\n\n    def flatten(self) -&gt; \"Device\":\n        \"\"\"\n        Flatten the device geometry by summing the vertical layers and normalizing the\n        result.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the flattened geometry.\n        \"\"\"\n        flattened_device_array = geometry.flatten(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": flattened_device_array})\n\n    def get_uncertainty(self) -&gt; npt.NDArray[Any]:\n        \"\"\"\n        Calculate the uncertainty in the edge positions of the predicted device.\n\n        This method computes the uncertainty based on the deviation of the device's\n        geometry values from the midpoint (0.5). The uncertainty is defined as the\n        absolute difference from 0.5, scaled and inverted to provide a measure where\n        higher values indicate greater uncertainty.\n\n        Returns\n        -------\n        np.ndarray\n            An array representing the uncertainty in the edge positions of the device,\n            with higher values indicating greater uncertainty.\n        \"\"\"\n        return 1 - 2 * np.abs(0.5 - self.device_array)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.is_binary","title":"<code>is_binary</code>  <code>property</code>","text":"<p>Check if the device geometry is binary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device geometry is binary, False otherwise.</p>"},{"location":"reference/device/#prefab.device.Device.__init__","title":"<code>__init__(device_array, buffer_spec=None)</code>","text":"<p>Represents the planar geometry of a photonic device design that will have its nanofabrication outcome predicted and/or corrected.</p> <p>This class is designed to encapsulate the geometric representation of a photonic device, facilitating operations such as padding, normalization, binarization, erosion/dilation, trimming, and blurring. These operations are useful for preparingthe device design for prediction or correction. Additionally, the class providesmethods for exporting the device representation to various formats, includingndarray, image files, and GDSII files, supporting a range of analysis and fabrication workflows.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device. This array undergoes various transformations to predict or correct the nanofabrication process.</p> required <code>buffer_spec</code> <code>Optional[BufferSpec]</code> <p>Defines the parameters for adding a buffer zone around the device geometry. This buffer zone is needed for providing surrounding context for prediction or correction and for ensuring seamless integration with the surrounding circuitry. By default, a generous padding is applied to accommodate isolated structures.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple[int, int]</code> <p>The shape of the device array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided <code>device_array</code> is not a numpy ndarray or is not a 2D array, indicating an invalid device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def __init__(\n    self, device_array: npt.NDArray[Any], buffer_spec: BufferSpec | None = None\n):\n    \"\"\"\n    Represents the planar geometry of a photonic device design that will have its\n    nanofabrication outcome predicted and/or corrected.\n\n    This class is designed to encapsulate the geometric representation of a photonic\n    device, facilitating operations such as padding, normalization, binarization,\n    erosion/dilation, trimming, and blurring. These operations are useful for\n    preparingthe device design for prediction or correction. Additionally, the class\n    providesmethods for exporting the device representation to various formats,\n    includingndarray, image files, and GDSII files, supporting a range of analysis\n    and fabrication workflows.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array\n        undergoes various transformations to predict or correct the nanofabrication\n        process.\n    buffer_spec : Optional[BufferSpec]\n        Defines the parameters for adding a buffer zone around the device geometry.\n        This buffer zone is needed for providing surrounding context for prediction\n        or correction and for ensuring seamless integration with the surrounding\n        circuitry. By default, a generous padding is applied to accommodate isolated\n        structures.\n\n    Attributes\n    ----------\n    shape : tuple[int, int]\n        The shape of the device array.\n\n    Raises\n    ------\n    ValueError\n        If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n        indicating an invalid device geometry.\n    \"\"\"\n    super().__init__(\n        device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n    )\n    self._initial_processing()\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize","title":"<code>binarize(eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the device geometry based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize(\n        device_array=self.device_array, eta=eta, beta=beta\n    )\n    return self.model_copy(\n        update={\"device_array\": binarized_device_array.astype(np.uint8)}\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_hard","title":"<code>binarize_hard(eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the device geometry. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the threshold-binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n    \"\"\"\n    Apply a hard threshold to binarize the device geometry. The `binarize` function\n    is generally preferred for most use cases, but it can create numerical artifacts\n    for large beta values.\n\n    Parameters\n    ----------\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the threshold-binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_hard(\n        device_array=self.device_array, eta=eta\n    )\n    return self.model_copy(\n        update={\"device_array\": binarized_device_array.astype(np.uint8)}\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_with_roughness","title":"<code>binarize_with_roughness(noise_magnitude=2.0, blur_radius=8.0)</code>","text":"<p>Binarize the input ndarray using a dynamic thresholding approach to simulate surfaceroughness.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. Thethreshold is then spatially varied across the array using Gaussian blurring, simulating a potentially more realistic scenario where the threshold is not uniform across the device.</p> Notes <p>This is a temporary solution, where the defaults are chosen based on what looks good. A better, data-driven approach is needed.</p> <p>Parameters:</p> Name Type Description Default <code>noise_magnitude</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold. Defaults to 2.0.</p> <code>2.0</code> <code>blur_radius</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array. Defaults to 9.0.</p> <code>8.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_with_roughness(\n    self,\n    noise_magnitude: float = 2.0,\n    blur_radius: float = 8.0,\n) -&gt; \"Device\":\n    \"\"\"\n    Binarize the input ndarray using a dynamic thresholding approach to simulate\n    surfaceroughness.\n\n    This function applies a dynamic thresholding technique where the threshold value\n    is determined by a base value perturbed by Gaussian-distributed random noise.\n    Thethreshold is then spatially varied across the array using Gaussian blurring,\n    simulating a potentially more realistic scenario where the threshold is not\n    uniform across the device.\n\n    Notes\n    -----\n    This is a temporary solution, where the defaults are chosen based on what looks\n    good. A better, data-driven approach is needed.\n\n    Parameters\n    ----------\n    noise_magnitude : float\n        The standard deviation of the Gaussian distribution used to generate noise\n        for the threshold values. This controls the amount of randomness in the\n        threshold. Defaults to 2.0.\n    blur_radius : float\n        The standard deviation for the Gaussian kernel used in blurring the\n        threshold map. This controls the spatial variation of the threshold across\n        the array. Defaults to 9.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_with_roughness(\n        device_array=self.device_array,\n        noise_magnitude=noise_magnitude,\n        blur_radius=blur_radius,\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.blur","title":"<code>blur(sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the device geometry and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the blurred and normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n    \"\"\"\n    Apply Gaussian blur to the device geometry and normalize the result.\n\n    Parameters\n    ----------\n    sigma : float\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the blurred and normalized geometry.\n    \"\"\"\n    blurred_device_array = geometry.blur(\n        device_array=self.device_array, sigma=sigma\n    )\n    return self.model_copy(update={\"device_array\": blurred_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.correct","title":"<code>correct(model, binarize=True)</code>","text":"<p>Correct the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless correction service, which uses a specified machine learning model to correct the outcome of the nanofabrication process. The correction aims to adjust the device geometry to compensate for known fabrication errors and improve the accuracy of the final device structure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for correction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry and process, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the correction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the corrected device geometry will be binarized using a threshold method. This is useful for converting probabilistic corrections into binary geometries. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the corrected geometry.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the correction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def correct(\n    self,\n    model: Model,\n    binarize: bool = True,\n) -&gt; \"Device\":\n    \"\"\"\n    Correct the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless correction service, which\n    uses a specified machine learning model to correct the outcome of the\n    nanofabrication process. The correction aims to adjust the device geometry to\n    compensate for known fabrication errors and improve the accuracy of the final\n    device structure.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for correction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry\n        and process, as defined in `models.py`. Each model is associated with a\n        version and dataset that detail its creation and the data it was trained on,\n        ensuring the correction is tailored to specific fabrication parameters.\n    binarize : bool\n        If True, the corrected device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic corrections into binary\n        geometries. Defaults to True.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the corrected geometry.\n\n    Raises\n    ------\n    RuntimeError\n        If the correction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    correction_array = predict_array(\n        device_array=self.device_array,\n        model=model,\n        model_type=\"c\",\n        binarize=binarize,\n    )\n    return self.model_copy(update={\"device_array\": correction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.dilate","title":"<code>dilate(kernel_size=3)</code>","text":"<p>Dilate the device geometry by expanding areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the dilated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Dilate the device geometry by expanding areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the dilated geometry.\n    \"\"\"\n    dilated_device_array = geometry.dilate(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": dilated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.erode","title":"<code>erode(kernel_size=3)</code>","text":"<p>Erode the device geometry by removing small areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the eroded geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Erode the device geometry by removing small areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the eroded geometry.\n    \"\"\"\n    eroded_device_array = geometry.erode(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": eroded_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.flatten","title":"<code>flatten()</code>","text":"<p>Flatten the device geometry by summing the vertical layers and normalizing the result.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the flattened geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def flatten(self) -&gt; \"Device\":\n    \"\"\"\n    Flatten the device geometry by summing the vertical layers and normalizing the\n    result.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the flattened geometry.\n    \"\"\"\n    flattened_device_array = geometry.flatten(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": flattened_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.get_uncertainty","title":"<code>get_uncertainty()</code>","text":"<p>Calculate the uncertainty in the edge positions of the predicted device.</p> <p>This method computes the uncertainty based on the deviation of the device's geometry values from the midpoint (0.5). The uncertainty is defined as the absolute difference from 0.5, scaled and inverted to provide a measure where higher values indicate greater uncertainty.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing the uncertainty in the edge positions of the device, with higher values indicating greater uncertainty.</p> Source code in <code>prefab/device.py</code> <pre><code>def get_uncertainty(self) -&gt; npt.NDArray[Any]:\n    \"\"\"\n    Calculate the uncertainty in the edge positions of the predicted device.\n\n    This method computes the uncertainty based on the deviation of the device's\n    geometry values from the midpoint (0.5). The uncertainty is defined as the\n    absolute difference from 0.5, scaled and inverted to provide a measure where\n    higher values indicate greater uncertainty.\n\n    Returns\n    -------\n    np.ndarray\n        An array representing the uncertainty in the edge positions of the device,\n        with higher values indicating greater uncertainty.\n    \"\"\"\n    return 1 - 2 * np.abs(0.5 - self.device_array)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the device geometry.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def normalize(self) -&gt; \"Device\":\n    \"\"\"\n    Normalize the device geometry.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the normalized geometry.\n    \"\"\"\n    normalized_device_array = geometry.normalize(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": normalized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.pad","title":"<code>pad(pad_width)</code>","text":"<p>Pad the device geometry with a specified width on all sides.</p> Source code in <code>prefab/device.py</code> <pre><code>def pad(self, pad_width: int) -&gt; \"Device\":\n    \"\"\"\n    Pad the device geometry with a specified width on all sides.\n    \"\"\"\n    padded_device_array = geometry.pad(\n        device_array=self.device_array, pad_width=pad_width\n    )\n    return self.model_copy(update={\"device_array\": padded_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot","title":"<code>plot(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the device geometry.</p> <p>This method allows for the visualization of the device geometry. The visualization can be customized with various matplotlib parameters and can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). Negative values count from the end (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device geometry on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot(\n    self,\n    show_buffer: bool = True,\n    bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n    level: int | None = None,\n    ax: Axes | None = None,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the device geometry.\n\n    This method allows for the visualization of the device geometry. The\n    visualization can be customized with various matplotlib parameters and can be\n    drawn on an existing matplotlib Axes object or create a new one if none is\n    provided.\n\n    Parameters\n    ----------\n    show_buffer : bool\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n        (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n        to \"end\", it will be replaced with the corresponding dimension size of the\n        device array. If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the device geometry on. If\n        None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the plot. This object can be used for\n        further plot customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        plot_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        plot_array = self.device_array[:, :, level]\n    _, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_compare","title":"<code>plot_compare(ref_device, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the comparison between the current device geometry and a reference device geometry.</p> <p>Positive values (dilation) and negative values (erosion) are visualized with a color map to indicate areas where the current device has expanded or contracted relative to the reference.</p> <p>Parameters:</p> Name Type Description Default <code>ref_device</code> <code>Device</code> <p>The reference device to compare against.</p> required <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). Negative values count from the end (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the comparison on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the comparison plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_compare(\n    self,\n    ref_device: \"Device\",\n    show_buffer: bool = True,\n    bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n    level: int | None = None,\n    ax: Axes | None = None,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the comparison between the current device geometry and a reference\n    device geometry.\n\n    Positive values (dilation) and negative values (erosion) are visualized with a\n    color map to indicate areas where the current device has expanded or contracted\n    relative to the reference.\n\n    Parameters\n    ----------\n    ref_device : Device\n        The reference device to compare against.\n    show_buffer : bool\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n        (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n        to \"end\", it will be replaced with the corresponding dimension size of the\n        device array. If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the comparison on. If None, a new\n        figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the comparison plot. This object can\n        be used for further plot customization or saving the plot after the method\n        returns.\n    \"\"\"\n    plot_array = ref_device.device_array - self.device_array\n\n    if level is None:\n        plot_array = geometry.flatten(plot_array)[:, :, 0]\n    else:\n        plot_array = plot_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        cmap=\"jet\",\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_contour","title":"<code>plot_contour(linewidth=None, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the contour of the device geometry.</p> <p>This method plots the contour of the device geometry, emphasizing the edges and boundaries of the device. The contour plot can be customized with various matplotlib parameters, including line width and color. The plot can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>linewidth</code> <code>Optional[int]</code> <p>The width of the contour lines. If None, the linewidth is automatically determined based on the size of the device array. Defaults to None.</p> <code>None</code> <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). Negative values count from the end (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device contour on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the contour plot. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_contour(\n    self,\n    linewidth: int | None = None,\n    # label: str | None = \"Device contour\",\n    show_buffer: bool = True,\n    bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n    level: int | None = None,\n    ax: Axes | None = None,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the contour of the device geometry.\n\n    This method plots the contour of the device geometry, emphasizing the edges and\n    boundaries of the device. The contour plot can be customized with various\n    matplotlib parameters, including line width and color. The plot can be drawn on\n    an existing matplotlib Axes object or create a new one if none is provided.\n\n    Parameters\n    ----------\n    linewidth : Optional[int]\n        The width of the contour lines. If None, the linewidth is automatically\n        determined based on the size of the device array. Defaults to None.\n    show_buffer : bool\n        If True, the buffer zones around the device will be visualized. By default,\n        it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n        (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n        to \"end\", it will be replaced with the corresponding dimension size of the\n        device array. If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the device contour on. If None, a\n        new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the contour plot. This can be used for\n        further customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        device_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        device_array = self.device_array[:, :, level]\n\n    kwargs.setdefault(\"cmap\", \"spring\")\n    linewidth_value = (\n        linewidth if linewidth is not None else device_array.shape[0] // 100\n    )\n\n    contours, _ = cv2.findContours(\n        geometry.binarize_hard(device_array).astype(np.uint8),\n        cv2.RETR_CCOMP,\n        cv2.CHAIN_APPROX_SIMPLE,\n    )\n    contour_array = np.zeros_like(device_array, dtype=np.uint8)\n    _ = cv2.drawContours(contour_array, contours, -1, (255,), linewidth_value)\n    contour_array = np.ma.masked_equal(contour_array, 0)\n\n    _, ax = self._plot_base(\n        plot_array=contour_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n    # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n    # ax.legend([legend_proxy], [label], loc=\"upper right\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_uncertainty","title":"<code>plot_uncertainty(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the uncertainty in the edge positions of the predicted device.</p> <p>This method plots the uncertainty associated with the positions of the edges of the device. The uncertainty is represented as a gradient, with areas of higher uncertainty indicating a greater likelihood of the edge position from run to run (due to inconsistencies in the fabrication process). This visualization can help in identifying areas within the device geometry that may require design adjustments to improve fabrication consistency.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will also be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). Negative values count from the end (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the uncertainty visualization on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the uncertainty visualization. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_uncertainty(\n    self,\n    show_buffer: bool = True,\n    bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n    level: int | None = None,\n    ax: Axes | None = None,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the uncertainty in the edge positions of the predicted device.\n\n    This method plots the uncertainty associated with the positions of the edges of\n    the device. The uncertainty is represented as a gradient, with areas of higher\n    uncertainty indicating a greater likelihood of the edge position from run to run\n    (due to inconsistencies in the fabrication process). This visualization can help\n    in identifying areas within the device geometry that may require design\n    adjustments to improve fabrication consistency.\n\n    Parameters\n    ----------\n    show_buffer : bool\n        If True, the buffer zones around the device will also be visualized. By\n        default, it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n        (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n        to \"end\", it will be replaced with the corresponding dimension size of the\n        device array. If None, the entire device geometry is visualized.\n    level : int\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes]\n        An existing matplotlib Axes object to draw the uncertainty visualization on.\n        If None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the uncertainty visualization. This\n        can be used for further customization or saving the plot after the method\n        returns.\n    \"\"\"\n    uncertainty_array = self.get_uncertainty()\n\n    if level is None:\n        uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n    else:\n        uncertainty_array = uncertainty_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=uncertainty_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Uncertainty (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.predict","title":"<code>predict(model, binarize=False)</code>","text":"<p>Predict the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry and process, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the predicted device geometry will be binarized using a threshold method. This is useful for converting probabilistic predictions into binary geometries. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the predicted geometry.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the prediction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def predict(\n    self,\n    model: Model,\n    binarize: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Predict the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless prediction service, which\n    uses a specified machine learning model to predict the outcome of the\n    nanofabrication process.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for prediction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry\n        and process, as defined in `models.py`. Each model is associated with a\n        version and dataset that detail its creation and the data it was trained on,\n        ensuring the prediction is tailored to specific fabrication parameters.\n    binarize : bool\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries. Defaults to False.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the predicted geometry.\n\n    Raises\n    ------\n    RuntimeError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    prediction_array = predict_array(\n        device_array=self.device_array,\n        model=model,\n        model_type=\"p\",\n        binarize=binarize,\n    )\n    return self.model_copy(update={\"device_array\": prediction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.rotate","title":"<code>rotate(angle)</code>","text":"<p>Rotate the device geometry by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the rotated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def rotate(self, angle: float) -&gt; \"Device\":\n    \"\"\"\n    Rotate the device geometry by a given angle.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the rotated geometry.\n    \"\"\"\n    rotated_device_array = geometry.rotate(\n        device_array=self.device_array, angle=angle\n    )\n    return self.model_copy(update={\"device_array\": rotated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.ternarize","title":"<code>ternarize(eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the device geometry based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the ternarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n    \"\"\"\n    Ternarize the device geometry based on two thresholds. This function is useful\n    for flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    eta1 : float\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the ternarized geometry.\n    \"\"\"\n    ternarized_device_array = geometry.ternarize(\n        device_array=self.flatten().device_array, eta1=eta1, eta2=eta2\n    )\n    return self.model_copy(update={\"device_array\": ternarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_3d","title":"<code>to_3d(thickness_nm)</code>","text":"<p>Convert the 2D device geometry into a 3D representation.</p> <p>This method creates a 3D array by interpolating between the bottom and top layers of the device geometry. The interpolation is linear.</p> <p>Parameters:</p> Name Type Description Default <code>thickness_nm</code> <code>int</code> <p>The thickness of the 3D representation in nanometers.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D narray representing the device geometry with the specified thickness.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_3d(self, thickness_nm: int) -&gt; npt.NDArray[Any]:\n    \"\"\"\n    Convert the 2D device geometry into a 3D representation.\n\n    This method creates a 3D array by interpolating between the bottom and top\n    layers of the device geometry. The interpolation is linear.\n\n    Parameters\n    ----------\n    thickness_nm : int\n        The thickness of the 3D representation in nanometers.\n\n    Returns\n    -------\n    np.ndarray\n        A 3D narray representing the device geometry with the specified thickness.\n    \"\"\"\n    bottom_layer = self.device_array[:, :, 0]\n    top_layer = self.device_array[:, :, -1]\n    dt_bottom = np.array(distance_transform_edt(bottom_layer)) - np.array(\n        distance_transform_edt(1 - bottom_layer)\n    )\n    dt_top = np.array(distance_transform_edt(top_layer)) - np.array(\n        distance_transform_edt(1 - top_layer)\n    )\n    weights = np.linspace(0, 1, thickness_nm)\n    layered_array = np.zeros(\n        (bottom_layer.shape[0], bottom_layer.shape[1], thickness_nm)\n    )\n    for i, w in enumerate(weights):\n        dt_interp = (1 - w) * dt_bottom + w * dt_top\n        layered_array[:, :, i] = dt_interp &gt;= 0\n    return layered_array\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gds","title":"<code>to_gds(gds_path='prefab_device.gds', cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2, origin=(0.0, 0.0))</code>","text":"<p>Exports the device geometry as a GDSII file.</p> <p>This method converts the device geometry into a format suitable for GDSII files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The path where the GDSII file will be saved. If not specified, the file is saved as \"prefab_device.gds\" in the current directory.</p> <code>'prefab_device.gds'</code> <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDSII file. If not specified, defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSII file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> <code>origin</code> <code>tuple[float, float]</code> <p>The x and y coordinates of the origin in \u00b5m for the GDSII export. Defaults to (0.0, 0.0).</p> <code>(0.0, 0.0)</code> Source code in <code>prefab/device.py</code> <pre><code>def to_gds(\n    self,\n    gds_path: str = \"prefab_device.gds\",\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n    origin: tuple[float, float] = (0.0, 0.0),\n) -&gt; None:\n    \"\"\"\n    Exports the device geometry as a GDSII file.\n\n    This method converts the device geometry into a format suitable for GDSII files.\n    The conversion involves contour approximation to simplify the geometry while\n    preserving essential features.\n\n    Parameters\n    ----------\n    gds_path : str\n        The path where the GDSII file will be saved. If not specified, the file is\n        saved as \"prefab_device.gds\" in the current directory.\n    cell_name : str\n        The name of the cell within the GDSII file. If not specified, defaults to\n        \"prefab_device\".\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n    contour_approx_mode : int\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    origin : tuple[float, float]\n        The x and y coordinates of the origin in \u00b5m for the GDSII export. Defaults\n        to (0.0, 0.0).\n    \"\"\"\n    gdstk_cell = self.flatten()._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n        origin=origin,\n    )\n    print(f\"Saving GDS to '{gds_path}'...\")\n    gdstk_library = gdstk.Library()\n    _ = gdstk_library.add(gdstk_cell)\n    gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gdstk","title":"<code>to_gdstk(cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2, origin=(0.0, 0.0))</code>","text":"<p>Converts the device geometry to a GDSTK cell object.</p> <p>This method prepares the device geometry for GDSII file export by converting it into a GDSTK cell object. GDSTK is a Python module for creating and manipulating GDSII layout files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>The name of the cell to be created. Defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> <code>origin</code> <code>tuple[float, float]</code> <p>The x and y coordinates of the origin in \u00b5m for the GDSTK cell. Defaults to (0.0, 0.0).</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Type Description <code>Cell</code> <p>The GDSTK cell object representing the device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdstk(\n    self,\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n    origin: tuple[float, float] = (0.0, 0.0),\n) -&gt; gdstk.Cell:\n    \"\"\"\n    Converts the device geometry to a GDSTK cell object.\n\n    This method prepares the device geometry for GDSII file export by converting it\n    into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n    GDSII layout files. The conversion involves contour approximation to simplify\n    the geometry while preserving essential features.\n\n    Parameters\n    ----------\n    cell_name : str\n        The name of the cell to be created. Defaults to \"prefab_device\".\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    contour_approx_mode : int\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    origin : tuple[float, float]\n        The x and y coordinates of the origin in \u00b5m for the GDSTK cell. Defaults\n        to (0.0, 0.0).\n\n    Returns\n    -------\n    gdstk.Cell\n        The GDSTK cell object representing the device geometry.\n    \"\"\"\n    # print(f\"Creating cell '{cell_name}'...\")\n    gdstk_cell = self.flatten()._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n        origin=origin,\n    )\n    return gdstk_cell\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_img","title":"<code>to_img(img_path='prefab_device.png', bounds=None)</code>","text":"<p>Exports the device geometry as an image file.</p> <p>This method converts the device geometry to an ndarray using <code>to_ndarray</code>, scales the values to the range [0, 255] for image representation, and saves the result as an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path where the image file will be saved. If not specified, the image is saved as \"prefab_device.png\" in the current directory.</p> <code>'prefab_device.png'</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for cropping the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). Negative values count from the end (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is exported.</p> <code>None</code> Source code in <code>prefab/device.py</code> <pre><code>def to_img(\n    self,\n    img_path: str = \"prefab_device.png\",\n    bounds: tuple[tuple[int, int], tuple[int, int]] | None = None,\n) -&gt; None:\n    \"\"\"\n    Exports the device geometry as an image file.\n\n    This method converts the device geometry to an ndarray using `to_ndarray`,\n    scales the values to the range [0, 255] for image representation, and saves the\n    result as an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path where the image file will be saved. If not specified, the image is\n        saved as \"prefab_device.png\" in the current directory.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]]\n        Specifies the bounds for cropping the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). Negative values count from the end\n        (e.g., -50 means 50 pixels from the edge). If 'max_x' or 'max_y' is set\n        to \"end\", it will be replaced with the corresponding dimension size of the\n        device array. If None, the entire device geometry is exported.\n    \"\"\"\n    device_array = self.flatten().to_ndarray()\n\n    if bounds is not None:\n        min_x, min_y = bounds[0]\n        max_x, max_y = bounds[1]\n\n        # Handle negative indices (count from end)\n        if min_x &lt; 0:\n            min_x = device_array.shape[1] + min_x\n        if min_y &lt; 0:\n            min_y = device_array.shape[0] + min_y\n        if max_x != \"end\" and max_x &lt; 0:\n            max_x = device_array.shape[1] + max_x\n        if max_y != \"end\" and max_y &lt; 0:\n            max_y = device_array.shape[0] + max_y\n\n        # Clamp to valid range\n        min_x = max(min_x, 0)\n        min_y = max(min_y, 0)\n        max_x = \"end\" if max_x == \"end\" else min(max_x, device_array.shape[1])\n        max_y = \"end\" if max_y == \"end\" else min(max_y, device_array.shape[0])\n        max_x = device_array.shape[1] if max_x == \"end\" else max_x\n        max_y = device_array.shape[0] if max_y == \"end\" else max_y\n\n        if min_x &gt;= max_x or min_y &gt;= max_y:\n            raise ValueError(\n                \"Invalid bounds: min values must be less than max values. \"\n                + f\"Got min_x={min_x}, max_x={max_x}, min_y={min_y}, max_y={max_y}\"\n            )\n\n        device_array = device_array[\n            device_array.shape[0] - max_y : device_array.shape[0] - min_y,\n            min_x:max_x,\n        ]\n\n    _ = cv2.imwrite(img_path, (255 * device_array).astype(np.uint8))\n    print(f\"Saved Device image to '{img_path}'\")\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_ndarray","title":"<code>to_ndarray()</code>","text":"<p>Converts the device geometry to an ndarray.</p> <p>This method applies the buffer specifications to crop the device array if necessary, based on the buffer mode ('edge' or 'constant'). It then returns the resulting ndarray representing the device geometry.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ndarray representation of the device geometry, with any applied buffer cropping.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_ndarray(self) -&gt; npt.NDArray[Any]:\n    \"\"\"\n    Converts the device geometry to an ndarray.\n\n    This method applies the buffer specifications to crop the device array if\n    necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n    resulting ndarray representing the device geometry.\n\n    Returns\n    -------\n    np.ndarray\n        The ndarray representation of the device geometry, with any applied buffer\n        cropping.\n    \"\"\"\n    device_array = np.copy(self.device_array)\n    buffer_thickness = self.buffer_spec.thickness\n\n    crop_top = buffer_thickness[\"top\"]\n    crop_bottom = buffer_thickness[\"bottom\"]\n    crop_left = buffer_thickness[\"left\"]\n    crop_right = buffer_thickness[\"right\"]\n\n    ndarray = device_array[\n        crop_top : device_array.shape[0] - crop_bottom,\n        crop_left : device_array.shape[1] - crop_right,\n    ]\n    return ndarray\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.trim","title":"<code>trim()</code>","text":"<p>Trim the device geometry by removing empty space around it.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the trimmed geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def trim(self) -&gt; \"Device\":\n    \"\"\"\n    Trim the device geometry by removing empty space around it.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the trimmed geometry.\n    \"\"\"\n    trimmed_device_array = geometry.trim(\n        device_array=self.device_array,\n        buffer_thickness=self.buffer_spec.thickness,\n    )\n    return self.model_copy(update={\"device_array\": trimmed_device_array})\n</code></pre>"},{"location":"reference/geometry/","title":"Geometry","text":"<p>Functions for manipulating and transforming device geometry arrays.</p> <p>This module provides utilities for common geometric operations on numpy arrays representing device geometries, including normalization, binarization, trimming, padding, blurring, rotation, morphological operations (erosion/dilation), and flattening. All functions operate on npt.NDArray[np.float64] arrays.</p>"},{"location":"reference/geometry/#prefab.geometry.binarize","title":"<code>binarize(device_array, eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the input ndarray based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The binarized array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize(\n    device_array: npt.NDArray[np.float64], eta: float = 0.5, beta: float = np.inf\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Binarize the input ndarray based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be binarized.\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The binarized array with elements scaled to 0 or 1.\n    \"\"\"\n    return cast(\n        npt.NDArray[np.float64],\n        (np.tanh(beta * eta) + np.tanh(beta * (device_array - eta)))\n        / (np.tanh(beta * eta) + np.tanh(beta * (1 - eta))),\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_hard","title":"<code>binarize_hard(device_array, eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the input ndarray. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The binarized array with elements set to 0 or 1 based on the threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_hard(\n    device_array: npt.NDArray[np.float64], eta: float = 0.5\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Apply a hard threshold to binarize the input ndarray. The `binarize` function is\n    generally preferred for most use cases, but it can create numerical artifacts for\n    large beta values.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be binarized.\n    eta : float\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The binarized array with elements set to 0 or 1 based on the threshold.\n    \"\"\"\n    return np.where(device_array &lt; eta, 0.0, 1.0)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_with_roughness","title":"<code>binarize_with_roughness(device_array, noise_magnitude, blur_radius)</code>","text":"<p>Binarize the input ndarray using a dynamic thresholding approach to simulate surface roughness.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the array using Gaussian blurring, simulating a potentially more realistic scenario where the threshold is not uniform across the device.</p> Notes <p>This is a temporary solution, where the defaults are chosen based on what looks good. A better, data-driven approach is needed.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be binarized.</p> required <code>noise_magnitude</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold.</p> required <code>blur_radius</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The binarized array with elements set to 0 or 1 based on the dynamically generated threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_with_roughness(\n    device_array: npt.NDArray[np.float64],\n    noise_magnitude: float,\n    blur_radius: float,\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Binarize the input ndarray using a dynamic thresholding approach to simulate surface\n    roughness.\n\n    This function applies a dynamic thresholding technique where the threshold value is\n    determined by a base value perturbed by Gaussian-distributed random noise. The\n    threshold is then spatially varied across the array using Gaussian blurring,\n    simulating a potentially more realistic scenario where the threshold is not uniform\n    across the device.\n\n    Notes\n    -----\n    This is a temporary solution, where the defaults are chosen based on what looks\n    good. A better, data-driven approach is needed.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be binarized.\n    noise_magnitude : float\n        The standard deviation of the Gaussian distribution used to generate noise for\n        the threshold values. This controls the amount of randomness in the threshold.\n    blur_radius : float\n        The standard deviation for the Gaussian kernel used in blurring the threshold\n        map. This controls the spatial variation of the threshold across the array.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The binarized array with elements set to 0 or 1 based on the dynamically\n        generated threshold.\n    \"\"\"\n    device_array = np.squeeze(device_array)\n    base_threshold_raw = float(np.random.normal(loc=0.5, scale=0.1))\n    base_threshold = max(0.2, min(base_threshold_raw, 0.8))\n    threshold_noise = np.random.normal(\n        loc=0, scale=noise_magnitude, size=device_array.shape\n    )\n    spatial_threshold: npt.NDArray[np.float64] = cv2.GaussianBlur(\n        threshold_noise, ksize=(0, 0), sigmaX=blur_radius\n    ).astype(np.float64)\n    dynamic_threshold: npt.NDArray[np.float64] = base_threshold + spatial_threshold\n    binarized_array = np.where(device_array &lt; dynamic_threshold, 0.0, 1.0)\n    binarized_array = np.expand_dims(binarized_array, axis=-1)\n    return binarized_array\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.blur","title":"<code>blur(device_array, sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the input ndarray and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be blurred.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The blurred and normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def blur(\n    device_array: npt.NDArray[np.float64], sigma: float = 1.0\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Apply Gaussian blur to the input ndarray and normalize the result.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be blurred.\n    sigma : float\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The blurred and normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return np.expand_dims(\n        normalize(\n            cv2.GaussianBlur(device_array, ksize=(0, 0), sigmaX=sigma).astype(\n                np.float64\n            )\n        ),\n        axis=-1,\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.dilate","title":"<code>dilate(device_array, kernel_size)</code>","text":"<p>Dilate the input ndarray using a specified kernel size.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array representing the device geometry to be dilated.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The dilated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def dilate(\n    device_array: npt.NDArray[np.float64], kernel_size: int\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Dilate the input ndarray using a specified kernel size.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array representing the device geometry to be dilated.\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The dilated array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return np.expand_dims(\n        cv2.dilate(device_array, kernel=kernel).astype(np.float64), axis=-1\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.erode","title":"<code>erode(device_array, kernel_size)</code>","text":"<p>Erode the input ndarray using a specified kernel size and number of iterations.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array representing the device geometry to be eroded.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The eroded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def erode(\n    device_array: npt.NDArray[np.float64], kernel_size: int\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Erode the input ndarray using a specified kernel size and number of iterations.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array representing the device geometry to be eroded.\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The eroded array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return np.expand_dims(\n        cv2.erode(device_array, kernel=kernel).astype(np.float64), axis=-1\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.flatten","title":"<code>flatten(device_array)</code>","text":"<p>Flatten the input ndarray by summing the vertical layers and normalizing the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be flattened.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The flattened array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def flatten(device_array: npt.NDArray[np.float64]) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Flatten the input ndarray by summing the vertical layers and normalizing the result.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be flattened.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The flattened array with values scaled between 0 and 1.\n    \"\"\"\n    return normalize(\n        cast(npt.NDArray[np.float64], np.sum(device_array, axis=-1, keepdims=True))\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.normalize","title":"<code>normalize(device_array)</code>","text":"<p>Normalize the input ndarray to have values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be normalized.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def normalize(device_array: npt.NDArray[np.float64]) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Normalize the input ndarray to have values between 0 and 1.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be normalized.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return (device_array - np.min(device_array)) / (\n        np.max(device_array) - np.min(device_array)\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.pad","title":"<code>pad(device_array, pad_width)</code>","text":"<p>Pad the input ndarray uniformly with a specified width on all sides.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be padded.</p> required <code>pad_width</code> <code>int</code> <p>The number of pixels to pad on each side.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The padded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def pad(\n    device_array: npt.NDArray[np.float64], pad_width: int\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Pad the input ndarray uniformly with a specified width on all sides.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be padded.\n    pad_width : int\n        The number of pixels to pad on each side.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The padded array.\n    \"\"\"\n    return np.pad(\n        device_array,\n        pad_width=((pad_width, pad_width), (pad_width, pad_width), (0, 0)),\n        mode=\"constant\",\n        constant_values=0,\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.rotate","title":"<code>rotate(device_array, angle)</code>","text":"<p>Rotate the input ndarray by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be rotated.</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The rotated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def rotate(\n    device_array: npt.NDArray[np.float64], angle: float\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Rotate the input ndarray by a given angle.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be rotated.\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The rotated array.\n    \"\"\"\n    center = (device_array.shape[1] / 2, device_array.shape[0] / 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center=center, angle=angle, scale=1)\n    return np.expand_dims(\n        cv2.warpAffine(\n            device_array,\n            M=rotation_matrix,\n            dsize=(device_array.shape[1], device_array.shape[0]),\n        ).astype(np.float64),\n        axis=-1,\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.ternarize","title":"<code>ternarize(device_array, eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the input ndarray based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be ternarized.</p> required <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def ternarize(\n    device_array: npt.NDArray[np.float64], eta1: float = 1 / 3, eta2: float = 2 / 3\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Ternarize the input ndarray based on two thresholds. This function is useful for\n    flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be ternarized.\n    eta1 : float\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.\n    \"\"\"\n    return np.where(device_array &lt; eta1, 0.0, np.where(device_array &gt;= eta2, 1.0, 0.5))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.trim","title":"<code>trim(device_array, buffer_thickness=None)</code>","text":"<p>Trim the input ndarray by removing rows and columns that are completely zero.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>NDArray[float64]</code> <p>The input array to be trimmed.</p> required <code>buffer_thickness</code> <code>Optional[dict[str, int]]</code> <p>A dictionary specifying the thickness of the buffer to leave around the non-zero elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'. Defaults to None, which means no buffer is added.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The trimmed array, potentially with a buffer around the non-zero elements.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def trim(\n    device_array: npt.NDArray[np.float64],\n    buffer_thickness: dict[str, int] | None = None,\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Trim the input ndarray by removing rows and columns that are completely zero.\n\n    Parameters\n    ----------\n    device_array : npt.NDArray[np.float64]\n        The input array to be trimmed.\n    buffer_thickness : Optional[dict[str, int]]\n        A dictionary specifying the thickness of the buffer to leave around the non-zero\n        elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'.\n        Defaults to None, which means no buffer is added.\n\n    Returns\n    -------\n    npt.NDArray[np.float64]\n        The trimmed array, potentially with a buffer around the non-zero elements.\n    \"\"\"\n    if buffer_thickness is None:\n        buffer_thickness = {\"top\": 0, \"bottom\": 0, \"left\": 0, \"right\": 0}\n\n    nonzero_indices = np.nonzero(np.squeeze(device_array))\n    nonzero_rows = nonzero_indices[0]\n    nonzero_cols = nonzero_indices[1]\n\n    row_min_val = int(nonzero_rows.min())\n    row_max_val = int(nonzero_rows.max())\n    col_min_val = int(nonzero_cols.min())\n    col_max_val = int(nonzero_cols.max())\n\n    row_min = max(row_min_val - buffer_thickness.get(\"top\", 0), 0)\n    row_max = min(\n        row_max_val + buffer_thickness.get(\"bottom\", 0) + 1, device_array.shape[0]\n    )\n    col_min = max(col_min_val - buffer_thickness.get(\"left\", 0), 0)\n    col_max = min(\n        col_max_val + buffer_thickness.get(\"right\", 0) + 1, device_array.shape[1]\n    )\n    return device_array[\n        row_min:row_max,\n        col_min:col_max,\n    ]\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>Fabrication process model definitions and configurations.</p> <p>This module automatically discovers and loads all model definitions from Python files in the models/ directory.</p>"},{"location":"reference/models/#prefab.models.Fab","title":"<code>Fab</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a fabrication process in the PreFab model library.</p> <p>Attributes:</p> Name Type Description <code>foundry</code> <code>str</code> <p>The name of the foundry where the fabrication process takes place.</p> <code>process</code> <code>str</code> <p>The specific process used in the fabrication.</p> Source code in <code>prefab/models/base.py</code> <pre><code>class Fab(BaseModel):\n    \"\"\"\n    Represents a fabrication process in the PreFab model library.\n\n    Attributes\n    ----------\n    foundry : str\n        The name of the foundry where the fabrication process takes place.\n    process : str\n        The specific process used in the fabrication.\n    \"\"\"\n\n    foundry: str\n    process: str\n</code></pre>"},{"location":"reference/models/#prefab.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a model of a fabrication process including versioning and dataset detail.</p> <p>Attributes:</p> Name Type Description <code>fab</code> <code>Fab</code> <p>An instance of the Fab class representing the fabrication details.</p> <code>version</code> <code>str</code> <p>The version identifier of the model.</p> <code>version_date</code> <code>date</code> <p>The release date of this version of the model.</p> <code>dataset</code> <code>str</code> <p>The identifier for the dataset used in this model.</p> <code>dataset_date</code> <code>date</code> <p>The date when the dataset was last updated or released.</p> <code>tag</code> <code>str</code> <p>An optional tag for additional categorization or notes.</p> <p>Methods:</p> Name Description <code>to_json</code> <p>Serializes the model instance to a JSON formatted string.</p> Source code in <code>prefab/models/base.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Represents a model of a fabrication process including versioning and dataset detail.\n\n    Attributes\n    ----------\n    fab : Fab\n        An instance of the Fab class representing the fabrication details.\n    version : str\n        The version identifier of the model.\n    version_date : date\n        The release date of this version of the model.\n    dataset : str\n        The identifier for the dataset used in this model.\n    dataset_date : date\n        The date when the dataset was last updated or released.\n    tag : str\n        An optional tag for additional categorization or notes.\n\n    Methods\n    -------\n    to_json()\n        Serializes the model instance to a JSON formatted string.\n    \"\"\"\n\n    fab: Fab\n    version: str\n    version_date: date\n    dataset: str\n    dataset_date: date\n    tag: str\n\n    def to_json(self):\n        return json.dumps(self.model_dump(), default=str)\n</code></pre>"},{"location":"reference/predict/","title":"Predict","text":"<p>Serverless prediction interface for nanofabrication modeling.</p> <p>This module provides functions for predicting nanofabrication outcomes using machine learning models hosted on a serverless platform. It supports multiple input formats (ndarrays, polygons, GDSII files) and model types (prediction and correction). Gradient computation is available for inverse design applications using automatic differentiation.</p>"},{"location":"reference/predict/#prefab.predict.predict_array_with_grad","title":"<code>predict_array_with_grad = predict_array_diff</code>  <code>module-attribute</code>","text":"<p>Alias for predict_array_diff. Deprecated, use predict_array_diff directly.</p>"},{"location":"reference/predict/#prefab.predict.differentiable","title":"<code>differentiable(model)</code>","text":"<p>Create a model-bound differentiable predictor for clean autograd integration.</p> <p>Returns a function that takes only <code>device_array</code> as input, enabling seamless composition with other differentiable functions. The VJP returns a single gradient array (not a tuple), making it compatible with standard autograd workflows.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for prediction.</p> required <p>Returns:</p> Type Description <code>callable</code> <p>A differentiable prediction function that takes <code>device_array</code> and returns the predicted fabrication outcome.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; predictor = pf.predict.differentiable(model)\n&gt;&gt;&gt; def loss_fn(x):\n...     pred = predictor(x)\n...     return np.mean((pred - target) ** 2)\n&gt;&gt;&gt; gradient = grad(loss_fn)(device_array)  # Returns array, not tuple\n</code></pre> Source code in <code>prefab/predict.py</code> <pre><code>def differentiable(model: Model):\n    \"\"\"\n    Create a model-bound differentiable predictor for clean autograd integration.\n\n    Returns a function that takes only `device_array` as input, enabling seamless\n    composition with other differentiable functions. The VJP returns a single\n    gradient array (not a tuple), making it compatible with standard autograd workflows.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for prediction.\n\n    Returns\n    -------\n    callable\n        A differentiable prediction function that takes `device_array` and returns\n        the predicted fabrication outcome.\n\n    Examples\n    --------\n    &gt;&gt;&gt; predictor = pf.predict.differentiable(model)\n    &gt;&gt;&gt; def loss_fn(x):\n    ...     pred = predictor(x)\n    ...     return np.mean((pred - target) ** 2)\n    &gt;&gt;&gt; gradient = grad(loss_fn)(device_array)  # Returns array, not tuple\n    \"\"\"\n\n    @primitive\n    def predict(device_array: npt.NDArray[Any]) -&gt; npt.NDArray[Any]:\n        prediction = predict_array(\n            device_array=device_array,\n            model=model,\n            model_type=\"p\",\n            binarize=False,\n        )\n        _diff_cache[id(prediction)] = (device_array.copy(), model)\n        return prediction\n\n    def predict_vjp(\n        ans: npt.NDArray[Any], device_array: npt.NDArray[Any]\n    ) -&gt; Any:\n        cache_key = id(ans)\n        cached_device_array, cached_model = _diff_cache.get(\n            cache_key, (device_array, model)\n        )\n\n        def vjp(g: npt.NDArray[Any]) -&gt; npt.NDArray[Any]:\n            vjp_result = _compute_vjp(\n                device_array=cached_device_array,\n                upstream_gradient=g,\n                model=cached_model,\n            )\n            _diff_cache.pop(cache_key, None)\n            # Ensure gradient shape matches input shape\n            return vjp_result.reshape(device_array.shape)\n\n        return vjp\n\n    defvjp(predict, predict_vjp)\n    return predict\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_array","title":"<code>predict_array(device_array, model, model_type, binarize)</code>","text":"<p>Predict the nanofabrication outcome of a device array using a specified model.</p> <p>This function sends the device array to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device. This array undergoes various transformations to predict the nanofabrication process.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry and process, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>model_type</code> <code>str</code> <p>The type of model to use (e.g., 'p' for prediction or 'c' for correction).</p> required <code>binarize</code> <code>bool</code> <p>If True, the predicted device geometry will be binarized using a threshold method. This is useful for converting probabilistic predictions into binary geometries.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The predicted output array. For single-level predictions, returns shape (h, w, 1). For multi-level predictions, returns shape (h, w, n) where n is the number of levels.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the request to the prediction service fails.</p> <code>ValueError</code> <p>If the server returns an error or invalid response.</p> Source code in <code>prefab/predict.py</code> <pre><code>def predict_array(\n    device_array: npt.NDArray[Any],\n    model: Model,\n    model_type: str,\n    binarize: bool,\n) -&gt; npt.NDArray[Any]:\n    \"\"\"\n    Predict the nanofabrication outcome of a device array using a specified model.\n\n    This function sends the device array to a serverless prediction service, which uses\n    a specified machine learning model to predict the outcome of the nanofabrication\n    process.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array undergoes\n        various transformations to predict the nanofabrication process.\n    model : Model\n        The model to use for prediction, representing a specific fabrication process and\n        dataset. This model encapsulates details about the fabrication foundry and\n        process, as defined in `models.py`. Each model is associated with a version and\n        dataset that detail its creation and the data it was trained on, ensuring the\n        prediction is tailored to specific fabrication parameters.\n    model_type : str\n        The type of model to use (e.g., 'p' for prediction or 'c' for correction).\n    binarize : bool\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries.\n\n    Returns\n    -------\n    np.ndarray\n        The predicted output array. For single-level predictions, returns shape\n        (h, w, 1). For multi-level predictions, returns shape (h, w, n) where n is the\n        number of levels.\n\n    Raises\n    ------\n    RuntimeError\n        If the request to the prediction service fails.\n    ValueError\n        If the server returns an error or invalid response.\n    \"\"\"\n    endpoint_url = PREDICT_ENDPOINT\n    predict_data = {\n        \"device_array\": _encode_array(np.squeeze(device_array)),\n        \"model\": model.to_json(),\n        \"model_type\": model_type,\n    }\n    headers = _prepare_headers()\n\n    try:\n        response = requests.post(\n            url=endpoint_url, data=json.dumps(predict_data), headers=headers\n        )\n        response.raise_for_status()\n\n        if not response.content:\n            raise ValueError(\"Empty response received from server\")\n\n        response_data = response.json()\n\n        if \"error\" in response_data:\n            raise ValueError(f\"Prediction error: {response_data['error']}\")\n\n        results = response_data[\"results\"]\n        result_arrays = [\n            _decode_array(results[key])\n            for key in sorted(results.keys())\n            if key.startswith(\"result\")\n        ]\n\n        prediction_array = np.stack(result_arrays, axis=-1)\n\n        if binarize:\n            prediction_array = binarize_hard(prediction_array)\n\n        return prediction_array\n\n    except requests.exceptions.RequestException as e:\n        raise RuntimeError(f\"Request failed: {e}\") from e\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"JSON decode error: {e}\") from e\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_array_diff","title":"<code>predict_array_diff(device_array, model)</code>","text":"<p>Differentiable fab prediction with exact gradient support.</p> <p>Compatible with autograd for automatic differentiation. Gradients are computed via a server-side VJP endpoint during the backward pass.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The predicted fabrication outcome array.</p> Source code in <code>prefab/predict.py</code> <pre><code>@primitive\ndef predict_array_diff(\n    device_array: npt.NDArray[Any], model: Model\n) -&gt; npt.NDArray[Any]:\n    \"\"\"\n    Differentiable fab prediction with exact gradient support.\n\n    Compatible with autograd for automatic differentiation. Gradients are computed via\n    a server-side VJP endpoint during the backward pass.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device.\n    model : Model\n        The model to use for prediction.\n\n    Returns\n    -------\n    np.ndarray\n        The predicted fabrication outcome array.\n    \"\"\"\n    # Use standard forward pass\n    prediction_array = predict_array(\n        device_array=device_array,\n        model=model,\n        model_type=\"p\",\n        binarize=False,\n    )\n\n    # Cache the input for VJP computation during backward pass\n    _diff_cache[id(prediction_array)] = (device_array.copy(), model)\n\n    return prediction_array\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_gds","title":"<code>predict_gds(gds_path, cell_name, model, model_type, gds_layer=(1, 0), eta=0.5, output_path=None)</code>","text":"<p>Predict the nanofabrication outcome for a GDS file and cell.</p> <p>This function loads a GDS file, extracts the specified cell, and predicts the nanofabrication outcome using the specified model. The predicted cell is automatically added to the original GDS library and the file is written to the specified output path (or overwrites the original if no output path is provided).</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The file path to the GDS file.</p> required <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDS file to predict.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry and process, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>model_type</code> <code>str</code> <p>The type of model to use (e.g., 'p' for prediction or 'c' for correction).</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDS file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5. Because intermediate values cannot be preserved in the polygon data, the predicted polygons are binarized using a threshold value of eta.</p> <code>0.5</code> <code>output_path</code> <code>str</code> <p>The file path where the updated GDS file will be written. If None, the original file will be overwritten. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the request to the prediction service fails.</p> <code>ValueError</code> <p>If the GDS file cannot be read, the specified cell is not found, or the server returns an error or invalid response.</p> Source code in <code>prefab/predict.py</code> <pre><code>def predict_gds(\n    gds_path: str,\n    cell_name: str,\n    model: Model,\n    model_type: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    eta: float = 0.5,\n    output_path: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Predict the nanofabrication outcome for a GDS file and cell.\n\n    This function loads a GDS file, extracts the specified cell, and predicts the\n    nanofabrication outcome using the specified model. The predicted cell is\n    automatically added to the original GDS library and the file is written to the\n    specified output path (or overwrites the original if no output path is provided).\n\n    Parameters\n    ----------\n    gds_path : str\n        The file path to the GDS file.\n    cell_name : str\n        The name of the cell within the GDS file to predict.\n    model : Model\n        The model to use for prediction, representing a specific fabrication process and\n        dataset. This model encapsulates details about the fabrication foundry and\n        process, as defined in `models.py`. Each model is associated with a version and\n        dataset that detail its creation and the data it was trained on, ensuring the\n        prediction is tailored to specific fabrication parameters.\n    model_type : str\n        The type of model to use (e.g., 'p' for prediction or 'c' for correction).\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDS file. Defaults to (1, 0).\n    eta : float\n        The threshold value for binarization. Defaults to 0.5. Because intermediate\n        values cannot be preserved in the polygon data, the predicted polygons are\n        binarized using a threshold value of eta.\n    output_path : str, optional\n        The file path where the updated GDS file will be written. If None, the\n        original file will be overwritten. Defaults to None.\n\n    Raises\n    ------\n    RuntimeError\n        If the request to the prediction service fails.\n    ValueError\n        If the GDS file cannot be read, the specified cell is not found, or the server\n        returns an error or invalid response.\n    \"\"\"\n    gdstk_library = gdstk.read_gds(gds_path)\n    cells = [\n        cell\n        for cell in gdstk_library.cells\n        if isinstance(cell, gdstk.Cell) and cell.name == cell_name\n    ]\n    if not cells:\n        raise ValueError(f\"Cell '{cell_name}' not found in GDS file\")\n    gdstk_cell = cells[0]\n\n    predicted_cell = predict_gdstk(\n        gdstk_cell=gdstk_cell,\n        model=model,\n        model_type=model_type,\n        gds_layer=gds_layer,\n        eta=eta,\n    )\n\n    base_name = predicted_cell.name\n    counter = 1\n    while predicted_cell.name in [cell.name for cell in gdstk_library.cells]:\n        predicted_cell.name = f\"{base_name}_{counter}\"\n        counter += 1\n\n    gdstk_library.add(predicted_cell)\n\n    write_path = output_path if output_path is not None else gds_path\n    print(f\"Writing to {write_path}\")\n    gdstk_library.write_gds(write_path, max_points=8190)\n</code></pre>"},{"location":"reference/predict/#prefab.predict.predict_gdstk","title":"<code>predict_gdstk(gdstk_cell, model, model_type, gds_layer=(1, 0), eta=0.5)</code>","text":"<p>Predict the nanofabrication outcome of a gdstk cell using a specified model.</p> <p>This function extracts polygons from a gdstk cell, sends them to a serverless prediction service, and returns a new cell containing the predicted polygons.</p> <p>Parameters:</p> Name Type Description Default <code>gdstk_cell</code> <code>Cell</code> <p>The gdstk.Cell object containing polygons to predict.</p> required <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry and process, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>model_type</code> <code>str</code> <p>The type of model to use (e.g., 'p' for prediction or 'c' for correction).</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5. Because intermediate values cannot be preserved in the polygon data, the predicted polygons are binarized using a threshold value of eta.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Cell</code> <p>A new gdstk cell containing the predicted polygons. For multi-level predictions, each level's polygons will be placed on a different layer: - Level 0: (layer, 99) - Level 1: (layer, 100)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the request to the prediction service fails.</p> <code>ValueError</code> <p>If no polygons are found in the specified layer, or the server returns an error or invalid response.</p> Source code in <code>prefab/predict.py</code> <pre><code>def predict_gdstk(\n    gdstk_cell: gdstk.Cell,\n    model: Model,\n    model_type: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    eta: float = 0.5,\n) -&gt; gdstk.Cell:\n    \"\"\"\n    Predict the nanofabrication outcome of a gdstk cell using a specified model.\n\n    This function extracts polygons from a gdstk cell, sends them to a serverless\n    prediction service, and returns a new cell containing the predicted polygons.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object containing polygons to predict.\n    model : Model\n        The model to use for prediction, representing a specific fabrication process and\n        dataset. This model encapsulates details about the fabrication foundry and\n        process, as defined in `models.py`. Each model is associated with a version and\n        dataset that detail its creation and the data it was trained on, ensuring the\n        prediction is tailored to specific fabrication parameters.\n    model_type : str\n        The type of model to use (e.g., 'p' for prediction or 'c' for correction).\n    gds_layer : tuple[int, int]\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    eta : float\n        The threshold value for binarization. Defaults to 0.5. Because intermediate\n        values cannot be preserved in the polygon data, the predicted polygons are\n        binarized using a threshold value of eta.\n\n    Returns\n    -------\n    gdstk.Cell\n        A new gdstk cell containing the predicted polygons. For multi-level\n        predictions, each level's polygons will be placed on a different layer:\n        - Level 0: (layer, 99)\n        - Level 1: (layer, 100)\n\n    Raises\n    ------\n    RuntimeError\n        If the request to the prediction service fails.\n    ValueError\n        If no polygons are found in the specified layer, or the server returns an error\n        or invalid response.\n    \"\"\"\n    polygons = gdstk_cell.get_polygons(layer=gds_layer[0], datatype=gds_layer[1])\n    if not polygons:\n        raise ValueError(\"No polygons found in the specified layer\")\n\n    polygon_points = [polygon.points.tolist() for polygon in polygons]  # pyright: ignore[reportAttributeAccessIssue]\n\n    predicted_polygon_data = _predict_poly(\n        polygon_points=polygon_points,\n        model=model,\n        model_type=model_type,\n        eta=eta,\n    )\n\n    suffix = \"corrected\" if model_type == \"c\" else \"predicted\"\n    result_cell = gdstk.Cell(f\"{gdstk_cell.name}_{suffix}\")\n\n    polygons_by_channel = {}\n    for polygon_data in predicted_polygon_data:\n        channel = polygon_data.get(\"channel\", 0)\n        points = polygon_data.get(\"points\", [])\n\n        if channel not in polygons_by_channel:\n            polygons_by_channel[channel] = []\n\n        polygons_by_channel[channel].append(points)\n\n    for channel, points_list in polygons_by_channel.items():\n        layer = gds_layer[0]\n        datatype = 99 + channel\n\n        for points in points_list:\n            points_array = np.array(points)\n            polygon = gdstk.Polygon(points_array, layer=layer, datatype=datatype)  # pyright: ignore[reportArgumentType]\n            result_cell.add(polygon)\n\n    return result_cell\n</code></pre>"},{"location":"reference/read/","title":"Read","text":"<p>Functions to create Device objects from various data sources.</p> <p>This module provides utilities for loading device geometries from multiple formats, including image files, numpy arrays, and GDS layout files. All functions return Device objects with optional preprocessing capabilities.</p>"},{"location":"reference/read/#prefab.read.from_gds","title":"<code>from_gds(gds_path, cell_name, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a GDS cell.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The file path to the GDS file.</p> required <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDS file to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the GDS file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>Optional[tuple[tuple[float, float], tuple[float, float]]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the specified cell from the GDS file, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gds(\n    gds_path: str,\n    cell_name: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[float, float], tuple[float, float]] | None = None,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a GDS cell.\n\n    Parameters\n    ----------\n    gds_path : str\n        The file path to the GDS file.\n    cell_name : str\n        The name of the cell within the GDS file to be converted into a Device object.\n    gds_layer : tuple[int, int]\n        A tuple specifying the layer and datatype to be used from the GDS file. Defaults\n        to (1, 0).\n    bounds : Optional[tuple[tuple[float, float], tuple[float, float]]]\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the specified cell from the GDS file, after\n        processing based on the specified layer.\n    \"\"\"\n    gdstk_library = gdstk.read_gds(gds_path)\n    gdstk_cell = cast(gdstk.Cell, gdstk_library[cell_name])  # pyright: ignore[reportIndexIssue]\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_gdstk","title":"<code>from_gdstk(gdstk_cell, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a gdstk cell.</p> <p>Parameters:</p> Name Type Description Default <code>gdstk_cell</code> <code>Cell</code> <p>The gdstk.Cell object to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>Optional[tuple[tuple[float, float], tuple[float, float]]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS cell. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the gdstk.Cell, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdstk(\n    gdstk_cell: gdstk.Cell,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[float, float], tuple[float, float]] | None = None,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a gdstk cell.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object to be converted into a Device object.\n    gds_layer : tuple[int, int]\n        A tuple specifying the layer and datatype to be used from the cell. Defaults to\n        (1, 0).\n    bounds : Optional[tuple[tuple[float, float], tuple[float, float]]]\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS cell. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdstk.Cell, after processing based on the\n        specified layer.\n    \"\"\"\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_img","title":"<code>from_img(img_path, img_width_nm=None, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path to the image file to be converted into a Device object.</p> required <code>img_width_nm</code> <code>Optional[int]</code> <p>The width of the image in nanometers. If specified, the Device will be resized to this width while maintaining aspect ratio. If None, no resizing is performed.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the image will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale images into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed image, after optional resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_img(\n    img_path: str, img_width_nm: int | None = None, binarize: bool = True, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path to the image file to be converted into a Device object.\n    img_width_nm : Optional[int]\n        The width of the image in nanometers. If specified, the Device will be resized\n        to this width while maintaining aspect ratio. If None, no resizing is performed.\n    binarize : bool\n        If True, the image will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed image, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = cv2.imread(img_path, flags=cv2.IMREAD_GRAYSCALE) / 255\n    if img_width_nm is not None:\n        resolution = img_width_nm / device_array.shape[1]\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=resolution, fy=resolution\n        )\n    device_array = _binarize_if_needed(device_array, binarize)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_ndarray","title":"<code>from_ndarray(ndarray, resolution=1.0, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <code>ndarray</code> <p>The input array representing the device geometry.</p> required <code>resolution</code> <code>float</code> <p>The resolution of the ndarray in nanometers per pixel, defaulting to 1.0 nm per pixel. If specified, the input array will be resized based on this resolution to match the desired physical size.</p> <code>1.0</code> <code>binarize</code> <code>bool</code> <p>If True, the input array will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale arrays into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the input array, after resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_ndarray(\n    ndarray: np.ndarray[Any, Any],\n    resolution: float = 1.0,\n    binarize: bool = True,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an ndarray.\n\n    Parameters\n    ----------\n    ndarray : np.ndarray\n        The input array representing the device geometry.\n    resolution : float\n        The resolution of the ndarray in nanometers per pixel, defaulting to 1.0 nm per\n        pixel. If specified, the input array will be resized based on this resolution to\n        match the desired physical size.\n    binarize : bool\n        If True, the input array will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale arrays\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the input array, after resizing and binarization.\n    \"\"\"\n    device_array = ndarray\n    if resolution != 1.0:\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=resolution, fy=resolution\n        )\n    device_array = _binarize_if_needed(device_array, binarize)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/","title":"Shapes","text":"<p>Shape generation functions for creating test device geometries.</p> <p>Provides functions for creating common shapes including rectangles, circles, gratings, polygons, and grid patterns. All functions return Device objects.</p>"},{"location":"reference/shapes/#prefab.shapes.cross","title":"<code>cross(width=200, height=None, arm_width=60, **kwargs)</code>","text":"<p>Create a Device object with a cross shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the cross. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the cross. Defaults to the value of width.</p> <code>None</code> <code>arm_width</code> <code>int</code> <p>The width of the cross arms. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the cross shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def cross(\n    width: int = 200, height: int | None = None, arm_width: int = 60, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a cross shape.\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the cross. Defaults to 200.\n    height : int | None\n        The overall height of the cross. Defaults to the value of width.\n    arm_width : int\n        The width of the cross arms. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the cross shape.\n    \"\"\"\n    height = _default_height(height, width)\n    shape_array = np.zeros((height, width))\n    center_x = width // 2\n    center_y = height // 2\n    half_arm_width = arm_width // 2\n    shape_array[center_y - half_arm_width : center_y + half_arm_width + 1, :] = 1\n    shape_array[:, center_x - half_arm_width : center_x + half_arm_width + 1] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disk","title":"<code>disk(width=200, height=None, **kwargs)</code>","text":"<p>Create a Device object with an elliptical shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the ellipse. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The height of the ellipse. Defaults to the value of width.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the elliptical shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disk(width: int = 200, height: int | None = None, **kwargs: Any) -&gt; Device:\n    \"\"\"\n    Create a Device object with an elliptical shape.\n\n    Parameters\n    ----------\n    width : int\n        The width of the ellipse. Defaults to 200.\n    height : int | None\n        The height of the ellipse. Defaults to the value of width.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the elliptical shape.\n    \"\"\"\n    height = _default_height(height, width)\n    mask, _, _ = _create_ellipse_mask(width, height)\n    shape_array = np.zeros((height, width))\n    shape_array[mask] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disk_wavy","title":"<code>disk_wavy(width=200, height=None, wave_amplitude=10, wave_frequency=10, **kwargs)</code>","text":"<p>Create a Device object with a circular shape with wavy edges.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the wavy circle. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the wavy circle. Defaults to the value of width.</p> <code>None</code> <code>wave_amplitude</code> <code>float</code> <p>The amplitude of the waves. Defaults to 10.</p> <code>10</code> <code>wave_frequency</code> <code>float</code> <p>The frequency of the waves. Defaults to 10.</p> <code>10</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the wavy circular shape.</p> Notes <p>The effective radius is reduced by wave_amplitude to ensure the wavy edges stay within the specified dimensions.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disk_wavy(\n    width: int = 200,\n    height: int | None = None,\n    wave_amplitude: float = 10,\n    wave_frequency: float = 10,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a circular shape with wavy edges.\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the wavy circle. Defaults to 200.\n    height : int | None\n        The overall height of the wavy circle. Defaults to the value of width.\n    wave_amplitude : float\n        The amplitude of the waves. Defaults to 10.\n    wave_frequency : float\n        The frequency of the waves. Defaults to 10.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the wavy circular shape.\n\n    Notes\n    -----\n    The effective radius is reduced by wave_amplitude to ensure the wavy\n    edges stay within the specified dimensions.\n    \"\"\"\n    height = _default_height(height, width)\n    size = min(width, height)\n    effective_radius = (size // 2) - wave_amplitude\n    y, x = np.ogrid[-size // 2 : size // 2, -size // 2 : size // 2]\n    distance_from_center = np.sqrt(x**2 + y**2)\n    sinusoidal_boundary = effective_radius + wave_amplitude * np.sin(\n        wave_frequency * np.arctan2(y, x)\n    )\n    mask = distance_from_center &lt;= sinusoidal_boundary\n    shape_array = np.zeros((size, size))\n    shape_array[mask] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disks","title":"<code>disks(rows=5, cols=5, disk_radius=30, spacing=60, **kwargs)</code>","text":"<p>Create a Device object with a grid of uniform disks.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>disk_radius</code> <code>int</code> <p>The radius of each disk. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between disk centers. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of disks.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disks(\n    rows: int = 5,\n    cols: int = 5,\n    disk_radius: int = 30,\n    spacing: int = 60,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of uniform disks.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    disk_radius : int\n        The radius of each disk. Defaults to 30.\n    spacing : int\n        The spacing between disk centers. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of disks.\n    \"\"\"\n    grid_height = rows * (2 * disk_radius + spacing) - spacing\n    grid_width = cols * (2 * disk_radius + spacing) - spacing\n    shape_array = np.zeros((grid_height, grid_width))\n\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * disk_radius + spacing) + disk_radius\n            center_x = col * (2 * disk_radius + spacing) + disk_radius\n            _place_disk_in_grid(shape_array, center_y, center_x, disk_radius, value=1.0)\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disks_offset","title":"<code>disks_offset(rows=5, cols=5, disk_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with an offset grid of disks.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>disk_radius</code> <code>int</code> <p>The radius of each disk. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between disk centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing an offset grid of disks.</p> Notes <p>Odd-numbered rows are shifted by (disk_radius + spacing // 2) to create an offset hexagonal packing pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disks_offset(\n    rows: int = 5,\n    cols: int = 5,\n    disk_radius: int = 30,\n    spacing: int = 30,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grid of disks.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    disk_radius : int\n        The radius of each disk. Defaults to 30.\n    spacing : int\n        The spacing between disk centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing an offset grid of disks.\n\n    Notes\n    -----\n    Odd-numbered rows are shifted by (disk_radius + spacing // 2) to create\n    an offset hexagonal packing pattern.\n    \"\"\"\n    grid_height = rows * (2 * disk_radius + spacing) - spacing\n    grid_width = (\n        cols * (2 * disk_radius + spacing) - spacing + (disk_radius + spacing // 2)\n    )\n    shape_array = np.zeros((grid_height, grid_width))\n\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * disk_radius + spacing) + disk_radius\n            offset_x = disk_radius + spacing // 2 if row % 2 == 1 else 0\n            center_x = col * (2 * disk_radius + spacing) + disk_radius + offset_x\n            _place_disk_in_grid(shape_array, center_y, center_x, disk_radius, value=1.0)\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.disks_varying","title":"<code>disks_varying(rows=5, cols=5, min_disk_radius=10, max_disk_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of disks with varying radii.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>min_disk_radius</code> <code>int</code> <p>The minimum radius of the disks. Defaults to 10.</p> <code>10</code> <code>max_disk_radius</code> <code>int</code> <p>The maximum radius of the disks. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between disk centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of disks with varying radii.</p> Notes <p>Disk radii vary linearly from min_disk_radius to max_disk_radius across the grid, progressing row by row, left to right.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def disks_varying(\n    rows: int = 5,\n    cols: int = 5,\n    min_disk_radius: int = 10,\n    max_disk_radius: int = 30,\n    spacing: int = 30,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of disks with varying radii.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    min_disk_radius : int\n        The minimum radius of the disks. Defaults to 10.\n    max_disk_radius : int\n        The maximum radius of the disks. Defaults to 30.\n    spacing : int\n        The spacing between disk centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of disks with varying radii.\n\n    Notes\n    -----\n    Disk radii vary linearly from min_disk_radius to max_disk_radius across\n    the grid, progressing row by row, left to right.\n    \"\"\"\n    grid_height = rows * (2 * max_disk_radius + spacing) - spacing\n    grid_width = cols * (2 * max_disk_radius + spacing) - spacing\n    shape_array = np.zeros((grid_height, grid_width))\n\n    radius_range = np.linspace(min_disk_radius, max_disk_radius, rows * cols).reshape(\n        rows, cols\n    )\n\n    for row in range(rows):\n        for col in range(cols):\n            disk_radius = int(radius_range[row, col])\n            center_y = row * (2 * max_disk_radius + spacing) + max_disk_radius\n            center_x = col * (2 * max_disk_radius + spacing) + max_disk_radius\n            _place_disk_in_grid(shape_array, center_y, center_x, disk_radius, value=1.0)\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.grating","title":"<code>grating(height=200, pitch=120, duty_cycle=0.5, num_gratings=3, **kwargs)</code>","text":"<p>Create a Device object with a grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height of the grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the grating. Defaults to 120.</p> <code>120</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the grating (fraction of pitch that is filled). Defaults to 0.5.</p> <code>0.5</code> <code>num_gratings</code> <code>int</code> <p>The number of grating periods. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the grating pattern.</p> Notes <p>The total width is calculated as pitch * num_gratings. Each grating line has width = pitch * duty_cycle.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def grating(\n    height: int = 200,\n    pitch: int = 120,\n    duty_cycle: float = 0.5,\n    num_gratings: int = 3,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grating pattern.\n\n    Parameters\n    ----------\n    height : int\n        The height of the grating. Defaults to 200.\n    pitch : int\n        The pitch (period) of the grating. Defaults to 120.\n    duty_cycle : float\n        The duty cycle of the grating (fraction of pitch that is filled). Defaults to\n        0.5.\n    num_gratings : int\n        The number of grating periods. Defaults to 3.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the grating pattern.\n\n    Notes\n    -----\n    The total width is calculated as pitch * num_gratings.\n    Each grating line has width = pitch * duty_cycle.\n    \"\"\"\n    width = pitch * num_gratings\n    shape_array = np.zeros((height, width))\n    grating_width = int(pitch * duty_cycle)\n    for i in range(num_gratings):\n        start = i * pitch\n        shape_array[:, start : start + grating_width] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes","title":"<code>holes(rows=5, cols=5, hole_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of uniform circular holes.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>hole_radius</code> <code>int</code> <p>The radius of each hole. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circular holes.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes(\n    rows: int = 5,\n    cols: int = 5,\n    hole_radius: int = 30,\n    spacing: int = 30,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of uniform circular holes.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    hole_radius : int\n        The radius of each hole. Defaults to 30.\n    spacing : int\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circular holes.\n    \"\"\"\n    grid_height = rows * (2 * hole_radius + spacing) - spacing\n    grid_width = cols * (2 * hole_radius + spacing) - spacing\n    shape_array = np.ones((grid_height, grid_width))\n\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * hole_radius + spacing) + hole_radius\n            center_x = col * (2 * hole_radius + spacing) + hole_radius\n            _place_disk_in_grid(shape_array, center_y, center_x, hole_radius, value=0.0)\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes_offset","title":"<code>holes_offset(rows=5, cols=5, hole_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with an offset grid of circular holes.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>hole_radius</code> <code>int</code> <p>The radius of each hole. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing an offset grid of circular holes.</p> Notes <p>Odd-numbered rows are shifted by (hole_radius + spacing // 2) to create an offset hexagonal packing pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes_offset(\n    rows: int = 5,\n    cols: int = 5,\n    hole_radius: int = 30,\n    spacing: int = 30,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grid of circular holes.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    hole_radius : int\n        The radius of each hole. Defaults to 30.\n    spacing : int\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing an offset grid of circular holes.\n\n    Notes\n    -----\n    Odd-numbered rows are shifted by (hole_radius + spacing // 2) to create\n    an offset hexagonal packing pattern.\n    \"\"\"\n    grid_height = rows * (2 * hole_radius + spacing) - spacing\n    grid_width = (\n        cols * (2 * hole_radius + spacing) - spacing + (hole_radius + spacing // 2)\n    )\n    shape_array = np.ones((grid_height, grid_width))\n\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * hole_radius + spacing) + hole_radius\n            offset_x = hole_radius + spacing // 2 if row % 2 == 1 else 0\n            center_x = col * (2 * hole_radius + spacing) + hole_radius + offset_x\n            _place_disk_in_grid(shape_array, center_y, center_x, hole_radius, value=0.0)\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes_varying","title":"<code>holes_varying(rows=5, cols=5, min_hole_radius=10, max_hole_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of circular holes with varying radii.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>min_hole_radius</code> <code>int</code> <p>The minimum radius of the holes. Defaults to 10.</p> <code>10</code> <code>max_hole_radius</code> <code>int</code> <p>The maximum radius of the holes. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circular holes with varying radii.</p> Notes <p>Hole radii vary linearly from min_hole_radius to max_hole_radius across the grid, progressing row by row, left to right.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes_varying(\n    rows: int = 5,\n    cols: int = 5,\n    min_hole_radius: int = 10,\n    max_hole_radius: int = 30,\n    spacing: int = 30,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of circular holes with varying radii.\n\n    Parameters\n    ----------\n    rows : int\n        The number of rows in the grid. Defaults to 5.\n    cols : int\n        The number of columns in the grid. Defaults to 5.\n    min_hole_radius : int\n        The minimum radius of the holes. Defaults to 10.\n    max_hole_radius : int\n        The maximum radius of the holes. Defaults to 30.\n    spacing : int\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circular holes with varying radii.\n\n    Notes\n    -----\n    Hole radii vary linearly from min_hole_radius to max_hole_radius across\n    the grid, progressing row by row, left to right.\n    \"\"\"\n    grid_height = rows * (2 * max_hole_radius + spacing) - spacing\n    grid_width = cols * (2 * max_hole_radius + spacing) - spacing\n    shape_array = np.ones((grid_height, grid_width))\n\n    radius_range = np.linspace(min_hole_radius, max_hole_radius, rows * cols).reshape(\n        rows, cols\n    )\n\n    for row in range(rows):\n        for col in range(cols):\n            hole_radius = int(radius_range[row, col])\n            center_y = row * (2 * max_hole_radius + spacing) + max_hole_radius\n            center_x = col * (2 * max_hole_radius + spacing) + max_hole_radius\n            _place_disk_in_grid(shape_array, center_y, center_x, hole_radius, value=0.0)\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.l_grating","title":"<code>l_grating(width=200, height=None, pitch=100, duty_cycle=0.5, **kwargs)</code>","text":"<p>Create a Device object with an L-shaped grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the L-grating. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The height of the L-grating. Defaults to the value of width.</p> <code>None</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the L-shapes. Defaults to 100.</p> <code>100</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the L-shapes (fraction of pitch). Defaults to 0.5.</p> <code>0.5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the L-shaped grating pattern.</p> Notes <p>Each L-shape consists of a horizontal and vertical line extending from the diagonal, creating a stepped pattern across the device.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def l_grating(\n    width: int = 200,\n    height: int | None = None,\n    pitch: int = 100,\n    duty_cycle: float = 0.5,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an L-shaped grating pattern.\n\n    Parameters\n    ----------\n    width : int\n        The width of the L-grating. Defaults to 200.\n    height : int | None\n        The height of the L-grating. Defaults to the value of width.\n    pitch : int\n        The pitch (period) of the L-shapes. Defaults to 100.\n    duty_cycle : float\n        The duty cycle of the L-shapes (fraction of pitch). Defaults to 0.5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the L-shaped grating pattern.\n\n    Notes\n    -----\n    Each L-shape consists of a horizontal and vertical line extending from\n    the diagonal, creating a stepped pattern across the device.\n    \"\"\"\n    height = _default_height(height, width)\n    shape_array = np.zeros((height, width))\n    num_l_shapes = min(height, width) // pitch\n    l_width = int(pitch * duty_cycle)\n\n    for i in range(num_l_shapes):\n        start = i * pitch\n        # Horizontal bar of L extending right from diagonal\n        shape_array[start : start + l_width, start:] = 1\n        # Vertical bar of L extending down from diagonal\n        shape_array[start:, start : start + l_width] = 1\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.offset_grating","title":"<code>offset_grating(height=200, pitch=120, duty_cycle=0.5, num_gratings=3, **kwargs)</code>","text":"<p>Create a Device object with an offset grating pattern (alternating rows).</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height of the grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the grating. Defaults to 120.</p> <code>120</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the grating (fraction of pitch that is filled). Defaults to 0.5.</p> <code>0.5</code> <code>num_gratings</code> <code>int</code> <p>The number of grating periods. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the offset grating pattern.</p> Notes <p>The top half of the grating is offset by pitch // 2 relative to the bottom half, creating an alternating pattern useful for certain optical applications.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def offset_grating(\n    height: int = 200,\n    pitch: int = 120,\n    duty_cycle: float = 0.5,\n    num_gratings: int = 3,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grating pattern (alternating rows).\n\n    Parameters\n    ----------\n    height : int\n        The height of the grating. Defaults to 200.\n    pitch : int\n        The pitch (period) of the grating. Defaults to 120.\n    duty_cycle : float\n        The duty cycle of the grating (fraction of pitch that is filled). Defaults to\n        0.5.\n    num_gratings : int\n        The number of grating periods. Defaults to 3.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the offset grating pattern.\n\n    Notes\n    -----\n    The top half of the grating is offset by pitch // 2 relative to the bottom half,\n    creating an alternating pattern useful for certain optical applications.\n    \"\"\"\n    width = pitch * num_gratings\n    shape_array = np.zeros((height, width))\n    grating_width = int(pitch * duty_cycle)\n    half_height = height // 2\n\n    # Bottom half - standard alignment\n    for i in range(num_gratings):\n        start = i * pitch\n        shape_array[half_height:, start : start + grating_width] = 1\n\n    # Top half - offset by half pitch\n    for i in range(num_gratings):\n        start = i * pitch + pitch // 2\n        shape_array[:half_height, start : start + grating_width] = 1\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.pie","title":"<code>pie(width=200, height=None, arc_angle=270, **kwargs)</code>","text":"<p>Create a Device object with a pie shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the pie. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The height of the pie. Defaults to the value of width.</p> <code>None</code> <code>arc_angle</code> <code>float</code> <p>The angle of the pie slice in degrees. Defaults to 270.</p> <code>270</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the pie shape.</p> Notes <p>The arc angle starts from the positive x-axis (right) and sweeps counter-clockwise. Angle is measured in degrees.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def pie(\n    width: int = 200, height: int | None = None, arc_angle: float = 270, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a pie shape.\n\n    Parameters\n    ----------\n    width : int\n        The width of the pie. Defaults to 200.\n    height : int | None\n        The height of the pie. Defaults to the value of width.\n    arc_angle : float\n        The angle of the pie slice in degrees. Defaults to 270.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the pie shape.\n\n    Notes\n    -----\n    The arc angle starts from the positive x-axis (right) and sweeps\n    counter-clockwise. Angle is measured in degrees.\n    \"\"\"\n    height = _default_height(height, width)\n    ellipse_mask, radius_x, radius_y = _create_ellipse_mask(width, height)\n\n    # Calculate angle mask\n    y, x = np.ogrid[-radius_y:radius_y, -radius_x:radius_x]\n    angle = np.arctan2(y, x) * 180 / np.pi\n    angle = (angle + 360) % 360\n    angle_mask = angle &lt;= arc_angle\n\n    shape_array = np.zeros((height, width))\n    shape_array[ellipse_mask &amp; angle_mask] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.poly","title":"<code>poly(width=200, height=None, num_points=5, **kwargs)</code>","text":"<p>Create a Device object with a regular polygon shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the polygon. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the polygon. Defaults to the value of width.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>The number of sides of the polygon. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the regular polygon shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def poly(\n    width: int = 200, height: int | None = None, num_points: int = 5, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a regular polygon shape.\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the polygon. Defaults to 200.\n    height : int | None\n        The overall height of the polygon. Defaults to the value of width.\n    num_points : int\n        The number of sides of the polygon. Defaults to 5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the regular polygon shape.\n    \"\"\"\n    height = _default_height(height, width)\n    size = min(width, height)\n    radius = size // 2\n\n    angles = np.linspace(0, 2 * np.pi, num_points, endpoint=False) - np.pi / 2\n    x = (radius * np.cos(angles) + radius).astype(int)\n    y = (radius * np.sin(angles) + radius).astype(int)\n\n    shape_array = np.zeros((size, size))\n    rr, cc = polygon(y, x)\n    rr = np.clip(rr, 0, size - 1)\n    cc = np.clip(cc, 0, size - 1)\n    shape_array[rr, cc] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.radial_grating","title":"<code>radial_grating(width=200, height=None, grating_skew=0, num_gratings=6, **kwargs)</code>","text":"<p>Create a Device object with a radial grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the radial grating. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the radial grating. Defaults to the value of width.</p> <code>None</code> <code>grating_skew</code> <code>int</code> <p>The skew angle of the grating arms. Defaults to 0.</p> <code>0</code> <code>num_gratings</code> <code>int</code> <p>The number of grating arms. Defaults to 6.</p> <code>6</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the radial grating pattern.</p> Notes <p>The grating_skew parameter controls the angular width of each arm.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def radial_grating(\n    width: int = 200,\n    height: int | None = None,\n    grating_skew: int = 0,\n    num_gratings: int = 6,\n    **kwargs: Any,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a radial grating pattern.\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the radial grating. Defaults to 200.\n    height : int | None\n        The overall height of the radial grating. Defaults to the value of width.\n    grating_skew : int\n        The skew angle of the grating arms. Defaults to 0.\n    num_gratings : int\n        The number of grating arms. Defaults to 6.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the radial grating pattern.\n\n    Notes\n    -----\n    The grating_skew parameter controls the angular width of each arm.\n    \"\"\"\n    height = _default_height(height, width)\n    size = min(width, height)\n    shape_array = np.zeros((size, size))\n    center = size // 2\n    radius = center\n    theta = np.linspace(0, 2 * np.pi, num_gratings, endpoint=False)\n\n    for angle in theta:\n        x0, y0 = center, center\n        x1 = int(center + radius * np.cos(angle))\n        y1 = int(center + radius * np.sin(angle))\n        x2 = int(\n            center + (radius - grating_skew) * np.cos(angle + np.pi / num_gratings)\n        )\n        y2 = int(\n            center + (radius - grating_skew) * np.sin(angle + np.pi / num_gratings)\n        )\n        rr, cc = polygon([y0, y1, y2], [x0, x1, x2])\n        rr = np.clip(rr, 0, size - 1)\n        cc = np.clip(cc, 0, size - 1)\n        shape_array[rr, cc] = 1\n\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.rectangle","title":"<code>rectangle(width=200, height=None, **kwargs)</code>","text":"<p>Create a Device object with a rectangular shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the rectangle. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The height of the rectangle. Defaults to the value of width if None.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the rectangular shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def rectangle(width: int = 200, height: int | None = None, **kwargs: Any) -&gt; Device:\n    \"\"\"\n    Create a Device object with a rectangular shape.\n\n    Parameters\n    ----------\n    width : int\n        The width of the rectangle. Defaults to 200.\n    height : int | None\n        The height of the rectangle. Defaults to the value of width if None.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the rectangular shape.\n    \"\"\"\n    height = _default_height(height, width)\n    shape_array = np.ones((height, width))\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.ring","title":"<code>ring(width=200, height=None, border_width=60, **kwargs)</code>","text":"<p>Create a Device object with a ring shape (hollow ellipse).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the ring. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the ring. Defaults to the value of width.</p> <code>None</code> <code>border_width</code> <code>int</code> <p>The width of the ring border. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the ring shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def ring(\n    width: int = 200, height: int | None = None, border_width: int = 60, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a ring shape (hollow ellipse).\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the ring. Defaults to 200.\n    height : int | None\n        The overall height of the ring. Defaults to the value of width.\n    border_width : int\n        The width of the ring border. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the ring shape.\n    \"\"\"\n    height = _default_height(height, width)\n    outer_mask, radius_x, radius_y = _create_ellipse_mask(width, height)\n\n    # Create inner ellipse mask\n    inner_radius_x = radius_x - border_width\n    inner_radius_y = radius_y - border_width\n    y, x = np.ogrid[-radius_y:radius_y, -radius_x:radius_x]\n    inner_mask = x**2 / inner_radius_x**2 + y**2 / inner_radius_y**2 &lt;= 1\n\n    shape_array = np.zeros((height, width))\n    shape_array[outer_mask &amp; ~inner_mask] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.star","title":"<code>star(width=200, height=None, num_points=5, **kwargs)</code>","text":"<p>Create a Device object with a star shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the star. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the star. Defaults to the value of width.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>The number of points on the star. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the star shape.</p> Notes <p>The inner radius is set to 50% of the outer radius by default.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def star(\n    width: int = 200, height: int | None = None, num_points: int = 5, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a star shape.\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the star. Defaults to 200.\n    height : int | None\n        The overall height of the star. Defaults to the value of width.\n    num_points : int\n        The number of points on the star. Defaults to 5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the star shape.\n\n    Notes\n    -----\n    The inner radius is set to 50% of the outer radius by default.\n    \"\"\"\n    height = _default_height(height, width)\n    size = min(width, height)\n    radius_outer = size // 2\n    radius_inner = radius_outer // 2  # Inner radius is 50% of outer radius\n\n    angles_outer = np.linspace(0, 2 * np.pi, num_points, endpoint=False) - np.pi / 2\n    angles_inner = angles_outer + np.pi / num_points\n\n    x_outer = (radius_outer * np.cos(angles_outer) + radius_outer).astype(int)\n    y_outer = (radius_outer * np.sin(angles_outer) + radius_outer).astype(int)\n    x_inner = (radius_inner * np.cos(angles_inner) + radius_outer).astype(int)\n    y_inner = (radius_inner * np.sin(angles_inner) + radius_outer).astype(int)\n\n    x = np.empty(2 * num_points, dtype=int)\n    y = np.empty(2 * num_points, dtype=int)\n    x[0::2] = x_outer\n    x[1::2] = x_inner\n    y[0::2] = y_outer\n    y[1::2] = y_inner\n\n    shape_array = np.zeros((size, size))\n    rr, cc = polygon(y, x)\n    rr = np.clip(rr, 0, size - 1)\n    cc = np.clip(cc, 0, size - 1)\n    shape_array[rr, cc] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.target","title":"<code>target(width=200, height=None, arm_width=60, **kwargs)</code>","text":"<p>Create a Device object with a target shape (cross with center removed).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the target. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the target. Defaults to the value of width.</p> <code>None</code> <code>arm_width</code> <code>int</code> <p>The width of the target arms. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the target shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def target(\n    width: int = 200, height: int | None = None, arm_width: int = 60, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a target shape (cross with center removed).\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the target. Defaults to 200.\n    height : int | None\n        The overall height of the target. Defaults to the value of width.\n    arm_width : int\n        The width of the target arms. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the target shape.\n    \"\"\"\n    height = _default_height(height, width)\n    shape_array = np.zeros((height, width))\n    center_x = width // 2\n    center_y = height // 2\n    half_arm_width = arm_width // 2\n    shape_array[center_y - half_arm_width : center_y + half_arm_width + 1, :] = 1\n    shape_array[:, center_x - half_arm_width : center_x + half_arm_width + 1] = 1\n    shape_array[\n        center_y - half_arm_width : center_y + half_arm_width + 1,\n        center_x - half_arm_width : center_x + half_arm_width + 1,\n    ] = 0\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.window","title":"<code>window(width=200, height=None, border_width=60, **kwargs)</code>","text":"<p>Create a Device object with a window shape (hollow rectangle).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width of the window. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int | None</code> <p>The overall height of the window. Defaults to the value of width.</p> <code>None</code> <code>border_width</code> <code>int</code> <p>The width of the window border. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the window shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def window(\n    width: int = 200, height: int | None = None, border_width: int = 60, **kwargs: Any\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a window shape (hollow rectangle).\n\n    Parameters\n    ----------\n    width : int\n        The overall width of the window. Defaults to 200.\n    height : int | None\n        The overall height of the window. Defaults to the value of width.\n    border_width : int\n        The width of the window border. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the window shape.\n    \"\"\"\n    height = _default_height(height, width)\n    shape_array = np.zeros((height, width))\n    shape_array[:border_width, :] = 1\n    shape_array[-border_width:, :] = 1\n    shape_array[:, :border_width] = 1\n    shape_array[:, -border_width:] = 1\n    return Device(device_array=shape_array, **kwargs)\n</code></pre>"}]}