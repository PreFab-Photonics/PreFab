{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"compare/","title":"Compare","text":"<p>Provides comparison functions for devices.</p>"},{"location":"compare/#prefab.compare.dice_coefficient","title":"<code>dice_coefficient(device_a, device_b)</code>","text":"<p>Calculates the Dice coefficient between two binary devices.</p>"},{"location":"compare/#prefab.compare.dice_coefficient--parameters","title":"Parameters","text":"<p>device_a : Device     The first device. device_b : Device     The second device.</p>"},{"location":"compare/#prefab.compare.dice_coefficient--returns","title":"Returns","text":"<p>float     The Dice coefficient between the two devices. A value closer to 1 indicates a     higher similarity (more overlap) between the images, while a value closer to 0     indicates less similarity (less overlap).</p> Source code in <code>prefab/compare.py</code> <pre><code>def dice_coefficient(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Dice coefficient between two binary devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The Dice coefficient between the two devices. A value closer to 1 indicates a\n        higher similarity (more overlap) between the images, while a value closer to 0\n        indicates less similarity (less overlap).\n    \"\"\"\n    intersection = 2.0 * np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    )\n    size_a = np.sum(device_a.device_array)\n    size_b = np.sum(device_b.device_array)\n    return intersection / (size_a + size_b)\n</code></pre>"},{"location":"compare/#prefab.compare.hamming_distance","title":"<code>hamming_distance(device_a, device_b)</code>","text":"<p>Calculates the Hamming distance between two binary devices.</p>"},{"location":"compare/#prefab.compare.hamming_distance--parameters","title":"Parameters","text":"<p>device_a : Device     The first device. device_b : Device     The second device.</p>"},{"location":"compare/#prefab.compare.hamming_distance--returns","title":"Returns","text":"<p>int     The Hamming distance between the two devices. A lower value indicates more     similarity between the devices, while a higher value indicates less similarity.</p> Source code in <code>prefab/compare.py</code> <pre><code>def hamming_distance(device_a: Device, device_b: Device) -&gt; int:\n    \"\"\"\n    Calculates the Hamming distance between two binary devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    int\n        The Hamming distance between the two devices. A lower value indicates more\n        similarity between the devices, while a higher value indicates less similarity.\n    \"\"\"\n    return np.sum(device_a.device_array != device_b.device_array)\n</code></pre>"},{"location":"compare/#prefab.compare.intersection_over_union","title":"<code>intersection_over_union(device_a, device_b)</code>","text":"<p>Calculates the Intersection over Union (IoU) between two binary devices.</p>"},{"location":"compare/#prefab.compare.intersection_over_union--parameters","title":"Parameters","text":"<p>device_a : Device     The first device. device_b : Device     The second device.</p>"},{"location":"compare/#prefab.compare.intersection_over_union--returns","title":"Returns","text":"<p>float     The Intersection over Union (IoU) between the two device images. A value closer     to 1 indicates a higher similarity (more overlap) between the images, while a     value closer to 0 indicates less similarity (less overlap).</p> Source code in <code>prefab/compare.py</code> <pre><code>def intersection_over_union(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Intersection over Union (IoU) between two binary devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The Intersection over Union (IoU) between the two device images. A value closer\n        to 1 indicates a higher similarity (more overlap) between the images, while a\n        value closer to 0 indicates less similarity (less overlap).\n    \"\"\"\n    return np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    ) / np.sum(np.logical_or(device_a.device_array, device_b.device_array))\n</code></pre>"},{"location":"compare/#prefab.compare.mean_squared_error","title":"<code>mean_squared_error(device_a, device_b)</code>","text":"<p>Calculate the mean squared error (MSE) between two non-binarized devices.</p>"},{"location":"compare/#prefab.compare.mean_squared_error--parameters","title":"Parameters","text":"<p>device_a : Device     The first device. device_b : Device     The second device.</p>"},{"location":"compare/#prefab.compare.mean_squared_error--returns","title":"Returns","text":"<p>float     The mean squared error between the two device. A lower value indicates more     similarity between the images.</p> Source code in <code>prefab/compare.py</code> <pre><code>def mean_squared_error(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between two non-binarized devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The mean squared error between the two device. A lower value indicates more\n        similarity between the images.\n    \"\"\"\n    return np.mean((device_a.device_array - device_b.device_array) ** 2)\n</code></pre>"},{"location":"device/","title":"Device","text":"<p>Provides the Device class for representing photonic devices.</p>"},{"location":"device/#prefab.device.BufferSpec","title":"<code>BufferSpec</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines the specifications for a buffer zone around a device.</p> <p>This class is used to specify the mode and thickness of a buffer zone that is added around the device geometry. The buffer zone can be used for various purposes such as providing extra space for device fabrication processes or for ensuring that the device is isolated from surrounding structures.</p>"},{"location":"device/#prefab.device.BufferSpec--parameters","title":"Parameters","text":"<p>mode : dict[str, str]     A dictionary that defines the buffer mode for each side of the device     ('top', 'bottom', 'left', 'right'), where 'constant' is used for isolated     structures and 'edge' is utilized for preserving the edge, such as for waveguide     connections. thickness : conint(gt=0)     The thickness of the buffer zone around the device. Must be greater than 0.</p>"},{"location":"device/#prefab.device.BufferSpec--raises","title":"Raises","text":"<p>ValueError     If any of the modes specified in the 'mode' dictionary are not one of the     allowed values ('constant', 'edge'). Or if the thickness is not greater than 0.</p>"},{"location":"device/#prefab.device.BufferSpec--example","title":"Example","text":"<p>import prefab as pf buffer_spec = pf.BufferSpec( ...     mode={ ...         \"top\": \"constant\", ...         \"bottom\": \"edge\", ...         \"left\": \"constant\", ...         \"right\": \"edge\" ...     }, ...     thickness=150 ... )</p> Source code in <code>prefab/device.py</code> <pre><code>class BufferSpec(BaseModel):\n    \"\"\"\n    Defines the specifications for a buffer zone around a device.\n\n    This class is used to specify the mode and thickness of a buffer zone that is added\n    around the device geometry. The buffer zone can be used for various purposes such as\n    providing extra space for device fabrication processes or for ensuring that the\n    device is isolated from surrounding structures.\n\n    Parameters\n    ----------\n    mode : dict[str, str]\n        A dictionary that defines the buffer mode for each side of the device\n        ('top', 'bottom', 'left', 'right'), where 'constant' is used for isolated\n        structures and 'edge' is utilized for preserving the edge, such as for waveguide\n        connections.\n    thickness : conint(gt=0)\n        The thickness of the buffer zone around the device. Must be greater than 0.\n\n    Raises\n    ------\n    ValueError\n        If any of the modes specified in the 'mode' dictionary are not one of the\n        allowed values ('constant', 'edge'). Or if the thickness is not greater than 0.\n\n    Example\n    -------\n    &gt;&gt;&gt; import prefab as pf\n    &gt;&gt;&gt; buffer_spec = pf.BufferSpec(\n    ...     mode={\n    ...         \"top\": \"constant\",\n    ...         \"bottom\": \"edge\",\n    ...         \"left\": \"constant\",\n    ...         \"right\": \"edge\"\n    ...     },\n    ...     thickness=150\n    ... )\n    \"\"\"\n\n    mode: dict[str, str] = Field(\n        default_factory=lambda: {\n            \"top\": \"constant\",\n            \"bottom\": \"constant\",\n            \"left\": \"constant\",\n            \"right\": \"constant\",\n        }\n    )\n    thickness: conint(gt=0) = 128\n\n    @validator(\"mode\", pre=True)\n    def check_mode(cls, v):\n        allowed_modes = [\"constant\", \"edge\"]\n        if not all(mode in allowed_modes for mode in v.values()):\n            raise ValueError(f\"Buffer mode must be one of {allowed_modes}, got '{v}'\")\n        return v\n</code></pre>"},{"location":"device/#prefab.device.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>prefab/device.py</code> <pre><code>class Device(BaseModel):\n    device_array: np.ndarray = Field(...)\n    buffer_spec: BufferSpec = Field(default_factory=BufferSpec)\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        return self.device_array.shape\n\n    def __init__(\n        self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n    ):\n        \"\"\"\n        Represents the planar geometry of a photonic device design that will have its\n        nanofabrication outcome predicted and/or corrected.\n\n        This class is designed to encapsulate the geometric representation of a photonic\n        device, facilitating operations such as padding, normalization, binarization,\n        ternarization, trimming, and blurring. These operations are useful for preparing\n        the device design for prediction or correction. Additionally, the class provides\n        methods for exporting the device representation to various formats, including\n        ndarray, image files, and GDSII files, supporting a range of analysis and\n        fabrication workflows.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            A 2D array representing the planar geometry of the device. This array\n            undergoes various transformations to predict or correct the nanofabrication\n            process.\n        buffer_spec : BufferSpec, optional\n            Defines the parameters for adding a buffer zone around the device geometry.\n            This buffer zone is needed for providing surrounding context for prediction\n            or correction and for ensuring seamless integration with the surrounding\n            circuitry. By default, a generous padding is applied to accommodate isolated\n            structures.\n\n        Attributes\n        ----------\n        shape : tuple[int, int]\n            The shape of the device array.\n\n        Raises\n        ------\n        ValueError\n            If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n            indicating an invalid device geometry.\n        \"\"\"\n        super().__init__(\n            device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n        )\n        self._initial_processing()\n\n    def __call__(self, *args, **kwargs):\n        return self.plot(*args, **kwargs)\n\n    def _initial_processing(self):\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((buffer_thickness, 0), (0, 0)),\n            mode=buffer_mode[\"top\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, buffer_thickness), (0, 0)),\n            mode=buffer_mode[\"bottom\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, 0), (buffer_thickness, 0)),\n            mode=buffer_mode[\"left\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, 0), (0, buffer_thickness)),\n            mode=buffer_mode[\"right\"],\n        )\n\n        self.device_array = self.device_array.astype(np.float32)\n\n    @root_validator(pre=True)\n    def check_device_array(cls, values):\n        device_array = values.get(\"device_array\")\n        if not isinstance(device_array, np.ndarray):\n            raise ValueError(\"device_array must be a numpy ndarray.\")\n        if device_array.ndim != 2:\n            raise ValueError(\"device_array must be a 2D array.\")\n        return values\n\n    def is_binary(self) -&gt; bool:\n        \"\"\"\n        Check if the device geometry is binary.\n\n        Returns\n        -------\n        bool\n            True if the device geometry is binary, False otherwise.\n        \"\"\"\n        unique_values = np.unique(self.device_array)\n        return (\n            np.array_equal(unique_values, [0, 1])\n            or np.array_equal(unique_values, [1, 0])\n            or np.array_equal(unique_values, [0])\n            or np.array_equal(unique_values, [1])\n        )\n\n    def _encode_array(self, array):\n        array_shape = struct.pack(\"&gt;II\", len(array), len(array[0]))\n        serialized_array = array_shape + array.tobytes()\n        encoded_array = base64.b64encode(serialized_array).decode(\"utf-8\")\n        return encoded_array\n\n    def _decode_array(self, encoded_array):\n        serialized_array = base64.b64decode(encoded_array)\n        array = np.frombuffer(serialized_array, dtype=np.float32, offset=8)\n        array.shape = struct.unpack(\"&gt;II\", serialized_array[:8])\n        return array\n\n    def _predict(\n        self,\n        model_name: str,\n        model_tags: list[str],\n        model_type: str,\n        binarize: bool = False,\n    ) -&gt; \"Device\":\n        if not self.is_binary():\n            warnings.warn(\n                \"The device is not binary. Prediction accuracy will be affected.\",\n                UserWarning,\n                stacklevel=2,\n            )\n\n        function_url = \"https://prefab-photonics--predict-v1.modal.run\"\n\n        predict_data = {\n            \"device_array\": self._encode_array(self.device_array),\n            \"model_name\": model_name,\n            \"model_tags\": model_tags,\n            \"model_type\": model_type,\n            \"binary\": binarize,\n        }\n\n        with open(os.path.expanduser(\"~/.prefab.toml\")) as file:\n            content = file.readlines()\n            for line in content:\n                if \"access_token\" in line:\n                    access_token = line.split(\"=\")[1].strip().strip('\"')\n                if \"refresh_token\" in line:\n                    refresh_token = line.split(\"=\")[1].strip().strip('\"')\n                    break\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"X-Refresh-Token\": refresh_token,\n        }\n\n        response = requests.post(url=function_url, json=predict_data, headers=headers)\n\n        if response.status_code != 200:\n            raise ValueError(response.text)\n        else:\n            response_data = response.json()\n            if \"error\" in response_data:\n                raise ValueError(response_data[\"error\"])\n            if \"prediction_array\" in response_data:\n                prediction_array = self._decode_array(response_data[\"prediction_array\"])\n                if binarize:\n                    prediction_array = geometry.binarize_hard(prediction_array)\n            if \"new_refresh_token\" in response_data:\n                prefab_file_path = os.path.expanduser(\"~/.prefab.toml\")\n                with open(prefab_file_path, \"w\", encoding=\"utf-8\") as toml_file:\n                    toml.dump(\n                        {\n                            \"access_token\": response_data[\"new_access_token\"],\n                            \"refresh_token\": response_data[\"new_refresh_token\"],\n                        },\n                        toml_file,\n                    )\n        return self.model_copy(update={\"device_array\": prediction_array})\n\n    def predict(\n        self,\n        model_name: str,\n        model_tags: list[str],\n        binarize: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Predict the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless prediction service, which\n        uses a specified machine learning model to predict the outcome of the\n        nanofabrication process.\n\n        Parameters\n        ----------\n        model_name : str\n            The name of the model to use for prediction.\n        model_tags : list[str]\n            A list of tags associated with the model. These tags can be used to specify\n            model versions or configurations.\n        binarize : bool, optional\n            If True, the predicted device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic predictions into binary\n            geometries. Defaults to False.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the predicted geometry.\n\n        Raises\n        ------\n        ValueError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        return self._predict(\n            model_name=model_name,\n            model_tags=model_tags,\n            model_type=\"p\",\n            binarize=binarize,\n        )\n\n    def correct(\n        self,\n        model_name: str,\n        model_tags: list[str],\n        binarize: bool = True,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Correct the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless correction service, which\n        uses a specified machine learning model to correct the outcome of the\n        nanofabrication process. The correction aims to adjust the device geometry to\n        compensate for known fabrication errors and improve the accuracy of the final\n        device structure.\n\n        Parameters\n        ----------\n        model_name : str\n            The name of the model to use for correction.\n        model_tags : list[str]\n            A list of tags associated with the model. These tags can be used to specify\n            model versions or configurations.\n        binarize : bool, optional\n            If True, the corrected device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic corrections into binary\n            geometries. Defaults to True.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the corrected geometry.\n\n        Raises\n        ------\n        ValueError\n            If the correction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        return self._predict(\n            model_name=model_name,\n            model_tags=model_tags,\n            model_type=\"c\",\n            binarize=binarize,\n        )\n\n    def semulate(\n        self,\n        model_name: str,\n        model_tags: list[str],\n    ) -&gt; \"Device\":\n        \"\"\"\n        Simulate the appearance of the device as if viewed under a Scanning Electron\n        Microscope (SEM).\n\n        This method applies a specified machine learning model to transform the device\n        geometry into a style that resembles an SEM image. This can be useful for\n        visualizing how the device might appear under an SEM, which is often used for\n        inspecting the surface and composition of materials at high magnification.\n\n        Parameters\n        ----------\n        model_name : str\n            The name of the model to use for correction.\n        model_tags : list[str]\n            A list of tags associated with the model. These tags can be used to specify\n            model versions or configurations.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with its geometry transformed to simulate\n            an SEM image style.\n        \"\"\"\n        return self._predict(\n            model_name=model_name,\n            model_tags=model_tags,\n            model_type=\"s\",\n        )\n\n    def to_ndarray(self) -&gt; np.ndarray:\n        \"\"\"\n        Converts the device geometry to a numpy ndarray.\n\n        This method applies the buffer specifications to crop the device array if\n        necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n        resulting numpy ndarray representing the device geometry.\n\n        Returns\n        -------\n        np.ndarray\n            The numpy ndarray representation of the device geometry, with any applied\n            buffer cropping.\n        \"\"\"\n        device_array = np.copy(self.device_array)\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        crop_top = buffer_thickness if buffer_mode[\"top\"] == \"edge\" else 0\n        crop_bottom = buffer_thickness if buffer_mode[\"bottom\"] == \"edge\" else 0\n        crop_left = buffer_thickness if buffer_mode[\"left\"] == \"edge\" else 0\n        crop_right = buffer_thickness if buffer_mode[\"right\"] == \"edge\" else 0\n\n        ndarray = device_array[\n            crop_top : device_array.shape[0] - crop_bottom,\n            crop_left : device_array.shape[1] - crop_right,\n        ]\n        return ndarray\n\n    def to_img(self, img_path: str = \"prefab_device.png\"):\n        \"\"\"\n        Exports the device geometry as an image file.\n\n        This method converts the device geometry to a numpy ndarray using `to_ndarray`,\n        scales the values to the range [0, 255] for image representation, and saves the\n        result as an image file.\n\n        Parameters\n        ----------\n        img_path : str, optional\n            The path where the image file will be saved. If not specified, the image is\n            saved as \"prefab_device.png\" in the current directory.\n        \"\"\"\n        cv2.imwrite(img_path, 255 * self.to_ndarray())\n        print(f\"Saved Device to '{img_path}'\")\n\n    def to_gds(\n        self,\n        gds_path: str = \"prefab_device.gds\",\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n    ):\n        \"\"\"\n        Exports the device geometry as a GDSII file.\n\n        This method converts the device geometry into a format suitable for GDSII files.\n        The conversion involves contour approximation to simplify the geometry while\n        preserving essential features.\n\n        Parameters\n        ----------\n        gds_path : str, optional\n            The path where the GDSII file will be saved. If not specified, the file is\n            saved as \"prefab_device.gds\" in the current directory.\n        cell_name : str, optional\n            The name of the cell within the GDSII file. If not specified, defaults to\n            \"prefab_device\".\n        gds_layer : tuple[int, int], optional\n            The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n        contour_approx_mode : int, optional\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        \"\"\"\n        gdstk_cell = self._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n        )\n        print(f\"Saving GDS to '{gds_path}'...\")\n        gdstk_library = gdstk.Library()\n        gdstk_library.add(gdstk_cell)\n        gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n\n    def to_gdstk(\n        self,\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n    ):\n        \"\"\"\n        Converts the device geometry to a GDSTK cell object.\n\n        This method prepares the device geometry for GDSII file export by converting it\n        into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n        GDSII layout files. The conversion involves contour approximation to simplify\n        the geometry while preserving essential features.\n\n        Parameters\n        ----------\n        cell_name : str, optional\n            The name of the cell to be created. Defaults to \"prefab_device\".\n        gds_layer : tuple[int, int], optional\n            The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n        contour_approx_mode : int, optional\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n\n        Returns\n        -------\n        gdstk.Cell\n            The GDSTK cell object representing the device geometry.\n        \"\"\"\n        print(f\"Creating cell '{cell_name}'...\")\n        gdstk_cell = self._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n        )\n        return gdstk_cell\n\n    def _device_to_gdstk(\n        self,\n        cell_name: str,\n        gds_layer: tuple[int, int],\n        contour_approx_mode: int,\n    ) -&gt; gdstk.Cell:\n        approx_mode_mapping = {\n            1: cv2.CHAIN_APPROX_NONE,\n            2: cv2.CHAIN_APPROX_SIMPLE,\n            3: cv2.CHAIN_APPROX_TC89_L1,\n            4: cv2.CHAIN_APPROX_TC89_KCOS,\n        }\n\n        contours, hierarchy = cv2.findContours(\n            np.flipud(self.to_ndarray()).astype(np.uint8),\n            cv2.RETR_TREE,\n            approx_mode_mapping[contour_approx_mode],\n        )\n\n        hierarchy_polygons = {}\n        for idx, contour in enumerate(contours):\n            level = 0\n            current_idx = idx\n            while hierarchy[0][current_idx][3] != -1:\n                level += 1\n                current_idx = hierarchy[0][current_idx][3]\n\n            if len(contour) &gt; 2:\n                contour = contour / 1000\n                points = [tuple(point) for point in contour.squeeze().tolist()]\n                if level not in hierarchy_polygons:\n                    hierarchy_polygons[level] = []\n                hierarchy_polygons[level].append(points)\n\n        cell = gdstk.Cell(cell_name)\n        processed_polygons = []\n        for level in sorted(hierarchy_polygons.keys()):\n            operation = \"or\" if level % 2 == 0 else \"xor\"\n            polygons_to_process = hierarchy_polygons[level]\n\n            if polygons_to_process:\n                processed_polygons = gdstk.boolean(\n                    polygons_to_process,\n                    processed_polygons,\n                    operation,\n                    layer=gds_layer[0],\n                    datatype=gds_layer[1],\n                )\n        for polygon in processed_polygons:\n            cell.add(polygon)\n\n        return cell\n\n    def _plot_base(\n        self,\n        plot_array: np.ndarray,\n        show_buffer: bool,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]],\n        ax: Optional[Axes],\n        **kwargs,\n    ) -&gt; Axes:\n        if ax is None:\n            _, ax = plt.subplots()\n        ax.set_ylabel(\"y (nm)\")\n        ax.set_xlabel(\"x (nm)\")\n\n        min_x, min_y = (0, 0) if bounds is None else bounds[0]\n        max_x, max_y = plot_array.shape[::-1] if bounds is None else bounds[1]\n        min_x = max(min_x, 0)\n        min_y = max(min_y, 0)\n        max_x = \"end\" if max_x == \"end\" else min(max_x, plot_array.shape[1])\n        max_y = \"end\" if max_y == \"end\" else min(max_y, plot_array.shape[0])\n        max_x = plot_array.shape[1] if max_x == \"end\" else max_x\n        max_y = plot_array.shape[0] if max_y == \"end\" else max_y\n        plot_array = plot_array[\n            plot_array.shape[0] - max_y : plot_array.shape[0] - min_y,\n            min_x:max_x,\n        ]\n        extent = [min_x, max_x, min_y, max_y]\n\n        max_size = (1000, 1000)\n        scale_x = min(1, max_size[0] / plot_array.shape[1])\n        scale_y = min(1, max_size[1] / plot_array.shape[0])\n        fx = min(scale_x, scale_y)\n        fy = fx\n        plot_array = cv2.resize(\n            plot_array,\n            dsize=(0, 0),\n            fx=fx,\n            fy=fy,\n            interpolation=cv2.INTER_AREA,\n        )\n\n        mappable = ax.imshow(\n            plot_array,\n            extent=extent,\n            **kwargs,\n        )\n\n        if show_buffer:\n            self._add_buffer_visualization(ax)\n\n        return mappable, ax\n\n    def plot(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the device geometry, optionally including buffer zones.\n\n        This method allows for the visualization of the device geometry with an option\n        to include buffer zones. It supports zooming into a specific area of the device.\n        The visualization can be customized with various matplotlib parameters and can\n        be drawn on an existing matplotlib Axes object or create a new one if none is\n        provided.\n\n        Parameters\n        ----------\n        show_buffer : bool, optional\n            If True, visualizes the buffer zones around the device to provide spatial\n            context. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the device geometry on. If\n            None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the plot. This object can be used for\n            further plot customization or saving the plot after the method returns.\n        \"\"\"\n        _, ax = self._plot_base(\n            plot_array=self.device_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        return ax\n\n    def plot_contour(\n        self,\n        linewidth: Optional[int] = None,\n        # label: Optional[str] = \"Device contour\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the contour of the device along with optional buffer zones.\n\n        This method plots the contour of the device geometry, emphasizing the edges and\n        boundaries of the device. The contour plot can be customized with various\n        matplotlib parameters, including line width and color. The plot can be drawn on\n        an existing matplotlib Axes object or create a new one if none is provided.\n\n        Parameters\n        ----------\n        linewidth : Optional[int], optional\n            The width of the contour lines. If None, the linewidth is automatically\n            determined based on the size of the device array. Defaults to None.\n        show_buffer : bool, optional\n            If True, the buffer zones around the device will be visualized. By default,\n            it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the device contour on. If None, a\n            new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the contour plot. This can be used for\n            further customization or saving the plot after the method returns.\n        \"\"\"\n        kwargs.setdefault(\"cmap\", \"spring\")\n        if linewidth is None:\n            linewidth = self.device_array.shape[0] // 100\n\n        contours, _ = cv2.findContours(\n            geometry.binarize_hard(self.device_array).astype(np.uint8),\n            cv2.RETR_CCOMP,\n            cv2.CHAIN_APPROX_SIMPLE,\n        )\n        contour_array = np.zeros_like(self.device_array, dtype=np.uint8)\n        cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n        contour_array = np.ma.masked_equal(contour_array, 0)\n\n        _, ax = self._plot_base(\n            plot_array=contour_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n        # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n        # ax.legend([legend_proxy], [label], loc=\"upper right\")\n        return ax\n\n    def plot_uncertainty(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the uncertainty in the edge positions of the predicted device.\n\n        This method plots the uncertainty associated with the positions of the edges of\n        the device. The uncertainty is represented as a gradient, with areas of higher\n        uncertainty indicating a greater likelihood of the edge position from run to run\n        (due to inconsistencies in the fabrication process). This visualization can help\n        in identifying areas within the device geometry that may require design\n        adjustments to improve fabrication consistency.\n\n        Parameters\n        ----------\n        show_buffer : bool, optional\n            If True, the buffer zones around the device will also be visualized. By\n            default, it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the uncertainty visualization on.\n            If None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the uncertainty visualization. This\n            can be used for further customization or saving the plot after the method\n            returns.\n        \"\"\"\n        uncertainty_array = 1 - 2 * np.abs(0.5 - self.device_array)\n\n        mappable, ax = self._plot_base(\n            plot_array=uncertainty_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Uncertainty (a.u.)\")\n        return ax\n\n    def _add_buffer_visualization(self, ax: Axes):\n        plot_array = self.device_array\n\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_fill = (0, 1, 0, 0.2)\n        buffer_hatch = \"/\"\n\n        mid_rect = Rectangle(\n            (buffer_thickness, buffer_thickness),\n            plot_array.shape[1] - 2 * buffer_thickness,\n            plot_array.shape[0] - 2 * buffer_thickness,\n            facecolor=\"none\",\n            edgecolor=\"black\",\n            linewidth=1,\n        )\n        ax.add_patch(mid_rect)\n\n        top_rect = Rectangle(\n            (0, 0),\n            plot_array.shape[1],\n            buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(top_rect)\n\n        bottom_rect = Rectangle(\n            (0, plot_array.shape[0] - buffer_thickness),\n            plot_array.shape[1],\n            buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(bottom_rect)\n\n        left_rect = Rectangle(\n            (0, buffer_thickness),\n            buffer_thickness,\n            plot_array.shape[0] - 2 * buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(left_rect)\n\n        right_rect = Rectangle(\n            (\n                plot_array.shape[1] - buffer_thickness,\n                buffer_thickness,\n            ),\n            buffer_thickness,\n            plot_array.shape[0] - 2 * buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(right_rect)\n\n    def normalize(self) -&gt; \"Device\":\n        \"\"\"\n        Normalize the device geometry.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the normalized geometry.\n        \"\"\"\n        normalized_device_array = geometry.normalize(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": normalized_device_array})\n\n    def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry based on a threshold and a scaling factor.\n\n        Parameters\n        ----------\n        eta : float, optional\n            The threshold value for binarization. Defaults to 0.5.\n        beta : float, optional\n            The scaling factor for the binarization process. A higher value makes the\n            transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize(\n            device_array=self.device_array, eta=eta, beta=beta\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n        \"\"\"\n        Apply a hard threshold to binarize the device geometry.\n\n        Parameters\n        ----------\n        eta : float, optional\n            The threshold value for binarization. Defaults to 0.5.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the threshold-binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_hard(\n            device_array=self.device_array, eta=eta\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def binarize_monte_carlo(\n        self,\n        threshold_noise_std: float = 2.0,\n        threshold_blur_std: float = 9.0,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry using a Monte Carlo approach with Gaussian\n        blurring.\n\n        This method applies a dynamic thresholding technique where the threshold value\n        is determined by a base value perturbed by Gaussian-distributed random noise.\n        The threshold is then spatially varied across the device array using Gaussian\n        blurring, simulating a more realistic scenario where the threshold is not\n        uniform across the device.\n\n        Parameters\n        ----------\n        threshold_noise_std : float, optional\n            The standard deviation of the Gaussian distribution used to generate noise\n            for the threshold values. This controls the amount of randomness in the\n            threshold. Defaults to 2.0.\n        threshold_blur_std : float, optional\n            The standard deviation for the Gaussian kernel used in blurring the\n            threshold map. This controls the spatial variation of the threshold across\n            the array. Defaults to 9.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_monte_carlo(\n            device_array=self.device_array,\n            threshold_noise_std=threshold_noise_std,\n            threshold_blur_std=threshold_blur_std,\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n        \"\"\"\n        Ternarize the device geometry based on two thresholds.\n\n        Parameters\n        ----------\n        eta1 : float, optional\n            The first threshold value for ternarization. Defaults to 1/3.\n        eta2 : float, optional\n            The second threshold value for ternarization. Defaults to 2/3.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the ternarized geometry.\n        \"\"\"\n        ternarized_device_array = geometry.ternarize(\n            device_array=self.device_array, eta1=eta1, eta2=eta2\n        )\n        return self.model_copy(update={\"device_array\": ternarized_device_array})\n\n    def trim(self) -&gt; \"Device\":\n        \"\"\"\n        Trim the device geometry by removing empty space around it.\n\n        Parameters\n        ----------\n        buffer_thickness : int, optional\n            The thickness of the buffer to leave around the empty space. Defaults to 0,\n            which means no buffer is added.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the trimmed geometry.\n        \"\"\"\n        trimmed_device_array = geometry.trim(\n            device_array=self.device_array,\n            buffer_thickness=self.buffer_spec.thickness,\n        )\n        return self.model_copy(update={\"device_array\": trimmed_device_array})\n\n    def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n        \"\"\"\n        Apply Gaussian blur to the device geometry and normalize the result.\n\n        Parameters\n        ----------\n        sigma : float, optional\n            The standard deviation for the Gaussian kernel. This controls the amount of\n            blurring. Defaults to 1.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the blurred and normalized geometry.\n        \"\"\"\n        blurred_device_array = geometry.blur(\n            device_array=self.device_array, sigma=sigma\n        )\n        return self.model_copy(update={\"device_array\": blurred_device_array})\n\n    def rotate(self, angle: float) -&gt; \"Device\":\n        \"\"\"\n        Rotate the device geometry by a given angle.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation in degrees. Positive values mean counter-clockwise\n            rotation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the rotated geometry.\n        \"\"\"\n        rotated_device_array = geometry.rotate(\n            device_array=self.device_array, angle=angle\n        )\n        return self.model_copy(update={\"device_array\": rotated_device_array})\n\n    def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Erode the device geometry by removing small areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for erosion.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the eroded geometry.\n        \"\"\"\n        eroded_device_array = geometry.erode(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": eroded_device_array})\n\n    def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Dilate the device geometry by expanding areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for dilation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the dilated geometry.\n        \"\"\"\n        dilated_device_array = geometry.dilate(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": dilated_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.__init__","title":"<code>__init__(device_array, buffer_spec=None)</code>","text":"<p>Represents the planar geometry of a photonic device design that will have its nanofabrication outcome predicted and/or corrected.</p> <p>This class is designed to encapsulate the geometric representation of a photonic device, facilitating operations such as padding, normalization, binarization, ternarization, trimming, and blurring. These operations are useful for preparing the device design for prediction or correction. Additionally, the class provides methods for exporting the device representation to various formats, including ndarray, image files, and GDSII files, supporting a range of analysis and fabrication workflows.</p>"},{"location":"device/#prefab.device.Device.__init__--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     A 2D array representing the planar geometry of the device. This array     undergoes various transformations to predict or correct the nanofabrication     process. buffer_spec : BufferSpec, optional     Defines the parameters for adding a buffer zone around the device geometry.     This buffer zone is needed for providing surrounding context for prediction     or correction and for ensuring seamless integration with the surrounding     circuitry. By default, a generous padding is applied to accommodate isolated     structures.</p>"},{"location":"device/#prefab.device.Device.__init__--attributes","title":"Attributes","text":"<p>shape : tuple[int, int]     The shape of the device array.</p>"},{"location":"device/#prefab.device.Device.__init__--raises","title":"Raises","text":"<p>ValueError     If the provided <code>device_array</code> is not a numpy ndarray or is not a 2D array,     indicating an invalid device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def __init__(\n    self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n):\n    \"\"\"\n    Represents the planar geometry of a photonic device design that will have its\n    nanofabrication outcome predicted and/or corrected.\n\n    This class is designed to encapsulate the geometric representation of a photonic\n    device, facilitating operations such as padding, normalization, binarization,\n    ternarization, trimming, and blurring. These operations are useful for preparing\n    the device design for prediction or correction. Additionally, the class provides\n    methods for exporting the device representation to various formats, including\n    ndarray, image files, and GDSII files, supporting a range of analysis and\n    fabrication workflows.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array\n        undergoes various transformations to predict or correct the nanofabrication\n        process.\n    buffer_spec : BufferSpec, optional\n        Defines the parameters for adding a buffer zone around the device geometry.\n        This buffer zone is needed for providing surrounding context for prediction\n        or correction and for ensuring seamless integration with the surrounding\n        circuitry. By default, a generous padding is applied to accommodate isolated\n        structures.\n\n    Attributes\n    ----------\n    shape : tuple[int, int]\n        The shape of the device array.\n\n    Raises\n    ------\n    ValueError\n        If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n        indicating an invalid device geometry.\n    \"\"\"\n    super().__init__(\n        device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n    )\n    self._initial_processing()\n</code></pre>"},{"location":"device/#prefab.device.Device.binarize","title":"<code>binarize(eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the device geometry based on a threshold and a scaling factor.</p>"},{"location":"device/#prefab.device.Device.binarize--parameters","title":"Parameters","text":"<p>eta : float, optional     The threshold value for binarization. Defaults to 0.5. beta : float, optional     The scaling factor for the binarization process. A higher value makes the     transition sharper. Defaults to np.inf, which results in a hard threshold.</p>"},{"location":"device/#prefab.device.Device.binarize--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float, optional\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize(\n        device_array=self.device_array, eta=eta, beta=beta\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.binarize_hard","title":"<code>binarize_hard(eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the device geometry.</p>"},{"location":"device/#prefab.device.Device.binarize_hard--parameters","title":"Parameters","text":"<p>eta : float, optional     The threshold value for binarization. Defaults to 0.5.</p>"},{"location":"device/#prefab.device.Device.binarize_hard--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the threshold-binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n    \"\"\"\n    Apply a hard threshold to binarize the device geometry.\n\n    Parameters\n    ----------\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the threshold-binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_hard(\n        device_array=self.device_array, eta=eta\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.binarize_monte_carlo","title":"<code>binarize_monte_carlo(threshold_noise_std=2.0, threshold_blur_std=9.0)</code>","text":"<p>Binarize the device geometry using a Monte Carlo approach with Gaussian blurring.</p> <p>This method applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the device array using Gaussian blurring, simulating a more realistic scenario where the threshold is not uniform across the device.</p>"},{"location":"device/#prefab.device.Device.binarize_monte_carlo--parameters","title":"Parameters","text":"<p>threshold_noise_std : float, optional     The standard deviation of the Gaussian distribution used to generate noise     for the threshold values. This controls the amount of randomness in the     threshold. Defaults to 2.0. threshold_blur_std : float, optional     The standard deviation for the Gaussian kernel used in blurring the     threshold map. This controls the spatial variation of the threshold across     the array. Defaults to 9.0.</p>"},{"location":"device/#prefab.device.Device.binarize_monte_carlo--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_monte_carlo(\n    self,\n    threshold_noise_std: float = 2.0,\n    threshold_blur_std: float = 9.0,\n) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry using a Monte Carlo approach with Gaussian\n    blurring.\n\n    This method applies a dynamic thresholding technique where the threshold value\n    is determined by a base value perturbed by Gaussian-distributed random noise.\n    The threshold is then spatially varied across the device array using Gaussian\n    blurring, simulating a more realistic scenario where the threshold is not\n    uniform across the device.\n\n    Parameters\n    ----------\n    threshold_noise_std : float, optional\n        The standard deviation of the Gaussian distribution used to generate noise\n        for the threshold values. This controls the amount of randomness in the\n        threshold. Defaults to 2.0.\n    threshold_blur_std : float, optional\n        The standard deviation for the Gaussian kernel used in blurring the\n        threshold map. This controls the spatial variation of the threshold across\n        the array. Defaults to 9.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_monte_carlo(\n        device_array=self.device_array,\n        threshold_noise_std=threshold_noise_std,\n        threshold_blur_std=threshold_blur_std,\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.blur","title":"<code>blur(sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the device geometry and normalize the result.</p>"},{"location":"device/#prefab.device.Device.blur--parameters","title":"Parameters","text":"<p>sigma : float, optional     The standard deviation for the Gaussian kernel. This controls the amount of     blurring. Defaults to 1.0.</p>"},{"location":"device/#prefab.device.Device.blur--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the blurred and normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n    \"\"\"\n    Apply Gaussian blur to the device geometry and normalize the result.\n\n    Parameters\n    ----------\n    sigma : float, optional\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the blurred and normalized geometry.\n    \"\"\"\n    blurred_device_array = geometry.blur(\n        device_array=self.device_array, sigma=sigma\n    )\n    return self.model_copy(update={\"device_array\": blurred_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.correct","title":"<code>correct(model_name, model_tags, binarize=True)</code>","text":"<p>Correct the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless correction service, which uses a specified machine learning model to correct the outcome of the nanofabrication process. The correction aims to adjust the device geometry to compensate for known fabrication errors and improve the accuracy of the final device structure.</p>"},{"location":"device/#prefab.device.Device.correct--parameters","title":"Parameters","text":"<p>model_name : str     The name of the model to use for correction. model_tags : list[str]     A list of tags associated with the model. These tags can be used to specify     model versions or configurations. binarize : bool, optional     If True, the corrected device geometry will be binarized using a threshold     method. This is useful for converting probabilistic corrections into binary     geometries. Defaults to True.</p>"},{"location":"device/#prefab.device.Device.correct--returns","title":"Returns","text":"<p>Device     A new instance of the Device class with the corrected geometry.</p>"},{"location":"device/#prefab.device.Device.correct--raises","title":"Raises","text":"<p>ValueError     If the correction service returns an error or if the response from the     service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def correct(\n    self,\n    model_name: str,\n    model_tags: list[str],\n    binarize: bool = True,\n) -&gt; \"Device\":\n    \"\"\"\n    Correct the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless correction service, which\n    uses a specified machine learning model to correct the outcome of the\n    nanofabrication process. The correction aims to adjust the device geometry to\n    compensate for known fabrication errors and improve the accuracy of the final\n    device structure.\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model to use for correction.\n    model_tags : list[str]\n        A list of tags associated with the model. These tags can be used to specify\n        model versions or configurations.\n    binarize : bool, optional\n        If True, the corrected device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic corrections into binary\n        geometries. Defaults to True.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the corrected geometry.\n\n    Raises\n    ------\n    ValueError\n        If the correction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    return self._predict(\n        model_name=model_name,\n        model_tags=model_tags,\n        model_type=\"c\",\n        binarize=binarize,\n    )\n</code></pre>"},{"location":"device/#prefab.device.Device.dilate","title":"<code>dilate(kernel_size=3)</code>","text":"<p>Dilate the device geometry by expanding areas of overlap.</p>"},{"location":"device/#prefab.device.Device.dilate--parameters","title":"Parameters","text":"<p>kernel_size : int     The size of the kernel used for dilation.</p>"},{"location":"device/#prefab.device.Device.dilate--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the dilated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Dilate the device geometry by expanding areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the dilated geometry.\n    \"\"\"\n    dilated_device_array = geometry.dilate(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": dilated_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.erode","title":"<code>erode(kernel_size=3)</code>","text":"<p>Erode the device geometry by removing small areas of overlap.</p>"},{"location":"device/#prefab.device.Device.erode--parameters","title":"Parameters","text":"<p>kernel_size : int     The size of the kernel used for erosion.</p>"},{"location":"device/#prefab.device.Device.erode--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the eroded geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Erode the device geometry by removing small areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the eroded geometry.\n    \"\"\"\n    eroded_device_array = geometry.erode(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": eroded_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.is_binary","title":"<code>is_binary()</code>","text":"<p>Check if the device geometry is binary.</p>"},{"location":"device/#prefab.device.Device.is_binary--returns","title":"Returns","text":"<p>bool     True if the device geometry is binary, False otherwise.</p> Source code in <code>prefab/device.py</code> <pre><code>def is_binary(self) -&gt; bool:\n    \"\"\"\n    Check if the device geometry is binary.\n\n    Returns\n    -------\n    bool\n        True if the device geometry is binary, False otherwise.\n    \"\"\"\n    unique_values = np.unique(self.device_array)\n    return (\n        np.array_equal(unique_values, [0, 1])\n        or np.array_equal(unique_values, [1, 0])\n        or np.array_equal(unique_values, [0])\n        or np.array_equal(unique_values, [1])\n    )\n</code></pre>"},{"location":"device/#prefab.device.Device.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the device geometry.</p>"},{"location":"device/#prefab.device.Device.normalize--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def normalize(self) -&gt; \"Device\":\n    \"\"\"\n    Normalize the device geometry.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the normalized geometry.\n    \"\"\"\n    normalized_device_array = geometry.normalize(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": normalized_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.plot","title":"<code>plot(show_buffer=True, bounds=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the device geometry, optionally including buffer zones.</p> <p>This method allows for the visualization of the device geometry with an option to include buffer zones. It supports zooming into a specific area of the device. The visualization can be customized with various matplotlib parameters and can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p>"},{"location":"device/#prefab.device.Device.plot--parameters","title":"Parameters","text":"<p>show_buffer : bool, optional     If True, visualizes the buffer zones around the device to provide spatial     context. Defaults to True. bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional     Specifies the bounds for zooming into the device geometry, formatted as     ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it     will be replaced with the corresponding dimension size of the device array.     If None, the entire device geometry is visualized. ax : Optional[Axes], optional     An existing matplotlib Axes object to draw the device geometry on. If     None, a new figure and axes will be created. Defaults to None. **kwargs     Additional matplotlib parameters for plot customization.</p>"},{"location":"device/#prefab.device.Device.plot--returns","title":"Returns","text":"<p>Axes     The matplotlib Axes object containing the plot. This object can be used for     further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the device geometry, optionally including buffer zones.\n\n    This method allows for the visualization of the device geometry with an option\n    to include buffer zones. It supports zooming into a specific area of the device.\n    The visualization can be customized with various matplotlib parameters and can\n    be drawn on an existing matplotlib Axes object or create a new one if none is\n    provided.\n\n    Parameters\n    ----------\n    show_buffer : bool, optional\n        If True, visualizes the buffer zones around the device to provide spatial\n        context. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the device geometry on. If\n        None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the plot. This object can be used for\n        further plot customization or saving the plot after the method returns.\n    \"\"\"\n    _, ax = self._plot_base(\n        plot_array=self.device_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    return ax\n</code></pre>"},{"location":"device/#prefab.device.Device.plot_contour","title":"<code>plot_contour(linewidth=None, show_buffer=True, bounds=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the contour of the device along with optional buffer zones.</p> <p>This method plots the contour of the device geometry, emphasizing the edges and boundaries of the device. The contour plot can be customized with various matplotlib parameters, including line width and color. The plot can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p>"},{"location":"device/#prefab.device.Device.plot_contour--parameters","title":"Parameters","text":"<p>linewidth : Optional[int], optional     The width of the contour lines. If None, the linewidth is automatically     determined based on the size of the device array. Defaults to None. show_buffer : bool, optional     If True, the buffer zones around the device will be visualized. By default,     it is set to True. bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional     Specifies the bounds for zooming into the device geometry, formatted as     ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it     will be replaced with the corresponding dimension size of the device array.     If None, the entire device geometry is visualized. ax : Optional[Axes], optional     An existing matplotlib Axes object to draw the device contour on. If None, a     new figure and axes will be created. Defaults to None. **kwargs     Additional matplotlib parameters for plot customization.</p>"},{"location":"device/#prefab.device.Device.plot_contour--returns","title":"Returns","text":"<p>Axes     The matplotlib Axes object containing the contour plot. This can be used for     further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_contour(\n    self,\n    linewidth: Optional[int] = None,\n    # label: Optional[str] = \"Device contour\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the contour of the device along with optional buffer zones.\n\n    This method plots the contour of the device geometry, emphasizing the edges and\n    boundaries of the device. The contour plot can be customized with various\n    matplotlib parameters, including line width and color. The plot can be drawn on\n    an existing matplotlib Axes object or create a new one if none is provided.\n\n    Parameters\n    ----------\n    linewidth : Optional[int], optional\n        The width of the contour lines. If None, the linewidth is automatically\n        determined based on the size of the device array. Defaults to None.\n    show_buffer : bool, optional\n        If True, the buffer zones around the device will be visualized. By default,\n        it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the device contour on. If None, a\n        new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the contour plot. This can be used for\n        further customization or saving the plot after the method returns.\n    \"\"\"\n    kwargs.setdefault(\"cmap\", \"spring\")\n    if linewidth is None:\n        linewidth = self.device_array.shape[0] // 100\n\n    contours, _ = cv2.findContours(\n        geometry.binarize_hard(self.device_array).astype(np.uint8),\n        cv2.RETR_CCOMP,\n        cv2.CHAIN_APPROX_SIMPLE,\n    )\n    contour_array = np.zeros_like(self.device_array, dtype=np.uint8)\n    cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n    contour_array = np.ma.masked_equal(contour_array, 0)\n\n    _, ax = self._plot_base(\n        plot_array=contour_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n    # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n    # ax.legend([legend_proxy], [label], loc=\"upper right\")\n    return ax\n</code></pre>"},{"location":"device/#prefab.device.Device.plot_uncertainty","title":"<code>plot_uncertainty(show_buffer=True, bounds=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the uncertainty in the edge positions of the predicted device.</p> <p>This method plots the uncertainty associated with the positions of the edges of the device. The uncertainty is represented as a gradient, with areas of higher uncertainty indicating a greater likelihood of the edge position from run to run (due to inconsistencies in the fabrication process). This visualization can help in identifying areas within the device geometry that may require design adjustments to improve fabrication consistency.</p>"},{"location":"device/#prefab.device.Device.plot_uncertainty--parameters","title":"Parameters","text":"<p>show_buffer : bool, optional     If True, the buffer zones around the device will also be visualized. By     default, it is set to True. bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional     Specifies the bounds for zooming into the device geometry, formatted as     ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it     will be replaced with the corresponding dimension size of the device array.     If None, the entire device geometry is visualized. ax : Optional[Axes], optional     An existing matplotlib Axes object to draw the uncertainty visualization on.     If None, a new figure and axes will be created. Defaults to None. **kwargs     Additional matplotlib parameters for plot customization.</p>"},{"location":"device/#prefab.device.Device.plot_uncertainty--returns","title":"Returns","text":"<p>Axes     The matplotlib Axes object containing the uncertainty visualization. This     can be used for further customization or saving the plot after the method     returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_uncertainty(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the uncertainty in the edge positions of the predicted device.\n\n    This method plots the uncertainty associated with the positions of the edges of\n    the device. The uncertainty is represented as a gradient, with areas of higher\n    uncertainty indicating a greater likelihood of the edge position from run to run\n    (due to inconsistencies in the fabrication process). This visualization can help\n    in identifying areas within the device geometry that may require design\n    adjustments to improve fabrication consistency.\n\n    Parameters\n    ----------\n    show_buffer : bool, optional\n        If True, the buffer zones around the device will also be visualized. By\n        default, it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the uncertainty visualization on.\n        If None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the uncertainty visualization. This\n        can be used for further customization or saving the plot after the method\n        returns.\n    \"\"\"\n    uncertainty_array = 1 - 2 * np.abs(0.5 - self.device_array)\n\n    mappable, ax = self._plot_base(\n        plot_array=uncertainty_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Uncertainty (a.u.)\")\n    return ax\n</code></pre>"},{"location":"device/#prefab.device.Device.predict","title":"<code>predict(model_name, model_tags, binarize=False)</code>","text":"<p>Predict the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process.</p>"},{"location":"device/#prefab.device.Device.predict--parameters","title":"Parameters","text":"<p>model_name : str     The name of the model to use for prediction. model_tags : list[str]     A list of tags associated with the model. These tags can be used to specify     model versions or configurations. binarize : bool, optional     If True, the predicted device geometry will be binarized using a threshold     method. This is useful for converting probabilistic predictions into binary     geometries. Defaults to False.</p>"},{"location":"device/#prefab.device.Device.predict--returns","title":"Returns","text":"<p>Device     A new instance of the Device class with the predicted geometry.</p>"},{"location":"device/#prefab.device.Device.predict--raises","title":"Raises","text":"<p>ValueError     If the prediction service returns an error or if the response from the     service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def predict(\n    self,\n    model_name: str,\n    model_tags: list[str],\n    binarize: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Predict the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless prediction service, which\n    uses a specified machine learning model to predict the outcome of the\n    nanofabrication process.\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model to use for prediction.\n    model_tags : list[str]\n        A list of tags associated with the model. These tags can be used to specify\n        model versions or configurations.\n    binarize : bool, optional\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries. Defaults to False.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the predicted geometry.\n\n    Raises\n    ------\n    ValueError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    return self._predict(\n        model_name=model_name,\n        model_tags=model_tags,\n        model_type=\"p\",\n        binarize=binarize,\n    )\n</code></pre>"},{"location":"device/#prefab.device.Device.rotate","title":"<code>rotate(angle)</code>","text":"<p>Rotate the device geometry by a given angle.</p>"},{"location":"device/#prefab.device.Device.rotate--parameters","title":"Parameters","text":"<p>angle : float     The angle of rotation in degrees. Positive values mean counter-clockwise     rotation.</p>"},{"location":"device/#prefab.device.Device.rotate--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the rotated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def rotate(self, angle: float) -&gt; \"Device\":\n    \"\"\"\n    Rotate the device geometry by a given angle.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the rotated geometry.\n    \"\"\"\n    rotated_device_array = geometry.rotate(\n        device_array=self.device_array, angle=angle\n    )\n    return self.model_copy(update={\"device_array\": rotated_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.semulate","title":"<code>semulate(model_name, model_tags)</code>","text":"<p>Simulate the appearance of the device as if viewed under a Scanning Electron Microscope (SEM).</p> <p>This method applies a specified machine learning model to transform the device geometry into a style that resembles an SEM image. This can be useful for visualizing how the device might appear under an SEM, which is often used for inspecting the surface and composition of materials at high magnification.</p>"},{"location":"device/#prefab.device.Device.semulate--parameters","title":"Parameters","text":"<p>model_name : str     The name of the model to use for correction. model_tags : list[str]     A list of tags associated with the model. These tags can be used to specify     model versions or configurations.</p>"},{"location":"device/#prefab.device.Device.semulate--returns","title":"Returns","text":"<p>Device     A new instance of the Device class with its geometry transformed to simulate     an SEM image style.</p> Source code in <code>prefab/device.py</code> <pre><code>def semulate(\n    self,\n    model_name: str,\n    model_tags: list[str],\n) -&gt; \"Device\":\n    \"\"\"\n    Simulate the appearance of the device as if viewed under a Scanning Electron\n    Microscope (SEM).\n\n    This method applies a specified machine learning model to transform the device\n    geometry into a style that resembles an SEM image. This can be useful for\n    visualizing how the device might appear under an SEM, which is often used for\n    inspecting the surface and composition of materials at high magnification.\n\n    Parameters\n    ----------\n    model_name : str\n        The name of the model to use for correction.\n    model_tags : list[str]\n        A list of tags associated with the model. These tags can be used to specify\n        model versions or configurations.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with its geometry transformed to simulate\n        an SEM image style.\n    \"\"\"\n    return self._predict(\n        model_name=model_name,\n        model_tags=model_tags,\n        model_type=\"s\",\n    )\n</code></pre>"},{"location":"device/#prefab.device.Device.ternarize","title":"<code>ternarize(eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the device geometry based on two thresholds.</p>"},{"location":"device/#prefab.device.Device.ternarize--parameters","title":"Parameters","text":"<p>eta1 : float, optional     The first threshold value for ternarization. Defaults to 1/3. eta2 : float, optional     The second threshold value for ternarization. Defaults to 2/3.</p>"},{"location":"device/#prefab.device.Device.ternarize--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the ternarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n    \"\"\"\n    Ternarize the device geometry based on two thresholds.\n\n    Parameters\n    ----------\n    eta1 : float, optional\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float, optional\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the ternarized geometry.\n    \"\"\"\n    ternarized_device_array = geometry.ternarize(\n        device_array=self.device_array, eta1=eta1, eta2=eta2\n    )\n    return self.model_copy(update={\"device_array\": ternarized_device_array})\n</code></pre>"},{"location":"device/#prefab.device.Device.to_gds","title":"<code>to_gds(gds_path='prefab_device.gds', cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2)</code>","text":"<p>Exports the device geometry as a GDSII file.</p> <p>This method converts the device geometry into a format suitable for GDSII files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p>"},{"location":"device/#prefab.device.Device.to_gds--parameters","title":"Parameters","text":"<p>gds_path : str, optional     The path where the GDSII file will be saved. If not specified, the file is     saved as \"prefab_device.gds\" in the current directory. cell_name : str, optional     The name of the cell within the GDSII file. If not specified, defaults to     \"prefab_device\". gds_layer : tuple[int, int], optional     The layer and datatype to use within the GDSII file. Defaults to (1, 0). contour_approx_mode : int, optional     The mode of contour approximation used during the conversion. Defaults to 2,     which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses     horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gds(\n    self,\n    gds_path: str = \"prefab_device.gds\",\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n):\n    \"\"\"\n    Exports the device geometry as a GDSII file.\n\n    This method converts the device geometry into a format suitable for GDSII files.\n    The conversion involves contour approximation to simplify the geometry while\n    preserving essential features.\n\n    Parameters\n    ----------\n    gds_path : str, optional\n        The path where the GDSII file will be saved. If not specified, the file is\n        saved as \"prefab_device.gds\" in the current directory.\n    cell_name : str, optional\n        The name of the cell within the GDSII file. If not specified, defaults to\n        \"prefab_device\".\n    gds_layer : tuple[int, int], optional\n        The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n    contour_approx_mode : int, optional\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    \"\"\"\n    gdstk_cell = self._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n    )\n    print(f\"Saving GDS to '{gds_path}'...\")\n    gdstk_library = gdstk.Library()\n    gdstk_library.add(gdstk_cell)\n    gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n</code></pre>"},{"location":"device/#prefab.device.Device.to_gdstk","title":"<code>to_gdstk(cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2)</code>","text":"<p>Converts the device geometry to a GDSTK cell object.</p> <p>This method prepares the device geometry for GDSII file export by converting it into a GDSTK cell object. GDSTK is a Python module for creating and manipulating GDSII layout files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p>"},{"location":"device/#prefab.device.Device.to_gdstk--parameters","title":"Parameters","text":"<p>cell_name : str, optional     The name of the cell to be created. Defaults to \"prefab_device\". gds_layer : tuple[int, int], optional     The layer and datatype to use within the GDSTK cell. Defaults to (1, 0). contour_approx_mode : int, optional     The mode of contour approximation used during the conversion. Defaults to 2,     which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses     horizontal, vertical, and diagonal segments and leaves only their endpoints.</p>"},{"location":"device/#prefab.device.Device.to_gdstk--returns","title":"Returns","text":"<p>gdstk.Cell     The GDSTK cell object representing the device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdstk(\n    self,\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n):\n    \"\"\"\n    Converts the device geometry to a GDSTK cell object.\n\n    This method prepares the device geometry for GDSII file export by converting it\n    into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n    GDSII layout files. The conversion involves contour approximation to simplify\n    the geometry while preserving essential features.\n\n    Parameters\n    ----------\n    cell_name : str, optional\n        The name of the cell to be created. Defaults to \"prefab_device\".\n    gds_layer : tuple[int, int], optional\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    contour_approx_mode : int, optional\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n\n    Returns\n    -------\n    gdstk.Cell\n        The GDSTK cell object representing the device geometry.\n    \"\"\"\n    print(f\"Creating cell '{cell_name}'...\")\n    gdstk_cell = self._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n    )\n    return gdstk_cell\n</code></pre>"},{"location":"device/#prefab.device.Device.to_img","title":"<code>to_img(img_path='prefab_device.png')</code>","text":"<p>Exports the device geometry as an image file.</p> <p>This method converts the device geometry to a numpy ndarray using <code>to_ndarray</code>, scales the values to the range [0, 255] for image representation, and saves the result as an image file.</p>"},{"location":"device/#prefab.device.Device.to_img--parameters","title":"Parameters","text":"<p>img_path : str, optional     The path where the image file will be saved. If not specified, the image is     saved as \"prefab_device.png\" in the current directory.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_img(self, img_path: str = \"prefab_device.png\"):\n    \"\"\"\n    Exports the device geometry as an image file.\n\n    This method converts the device geometry to a numpy ndarray using `to_ndarray`,\n    scales the values to the range [0, 255] for image representation, and saves the\n    result as an image file.\n\n    Parameters\n    ----------\n    img_path : str, optional\n        The path where the image file will be saved. If not specified, the image is\n        saved as \"prefab_device.png\" in the current directory.\n    \"\"\"\n    cv2.imwrite(img_path, 255 * self.to_ndarray())\n    print(f\"Saved Device to '{img_path}'\")\n</code></pre>"},{"location":"device/#prefab.device.Device.to_ndarray","title":"<code>to_ndarray()</code>","text":"<p>Converts the device geometry to a numpy ndarray.</p> <p>This method applies the buffer specifications to crop the device array if necessary, based on the buffer mode ('edge' or 'constant'). It then returns the resulting numpy ndarray representing the device geometry.</p>"},{"location":"device/#prefab.device.Device.to_ndarray--returns","title":"Returns","text":"<p>np.ndarray     The numpy ndarray representation of the device geometry, with any applied     buffer cropping.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_ndarray(self) -&gt; np.ndarray:\n    \"\"\"\n    Converts the device geometry to a numpy ndarray.\n\n    This method applies the buffer specifications to crop the device array if\n    necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n    resulting numpy ndarray representing the device geometry.\n\n    Returns\n    -------\n    np.ndarray\n        The numpy ndarray representation of the device geometry, with any applied\n        buffer cropping.\n    \"\"\"\n    device_array = np.copy(self.device_array)\n    buffer_thickness = self.buffer_spec.thickness\n    buffer_mode = self.buffer_spec.mode\n\n    crop_top = buffer_thickness if buffer_mode[\"top\"] == \"edge\" else 0\n    crop_bottom = buffer_thickness if buffer_mode[\"bottom\"] == \"edge\" else 0\n    crop_left = buffer_thickness if buffer_mode[\"left\"] == \"edge\" else 0\n    crop_right = buffer_thickness if buffer_mode[\"right\"] == \"edge\" else 0\n\n    ndarray = device_array[\n        crop_top : device_array.shape[0] - crop_bottom,\n        crop_left : device_array.shape[1] - crop_right,\n    ]\n    return ndarray\n</code></pre>"},{"location":"device/#prefab.device.Device.trim","title":"<code>trim()</code>","text":"<p>Trim the device geometry by removing empty space around it.</p>"},{"location":"device/#prefab.device.Device.trim--parameters","title":"Parameters","text":"<p>buffer_thickness : int, optional     The thickness of the buffer to leave around the empty space. Defaults to 0,     which means no buffer is added.</p>"},{"location":"device/#prefab.device.Device.trim--returns","title":"Returns","text":"<p>Device     A new instance of the Device with the trimmed geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def trim(self) -&gt; \"Device\":\n    \"\"\"\n    Trim the device geometry by removing empty space around it.\n\n    Parameters\n    ----------\n    buffer_thickness : int, optional\n        The thickness of the buffer to leave around the empty space. Defaults to 0,\n        which means no buffer is added.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the trimmed geometry.\n    \"\"\"\n    trimmed_device_array = geometry.trim(\n        device_array=self.device_array,\n        buffer_thickness=self.buffer_spec.thickness,\n    )\n    return self.model_copy(update={\"device_array\": trimmed_device_array})\n</code></pre>"},{"location":"geometry/","title":"Geometry","text":"<p>Provides functions for manipulating numpy arrays of device geometries.</p>"},{"location":"geometry/#prefab.geometry.binarize","title":"<code>binarize(device_array, eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the input numpy array based on a threshold and a scaling factor.</p>"},{"location":"geometry/#prefab.geometry.binarize--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be binarized. eta : float, optional     The threshold value for binarization. Defaults to 0.5. beta : float, optional     The scaling factor for the binarization process. A higher value makes the     transition sharper. Defaults to np.inf, which results in a hard threshold.</p>"},{"location":"geometry/#prefab.geometry.binarize--returns","title":"Returns","text":"<p>np.ndarray     The binarized array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize(\n    device_array: np.ndarray, eta: float = 0.5, beta: float = np.inf\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input numpy array based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float, optional\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements scaled to 0 or 1.\n    \"\"\"\n    return (np.tanh(beta * eta) + np.tanh(beta * (device_array - eta))) / (\n        np.tanh(beta * eta) + np.tanh(beta * (1 - eta))\n    )\n</code></pre>"},{"location":"geometry/#prefab.geometry.binarize_hard","title":"<code>binarize_hard(device_array, eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the input numpy array.</p>"},{"location":"geometry/#prefab.geometry.binarize_hard--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be binarized. eta : float, optional     The threshold value for binarization. Defaults to 0.5.</p>"},{"location":"geometry/#prefab.geometry.binarize_hard--returns","title":"Returns","text":"<p>np.ndarray     The binarized array with elements set to 0 or 1 based on the threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_hard(device_array: np.ndarray, eta: float = 0.5) -&gt; np.ndarray:\n    \"\"\"\n    Apply a hard threshold to binarize the input numpy array.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the threshold.\n    \"\"\"\n    return np.where(device_array &lt; eta, 0.0, 1.0)\n</code></pre>"},{"location":"geometry/#prefab.geometry.binarize_monte_carlo","title":"<code>binarize_monte_carlo(device_array, threshold_noise_std, threshold_blur_std)</code>","text":"<p>Binarize the input numpy array using a Monte Carlo approach with Gaussian blurring.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the array using Gaussian blurring, simulating a more realistic scenario where the threshold is not uniform across the device.</p>"},{"location":"geometry/#prefab.geometry.binarize_monte_carlo--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be binarized. threshold_noise_std : float     The standard deviation of the Gaussian distribution used to generate noise for     the threshold values. This controls the amount of randomness in the threshold. threshold_blur_std : float     The standard deviation for the Gaussian kernel used in blurring the threshold     map. This controls the spatial variation of the threshold across the array.</p>"},{"location":"geometry/#prefab.geometry.binarize_monte_carlo--returns","title":"Returns","text":"<p>np.ndarray     The binarized array with elements set to 0 or 1 based on the dynamically     generated threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_monte_carlo(\n    device_array: np.ndarray,\n    threshold_noise_std: float,\n    threshold_blur_std: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input numpy array using a Monte Carlo approach with Gaussian blurring.\n\n    This function applies a dynamic thresholding technique where the threshold value is\n    determined by a base value perturbed by Gaussian-distributed random noise. The\n    threshold is then spatially varied across the array using Gaussian blurring,\n    simulating a more realistic scenario where the threshold is not uniform across the\n    device.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    threshold_noise_std : float\n        The standard deviation of the Gaussian distribution used to generate noise for\n        the threshold values. This controls the amount of randomness in the threshold.\n    threshold_blur_std : float\n        The standard deviation for the Gaussian kernel used in blurring the threshold\n        map. This controls the spatial variation of the threshold across the array.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the dynamically\n        generated threshold.\n    \"\"\"\n    base_threshold = np.clip(np.random.normal(loc=0.5, scale=0.5 / 2), 0.4, 0.6)\n    threshold_noise = np.random.normal(\n        loc=0, scale=threshold_noise_std, size=device_array.shape\n    )\n    spatial_threshold = cv2.GaussianBlur(\n        threshold_noise, ksize=(0, 0), sigmaX=threshold_blur_std\n    )\n    dynamic_threshold = base_threshold + spatial_threshold\n    return np.where(device_array &lt; dynamic_threshold, 0.0, 1.0)\n</code></pre>"},{"location":"geometry/#prefab.geometry.binarize_sem","title":"<code>binarize_sem(sem_array)</code>","text":"<p>Binarize a grayscale SEM (Scanning Electron Microscope) image.</p> <p>This function applies Otsu's method to automatically determine the optimal threshold value for binarization of a grayscale SEM image.</p>"},{"location":"geometry/#prefab.geometry.binarize_sem--parameters","title":"Parameters","text":"<p>sem_array : np.ndarray     The input SEM image array to be binarized.</p>"},{"location":"geometry/#prefab.geometry.binarize_sem--returns","title":"Returns","text":"<p>np.ndarray     The binarized SEM image array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_sem(sem_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Binarize a grayscale SEM (Scanning Electron Microscope) image.\n\n    This function applies Otsu's method to automatically determine the optimal threshold\n    value for binarization of a grayscale SEM image.\n\n    Parameters\n    ----------\n    sem_array : np.ndarray\n        The input SEM image array to be binarized.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized SEM image array with elements scaled to 0 or 1.\n    \"\"\"\n    return cv2.threshold(\n        sem_array.astype(\"uint8\"), 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU\n    )[1]\n</code></pre>"},{"location":"geometry/#prefab.geometry.blur","title":"<code>blur(device_array, sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the input numpy array and normalize the result.</p>"},{"location":"geometry/#prefab.geometry.blur--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be blurred. sigma : float, optional     The standard deviation for the Gaussian kernel. This controls the amount of     blurring. Defaults to 1.0.</p>"},{"location":"geometry/#prefab.geometry.blur--returns","title":"Returns","text":"<p>np.ndarray     The blurred and normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def blur(device_array: np.ndarray, sigma: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Apply Gaussian blur to the input numpy array and normalize the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be blurred.\n    sigma : float, optional\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        The blurred and normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return normalize(cv2.GaussianBlur(device_array, ksize=(0, 0), sigmaX=sigma))\n</code></pre>"},{"location":"geometry/#prefab.geometry.dilate","title":"<code>dilate(device_array, kernel_size)</code>","text":"<p>Dilate the input numpy array using a specified kernel size.</p>"},{"location":"geometry/#prefab.geometry.dilate--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array representing the device geometry to be dilated. kernel_size : int     The size of the kernel used for dilation.</p>"},{"location":"geometry/#prefab.geometry.dilate--returns","title":"Returns","text":"<p>np.ndarray     The dilated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def dilate(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Dilate the input numpy array using a specified kernel size.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be dilated.\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    np.ndarray\n        The dilated array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return cv2.dilate(device_array, kernel=kernel)\n</code></pre>"},{"location":"geometry/#prefab.geometry.erode","title":"<code>erode(device_array, kernel_size)</code>","text":"<p>Erode the input numpy array using a specified kernel size and number of iterations.</p>"},{"location":"geometry/#prefab.geometry.erode--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array representing the device geometry to be eroded. kernel_size : int     The size of the kernel used for erosion.</p>"},{"location":"geometry/#prefab.geometry.erode--returns","title":"Returns","text":"<p>np.ndarray     The eroded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def erode(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Erode the input numpy array using a specified kernel size and number of iterations.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be eroded.\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    np.ndarray\n        The eroded array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return cv2.erode(device_array, kernel=kernel)\n</code></pre>"},{"location":"geometry/#prefab.geometry.normalize","title":"<code>normalize(device_array)</code>","text":"<p>Normalize the input numpy array to have values between 0 and 1.</p>"},{"location":"geometry/#prefab.geometry.normalize--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be normalized.</p>"},{"location":"geometry/#prefab.geometry.normalize--returns","title":"Returns","text":"<p>np.ndarray     The normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def normalize(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Normalize the input numpy array to have values between 0 and 1.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be normalized.\n\n    Returns\n    -------\n    np.ndarray\n        The normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return (device_array - np.min(device_array)) / (\n        np.max(device_array) - np.min(device_array)\n    )\n</code></pre>"},{"location":"geometry/#prefab.geometry.rotate","title":"<code>rotate(device_array, angle)</code>","text":"<p>Rotate the input numpy array by a given angle.</p>"},{"location":"geometry/#prefab.geometry.rotate--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be rotated. angle : float     The angle of rotation in degrees. Positive values mean counter-clockwise     rotation.</p>"},{"location":"geometry/#prefab.geometry.rotate--returns","title":"Returns","text":"<p>np.ndarray     The rotated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def rotate(device_array: np.ndarray, angle: float) -&gt; np.ndarray:\n    \"\"\"\n    Rotate the input numpy array by a given angle.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be rotated.\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    np.ndarray\n        The rotated array.\n    \"\"\"\n    center = (device_array.shape[1] / 2, device_array.shape[0] / 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center=center, angle=angle, scale=1)\n    return cv2.warpAffine(\n        device_array,\n        M=rotation_matrix,\n        dsize=(device_array.shape[1], device_array.shape[0]),\n    )\n</code></pre>"},{"location":"geometry/#prefab.geometry.ternarize","title":"<code>ternarize(device_array, eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the input numpy array based on two thresholds.</p>"},{"location":"geometry/#prefab.geometry.ternarize--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be ternarized. eta1 : float, optional     The first threshold value for ternarization. Defaults to 1/3. eta2 : float, optional     The second threshold value for ternarization. Defaults to 2/3.</p>"},{"location":"geometry/#prefab.geometry.ternarize--returns","title":"Returns","text":"<p>np.ndarray     The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def ternarize(\n    device_array: np.ndarray, eta1: float = 1 / 3, eta2: float = 2 / 3\n) -&gt; np.ndarray:\n    \"\"\"\n    Ternarize the input numpy array based on two thresholds.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be ternarized.\n    eta1 : float, optional\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float, optional\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    np.ndarray\n        The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.\n    \"\"\"\n    return np.where(device_array &lt; eta1, 0.0, np.where(device_array &gt;= eta2, 1.0, 0.5))\n</code></pre>"},{"location":"geometry/#prefab.geometry.trim","title":"<code>trim(device_array, buffer_thickness=0)</code>","text":"<p>Trim the input numpy array by removing rows and columns that are completely zero.</p>"},{"location":"geometry/#prefab.geometry.trim--parameters","title":"Parameters","text":"<p>device_array : np.ndarray     The input array to be trimmed. buffer_thickness : int, optional     The thickness of the buffer to leave around the non-zero elements of the array.     Defaults to 0, which means no buffer is added.</p>"},{"location":"geometry/#prefab.geometry.trim--returns","title":"Returns","text":"<p>np.ndarray     The trimmed array, potentially with a buffer around the non-zero elements.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def trim(device_array: np.ndarray, buffer_thickness: int = 0) -&gt; np.ndarray:\n    \"\"\"\n    Trim the input numpy array by removing rows and columns that are completely zero.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be trimmed.\n    buffer_thickness : int, optional\n        The thickness of the buffer to leave around the non-zero elements of the array.\n        Defaults to 0, which means no buffer is added.\n\n    Returns\n    -------\n    np.ndarray\n        The trimmed array, potentially with a buffer around the non-zero elements.\n    \"\"\"\n    nonzero_rows, nonzero_cols = np.nonzero(device_array)\n    row_min = max(nonzero_rows.min() - buffer_thickness, 0)\n    row_max = min(\n        nonzero_rows.max() + buffer_thickness + 1,\n        device_array.shape[0],\n    )\n    col_min = max(nonzero_cols.min() - buffer_thickness, 0)\n    col_max = min(\n        nonzero_cols.max() + buffer_thickness + 1,\n        device_array.shape[1],\n    )\n    return device_array[\n        row_min:row_max,\n        col_min:col_max,\n    ]\n</code></pre>"},{"location":"models/","title":"Models","text":"<p><code>PreFab</code> accommodates unique predictor and corrector models for each photonic foundry, regularly updated based on recent fabrication data.</p> Foundry Process Latest Version Latest Dataset Model Name Model Tag Status ANT NanoSOI v5 (Jun 3 2023) d4 (Apr 12 2023) ANT_NanoSOI v5-d4 Beta ANT NanoSOI v6 (Nov 24 2023) d7 (Nov 24 2023) ANT_NanoSOI v6-d7 Beta ANT NanoSOI v6 (Nov 24 2023) d8 (Feb 6 2024) ANT_NanoSOI v6-d8 Beta ANT SiN (Upper Edge) v5 (Jun 3 2023) d0 (Jun 1 2023) ANT_SiN v5-d0-upper Alpha ANT SiN (Lower Edge) v5 (Jun 3 2023) d0 (Jun 1 2023) ANT_SiN v5-d0-lower Alpha <p>New models and foundries are regularly added. Usage may change. For additional foundry and process models, feel free to contact us or raise an issue.</p>"},{"location":"read/","title":"Read","text":"<p>Provides functions to create Devices from various data sources.</p>"},{"location":"read/#prefab.read.from_gds","title":"<code>from_gds(gds_path, cell_name, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a GDS cell.</p>"},{"location":"read/#prefab.read.from_gds--parameters","title":"Parameters","text":"<p>gds_path : str     The file path to the GDS file. cell_name : str     The name of the cell within the GDS file to be converted into a Device object. gds_layer : tuple[int, int], optional     A tuple specifying the layer and datatype to be used from the GDS file. Defaults     to (1, 0). bounds : tuple[tuple[int, int], tuple[int, int]], optional     A tuple specifying the bounds for cropping the cell before conversion, formatted     as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the     entire cell is used. **kwargs     Additional keyword arguments to be passed to the Device constructor.</p>"},{"location":"read/#prefab.read.from_gds--returns","title":"Returns","text":"<p>Device     A Device object representing the specified cell from the GDS file, after     processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gds(\n    gds_path: str,\n    cell_name: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a GDS cell.\n\n    Parameters\n    ----------\n    gds_path : str\n        The file path to the GDS file.\n    cell_name : str\n        The name of the cell within the GDS file to be converted into a Device object.\n    gds_layer : tuple[int, int], optional\n        A tuple specifying the layer and datatype to be used from the GDS file. Defaults\n        to (1, 0).\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the specified cell from the GDS file, after\n        processing based on the specified layer.\n    \"\"\"\n    gdstk_library = gdstk.read_gds(gds_path)\n    gdstk_cell = gdstk_library[cell_name]\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"read/#prefab.read.from_gdstk","title":"<code>from_gdstk(gdstk_cell, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a gdstk cell.</p>"},{"location":"read/#prefab.read.from_gdstk--parameters","title":"Parameters","text":"<p>gdstk_cell : gdstk.Cell     The gdstk.Cell object to be converted into a Device object. gds_layer : tuple[int, int], optional     A tuple specifying the layer and datatype to be used. Defaults to (1, 0). bounds : tuple[tuple[int, int], tuple[int, int]], optional     A tuple specifying the bounds for cropping the cell before conversion, formatted     as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the     entire cell is used. **kwargs     Additional keyword arguments to be passed to the Device constructor.</p>"},{"location":"read/#prefab.read.from_gdstk--returns","title":"Returns","text":"<p>Device     A Device object representing the gdstk.Cell, after processing based on the     specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdstk(\n    gdstk_cell: gdstk.Cell,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a gdstk cell.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object to be converted into a Device object.\n    gds_layer : tuple[int, int], optional\n        A tuple specifying the layer and datatype to be used. Defaults to (1, 0).\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdstk.Cell, after processing based on the\n        specified layer.\n    \"\"\"\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"read/#prefab.read.from_img","title":"<code>from_img(img_path, img_width_nm=None, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an image file.</p>"},{"location":"read/#prefab.read.from_img--parameters","title":"Parameters","text":"<p>img_path : str     The path to the image file to be converted into a Device object. img_width_nm : int, optional     The desired width of the device in nanometers. If specified, the image will be     resized to this width while maintaining aspect ratio. If None, no resizing is     performed. binarize : bool, optional     If True, the image will be binarized (converted to binary values) before     conversion to a Device object. This is useful for converting grayscale images     into binary masks. Defaults to True. **kwargs     Additional keyword arguments to be passed to the Device constructor.</p>"},{"location":"read/#prefab.read.from_img--returns","title":"Returns","text":"<p>Device     A Device object representing the processed image, after optional resizing and     binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_img(\n    img_path: str, img_width_nm: int = None, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path to the image file to be converted into a Device object.\n    img_width_nm : int, optional\n        The desired width of the device in nanometers. If specified, the image will be\n        resized to this width while maintaining aspect ratio. If None, no resizing is\n        performed.\n    binarize : bool, optional\n        If True, the image will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for converting grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed image, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = cv2.imread(img_path, flags=cv2.IMREAD_GRAYSCALE) / 255\n    if img_width_nm is not None:\n        scale = img_width_nm / device_array.shape[1]\n        device_array = cv2.resize(device_array, dsize=(0, 0), fx=scale, fy=scale)\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"read/#prefab.read.from_ndarray","title":"<code>from_ndarray(ndarray, ndarray_width_nm=None, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an ndarray.</p>"},{"location":"read/#prefab.read.from_ndarray--parameters","title":"Parameters","text":"<p>ndarray : np.ndarray     The input array representing the device layout. ndarray_width_nm : int, optional     The desired width of the device in nanometers. If specified, the input array     will be resized to this width while maintaining aspect ratio. If None, no     resizing is performed. binarize : bool, optional     If True, the input array will be binarized (converted to binary values) before     conversion to a Device object. This is useful for processing grayscale images     into binary masks. Defaults to True. **kwargs     Additional keyword arguments to be passed to the Device constructor.</p>"},{"location":"read/#prefab.read.from_ndarray--returns","title":"Returns","text":"<p>Device     A Device object representing the input array, after optional resizing and     binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_ndarray(\n    ndarray: np.ndarray, ndarray_width_nm: int = None, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an ndarray.\n\n    Parameters\n    ----------\n    ndarray : np.ndarray\n        The input array representing the device layout.\n    ndarray_width_nm : int, optional\n        The desired width of the device in nanometers. If specified, the input array\n        will be resized to this width while maintaining aspect ratio. If None, no\n        resizing is performed.\n    binarize : bool, optional\n        If True, the input array will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the input array, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = ndarray\n    if ndarray_width_nm is not None:\n        scale = ndarray_width_nm / device_array.shape[1]\n        device_array = cv2.resize(device_array, dsize=(0, 0), fx=scale, fy=scale)\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"read/#prefab.read.from_sem","title":"<code>from_sem(sem_path, sem_resolution=None, sem_resolution_key=None, binarize=True, bounds=None, **kwargs)</code>","text":"<p>Create a Device from a Scanning Electron Microscope (SEM) image file.</p>"},{"location":"read/#prefab.read.from_sem--parameters","title":"Parameters","text":"<p>sem_path : str     The file path to the SEM image. sem_resolution : float, optional     The resolution of the SEM image in nanometers per pixel. If not provided, it     will be extracted from the image metadata using the <code>sem_resolution_key</code>. sem_resolution_key : str, optional     The key to look for in the SEM image metadata to extract the resolution.     Required if <code>sem_resolution</code> is not provided. binarize : bool, optional     If True, the SEM image will be binarized (converted to binary values) before     conversion to a Device object. This is useful for processing grayscale images     into binary masks. Defaults to True. bounds : tuple[tuple[int, int], tuple[int, int]], optional     A tuple specifying the bounds for cropping the image before conversion,     formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is     used. **kwargs     Additional keyword arguments to be passed to the Device constructor.</p>"},{"location":"read/#prefab.read.from_sem--returns","title":"Returns","text":"<p>Device     A Device object representing the processed SEM image.</p>"},{"location":"read/#prefab.read.from_sem--raises","title":"Raises","text":"<p>ValueError     If neither <code>sem_resolution</code> nor <code>sem_resolution_key</code> is provided.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_sem(\n    sem_path: str,\n    sem_resolution: float = None,\n    sem_resolution_key: str = None,\n    binarize: bool = True,\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a Scanning Electron Microscope (SEM) image file.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution : float, optional\n        The resolution of the SEM image in nanometers per pixel. If not provided, it\n        will be extracted from the image metadata using the `sem_resolution_key`.\n    sem_resolution_key : str, optional\n        The key to look for in the SEM image metadata to extract the resolution.\n        Required if `sem_resolution` is not provided.\n    binarize : bool, optional\n        If True, the SEM image will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale images\n        into binary masks. Defaults to True.\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the image before conversion,\n        formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is\n        used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed SEM image.\n\n    Raises\n    ------\n    ValueError\n        If neither `sem_resolution` nor `sem_resolution_key` is provided.\n    \"\"\"\n    if sem_resolution is None and sem_resolution_key is not None:\n        sem_resolution = get_sem_resolution(sem_path, sem_resolution_key)\n    elif sem_resolution is None:\n        raise ValueError(\"Either sem_resolution or resolution_key must be provided.\")\n\n    device_array = cv2.imread(sem_path, flags=cv2.IMREAD_GRAYSCALE)\n    if sem_resolution is not None:\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=sem_resolution, fy=sem_resolution\n        )\n    if bounds is not None:\n        device_array = device_array[\n            -bounds[1][1] : -bounds[0][1], bounds[0][0] : bounds[1][0]\n        ]\n    if binarize:\n        device_array = geometry.binarize_sem(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"read/#prefab.read.get_sem_resolution","title":"<code>get_sem_resolution(sem_path, resolution_key)</code>","text":"<p>Extracts the resolution of a Scanning Electron Microscope (SEM) image from its metadata.</p>"},{"location":"read/#prefab.read.get_sem_resolution--parameters","title":"Parameters","text":"<p>sem_path : str     The file path to the SEM image. resolution_key : str     The key to look for in the SEM image metadata to extract the resolution.</p>"},{"location":"read/#prefab.read.get_sem_resolution--returns","title":"Returns","text":"<p>float     The resolution of the SEM image in nanometers per pixel.</p>"},{"location":"read/#prefab.read.get_sem_resolution--raises","title":"Raises","text":"<p>ValueError     If the resolution key is not found in the SEM image metadata.</p> Source code in <code>prefab/read.py</code> <pre><code>def get_sem_resolution(sem_path: str, resolution_key: str) -&gt; float:\n    \"\"\"\n    Extracts the resolution of a Scanning Electron Microscope (SEM) image from its\n    metadata.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    resolution_key : str\n        The key to look for in the SEM image metadata to extract the resolution.\n\n    Returns\n    -------\n    float\n        The resolution of the SEM image in nanometers per pixel.\n\n    Raises\n    ------\n    ValueError\n        If the resolution key is not found in the SEM image metadata.\n    \"\"\"\n    with open(sem_path, \"rb\") as file:\n        resolution_key_bytes = resolution_key.encode(\"utf-8\")\n        for line in file:\n            if resolution_key_bytes in line:\n                line_str = line.decode(\"utf-8\")\n                match = re.search(r\"-?\\d+(\\.\\d+)?\", line_str)\n                if match:\n                    value = float(match.group())\n                    if value &gt; 100:\n                        value /= 1000\n                    return value\n    raise ValueError(f\"Resolution key '{resolution_key}' not found in {sem_path}.\")\n</code></pre>"},{"location":"examples/1_prediction/","title":"1 prediction","text":"<p>This Jupyter notebook offers an interactive tutorial on utilizing the PreFab library to anticipate the fabrication outcomes of nanoscale structures, specifically a 500 nm-wide cross structure on a silicon-on-insulator (SOI) e-beam process. This tutorial is structured as follows:</p> <ol> <li>Preparing a device image for prediction</li> <li>Executing a prediction</li> <li>Analyzing the prediction</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import prefab as pf\n</code></pre> <p>The first step involves preparing a device image for prediction. This requires loading an image of a device as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use an image of a cross, but feel free to explore with other structures available in the <code>devices/</code> directory, or include your own images.</p> <p>The image scale should be 1 nm/px. If not, ensure you specify the actual length of the device image (in nanometers) when loading the image.</p> <pre><code>device = pf.read.from_img(\n    img_path=\"../../devices/cross_32x128_256x256.png\", img_width_nm=1000\n)\ndevice.plot()\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>In the next step, we proceed with the prediction. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for the list of available models.</p> <p>You can also choose if you want a binarized output. The predictor, by default, produces raw predictions, which includes \"fuzzy\" areas of the structure that might vary between different fabrication runs or even different device instances on the same chip. When binarized, the predictor outputs the most probable fabrication outcome (a threshold of 50%). Post-prediction binarization is also an option, as we'll show here.</p> <p>&gt; Note: Initial prediction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_NanoSOI\"\nMODEL_TAGS = \"v7-d9\"\nprediction = device.predict(model_name=MODEL_NAME, model_tags=MODEL_TAGS)\nprediction_bin = prediction.binarize()\n\nprediction.plot()\nprediction_bin.plot()\n\nprint(\n    f\"Prediction IoU: {pf.compare.intersection_over_union(device, prediction_bin):.2f}\"\n)\n</code></pre> <pre>\n<code>Prediction IoU: 0.86\n</code>\n</pre> <p>Lastly, we analyze the prediction. Plotting the variations between the nominal device and the predicted outcome is an effective analysis technique. It helps in identifying areas of high uncertainty, such as potential rounding of the cross's corners.</p> <pre><code>prediction.plot_uncertainty()\n\npf.compare.intersection_over_union(device, prediction_bin)\n</code></pre> <pre>\n<code>0.8562565007009452</code>\n</pre> <pre><code>variation = device - prediction\nplt.imshow(variation, cmap=\"jet\", vmin=-1, vmax=1)\nplt.title(\"Variation Likelihood\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\ncb = plt.colorbar()\ncb.set_label(\"Under-Etch              Over-Etch\")\nplt.show()\n\nplt.imshow(variation[60:120, 80:-80], cmap=\"jet\", vmin=-1, vmax=1)\nplt.title(\"Zoomed Variation Likelihood\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\ncb = plt.colorbar()\ncb.set_label(\"Under-Etch              Over-Etch\")\nplt.show()\n</code></pre> <p>And with that, we conclude this tutorial! You're now ready to use the prediction to simulate expected performance, or even to refine your design to decrease variation and uncertainty (refer to the device correction examples). Happy designing!</p>"},{"location":"examples/2_prediction_gds/","title":"2 prediction gds","text":"<p>This Jupyter notebook offers an engaging tutorial on using the PreFab library to predict the fabrication outcomes of a nanobeam structure, specifically imported from a GDS file, on a Silicon-On-Insulator (SOI) e-beam process. The tutorial encompasses:</p> <ol> <li>Importing a device from a GDS file</li> <li>Conducting a prediction</li> <li>Analyzing the prediction</li> <li>Writing the predicted device back to a GDS file</li> </ol> <p>Initially, let's import the necessary libraries:</p> <pre><code>import matplotlib.pyplot as plt\nimport prefab as pf\nimport gdstk\n</code></pre> <p>We commence by importing a nanobeam device from a GDS file, transforming the geometric data into a numpy matrix with pixel values of either 0 or 1. We use a specific nanobeam design in this tutorial, but feel free to experiment with other designs in <code>devices/devices.gds</code>, or input your own GDS file!</p> <pre><code>device = pf.load_device_gds(path=\"../devices/devices.gds\", cell_name=\"nanobeam\")\n\nplt.imshow(device)\nplt.title(\"Nominal Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>Next, we predict the fabrication result for our nanobeam. Each model is uniquely tagged by its type ('p' for predictor), the fabrication facility and process name, model version, and training dataset version. Refer to <code>docs/models.md</code> for the list of available models.</p> <p>The option to specify binarized output is also provided. The predictor by default generates raw predictions, inclusive of \"fuzzy\" areas of the structure that can vary across fabrication runs or even among different nanobeam instances on the same chip. Choosing binarized output lets the predictor supply the most probable post-fabrication outcome. Post-prediction binarization is also feasible, enabling comparison between raw and binarized predictions.</p> <pre><code># Note: Initial prediction may take longer due to server startup and model loading. Subsequent predictions should be quicker.\nMODEL_NAME = \"ANT_NanoSOI\"\nMODEL_TAGS = \"v6-d7\"\nprediction = pf.predict(device=device, model_name=MODEL_NAME, model_tags=MODEL_TAGS)\n\nplt.imshow(prediction)\nplt.title(\"Predicted Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>Finally, we proceed with an analysis of the prediction. A valuable approach here is to visualize potential deviations between the original nanobeam and the predicted outcome. This analysis can aid in identifying areas of high uncertainty in the fabrication process.</p> <p>For our nanobeam, for instance, we may notice filling of the first two innermost holes and a general dilation of the larger holes. These are fabrication process artifacts, and understanding their potential appearance helps us to better predict and plan for the actual outcome.</p> <pre><code>variation = device - prediction\nplt.imshow(variation, cmap=\"jet\", vmin=-1, vmax=1)\nplt.title(\"Variation Likelihood\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\ncb = plt.colorbar()\ncb.set_label(\"Under-Etch              Over-Etch\")\nplt.show()\n\nplt.imshow(variation[0:-1, 3000:-3000], cmap=\"jet\", vmin=-1, vmax=1)\nplt.title(\"Zoomed Variation Likelihood\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\ncb = plt.colorbar()\ncb.set_label(\"Under-Etch              Over-Etch\")\nplt.show()\n</code></pre> <p>Subsequently, we generate a GDS cell for the predicted binarized device and add it back to the original GDS library. The GDS file with the original and predicted devices can then be exported for further use or analysis.</p> <pre><code>gds_library = gdstk.read_gds(\"../devices/devices.gds\")\npredicted_nanobeam_cell = pf.device_to_cell(\n    device=pf.binarize(prediction),\n    cell_name=\"nanobeam_p\",\n    library=gds_library,\n    resolution=1,\n    layer=(9, 0),\n)\norigin = (-device.shape[1] / 2 / 1000, -device.shape[0] / 2 / 1000)\ngds_library[\"nanobeam\"].add(\n    gdstk.Reference(cell=predicted_nanobeam_cell, origin=origin)\n)\ngds_library.write_gds(outfile=\"../devices/devices.gds\")\n</code></pre> <p>With this, we conclude the tutorial! You're now empowered to employ the predicted model of your nanobeam device and conduct simulations to forecast its performance. Furthermore, you might want to refine your nanobeam design to decrease variations and uncertainty (refer to device correction examples). This newfound understanding enables you to enhance your device fabrication processes. Happy fabricating!</p>"},{"location":"examples/3_correction/","title":"3 correction","text":"<p>This Jupyter notebook offers a practical demonstration of how to utilize the <code>PreFab</code> library for correcting the fabrication of a target structure using a Silicon-On-Insulator (SOI) e-beam process. The tutorial is designed to help you navigate the following steps:</p> <ol> <li>Preparing an image of the fleur-de-lis structure for correction</li> <li>Executing the correction process</li> <li>Analyzing the results of the correction</li> </ol> <p>To begin, let's import the necessary libraries:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport prefab as pf\n</code></pre> <p>Initially, we prepare a device image for correction. This involves loading an image of a device as a numpy matrix. Pixel values should be binary: 0 or 1. For this tutorial, we use an image of a target, but feel free to try other devices in the devices/ directory, or even add your own images.</p> <p>Please remember that the image scale should be 1 nm/px. If it's not, ensure you specify the actual length of the device image (in nm) when loading the image.</p> <pre><code>IMG_LENGTH_NM = 1000\ndevice = pf.load_device_img(\n    path=\"../devices/target_32x128_256x256.png\", img_length_nm=IMG_LENGTH_NM\n)\n\nplt.imshow(device)\nplt.title(\"Nominal Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>Next, we perform the correction on our target structure. Each model is distinctively identified by the name of the fabrication facility and process, the model version, and the dataset version used for training. Please refer to docs/models.md for a list of available models.</p> <p>At this point, we will opt for a binarized output. By default, the corrector provides raw corrections, which include \"fuzzy\" or uncertain areas of the structure that may vary between different fabrication runs or even between different instances of the same target structure on the same chip. However, choosing a binarized output, the corrector will output the most likely corrected design, creating a fabricatable structure. It's also possible to binarize the output post-correction, allowing you to compare both the raw and binarized corrections.</p> <pre><code># Performance note: The first correction might take longer as the cloud server starts and loads the necessary model(s). Subsequent predictions should be quicker.\nMODEL_NAME = \"ANT_NanoSOI\"\nMODEL_TAGS = \"v6-d7\"\ncorrection = pf.correct(\n    device=device, model_name=MODEL_NAME, model_tags=MODEL_TAGS, binarize=True\n)\n\nplt.imshow(pf.binarize(correction))\nplt.title(\"Corrected Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>Our next step is to visualize the difference between the nominal and corrected designs for the target structure. The corrector compensates for expected fabrication errors by adjusting the design. It adds silicon in places where it predicts an over-etch and removes silicon where it predicts an under-etch.</p> <pre><code>variation = device - correction\nplt.imshow(variation, cmap=\"jet\", vmin=-1, vmax=1)\nplt.title(\"Changes to Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\ncb = plt.colorbar()\ncb.set_label(\"Added Silicon                    Removed Silicon\")\nplt.show()\n</code></pre> <p>In the next step, we predict the fabrication outcomes for both the nominal and corrected target structures using the prediction model. We then visualize the predicted outcomes, highlighting the fidelity improvements achieved through the correction process.</p> <p>In the corrected design, the corners are expected to be sharper and the middle openings are better resolved compared to the nominal design. Additionally, the Intersection over Union (IoU) score, a common metric for comparing the similarity of two designs, is improved. This means that the corrected design will more closely match the intended design, leading to better fabrication outcomes.</p> <pre><code>outcome = pf.predict(\n    device=correction, model_name=MODEL_NAME, model_tags=MODEL_TAGS, binarize=True\n)\nprediction = pf.predict(\n    device=device, model_name=MODEL_NAME, model_tags=MODEL_TAGS, binarize=True\n)\n\ndef calculate_iou(prediction, device):\n    intersection = np.logical_and(prediction, device)\n    union = np.logical_or(prediction, device)\n    iou_score = np.sum(intersection) / np.sum(union)\n    return iou_score\n\niou_nominal = calculate_iou(prediction, device)\niou_corrected = calculate_iou(outcome, device)\n\nfig, axs = plt.subplots(1, 3, figsize=(15, 5))\naxs[0].imshow(prediction)\naxs[0].imshow(pf.generate_device_contour(device), cmap=\"cool\")\naxs[0].set_title(f\"Prediction of Nominal Device (IOU: {iou_nominal:.2f})\")\naxs[0].set_ylabel(\"Distance (nm)\")\naxs[0].set_xlabel(\"Distance (nm)\")\naxs[1].imshow(outcome)\naxs[1].imshow(pf.generate_device_contour(device), cmap=\"cool\")\naxs[1].set_title(f\"Prediction of Corrected Device (IOU: {iou_corrected:.2f})\")\naxs[1].set_xlabel(\"Distance (nm)\")\naxs[2].imshow(prediction - outcome, cmap=\"jet\", vmin=-1, vmax=1)\naxs[2].set_title(\"Improvement From Correction\")\naxs[2].set_xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>This concludes our tutorial! You are now ready to leverage the corrected model of your device to run simulations and anticipate its post-fabrication performance. This expertise enables you to improve the accuracy and repeatability of your nanostructures. We wish you the best in your future fabrication endeavors!</p>"},{"location":"examples/4_prediction_silicon_nitride/","title":"4 prediction silicon nitride","text":"<p>This Jupyter notebook offers an interactive tutorial on utilizing the PreFab library to anticipate the fabrication outcomes of nanoscale structures, specifically for a silicon nitride process with angled sidewalls. This tutorial is structured as follows:</p> <ol> <li>Preparing a device image for prediction</li> <li>Executing a prediction for each edge</li> <li>Interpreting the prediction</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import matplotlib.pyplot as plt\nimport prefab as pf\n</code></pre> <p>The first step involves preparing a device image for prediction. This requires loading an image of a device as a numpy matrix with binary pixel values: 0 or 1. In this tutorial, we'll use an image of a small ring, but feel free to explore with other structures available in the <code>devices/</code> directory, or include your own images.</p> <p>The image scale should ideally be 1 nm/px. If not, ensure you specify the actual length of the device image (in nanometers) when loading the image. Please feel free to explore other device lengths as well.</p> <pre><code>device = pf.load_device_img(\n    path=\"../devices/ring_64x128_256x256.png\", img_length_nm=1000\n)\n\nplt.imshow(device)\nplt.title(\"Nominal Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>In the next step, we proceed with the prediction for the angled sidewall process. Each model is labeled by its type ('p' for predictor), fabrication facility and process name, model version, and dataset version. We use upper and lower model_tag suffixes to do two predictions, one for each edge. Refer to <code>docs/models.md</code> for the list of available models.</p> <p>You can also choose if you want a ternarized output. The predictor, by default, produces raw predictions, which includes \"fuzzy\" areas of the structure that might vary between different fabrication runs or even different device instances on the same chip. When ternarized, the predictor outputs the most probable fabrication outcome.</p> <pre><code># Note: Initial prediction may take longer due to server startup and model loading. Subsequent predictions should be quicker.\nMODEL_NAME = \"ANT_SiN\"\nMODEL_TAGS = [\"v5-d0-upper\", \"v5-d0-lower\"]\nprediction = pf.predict(device=device, model_name=MODEL_NAME, model_tags=MODEL_TAGS)\n\nplt.imshow(prediction)\nplt.title(\"Predicted Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n\nplt.imshow(pf.ternarize(prediction))\nplt.title(\"Ternarized Predicted Device\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>Finally, we examine the prediction. By overlaying the contour of the original device on the predicted outcome, we can observe the extent of over-etching on the upper edge and under-etching on the lower edge.</p> <pre><code>plt.imshow(pf.ternarize(prediction))\nplt.imshow(pf.generate_device_contour(prediction), cmap=\"spring\")\nplt.title(\"Ternarized Predicted Device\\nWith Contour Overlay\")\nplt.ylabel(\"Distance (nm)\")\nplt.xlabel(\"Distance (nm)\")\nplt.show()\n</code></pre> <p>And with that, we conclude this tutorial! You're now ready to use the prediction to simulate expected performance, or even to refine your design to decrease variation and uncertainty (refer to the device correction examples). We would love to hear your comments, questions, and suggestions on how to implement this prediction in simulation. Happy designing!</p>"}]}