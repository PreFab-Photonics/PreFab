{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Installation","text":"<p>PreFab leverages deep learning to model fabrication-induced structural variations in integrated photonic devices. Through this virtual nanofabrication environment, we uncover valuable insights into nanofabrication processes and enhance device design accuracy.</p> <p>This guide will get you all set up and ready to use PreFab to predict the fabrication-induced structural variations of your own integrated photonic devices.</p> <p>Sign up</p> <p>Before you can make PreFab requests, you will need to create an account<sup>1</sup>. Sign up here.</p>"},{"location":"#install-prefab","title":"Install PreFab","text":"<p>Before making your first prediction, follow the steps below to install the PreFab Python package.</p>"},{"location":"#from-pypi","title":"From PyPI","text":"<p>You can easily install PreFab using pip, which is the Python package installer. This method is suitable for most users.</p> <pre><code>pip install prefab\n</code></pre>"},{"location":"#from-github","title":"From GitHub","text":"<p>For those who wish to make changes to the source code for their own development purposes, PreFab can also be installed directly from GitHub.</p> <pre><code>git clone https://github.com/PreFab-Photonics/PreFab.git\npip install -e prefab\n</code></pre>"},{"location":"#authenticate-prefab-token","title":"Authenticate PreFab token","text":"<p>To link your PreFab account to the API, you will need to create an authentication token. You can do this by running the following command in your terminal. This will open a browser window where you can log in and generate a token.</p> <pre><code>python3 -m prefab setup\n</code></pre>"},{"location":"#prefabricate-your-designs","title":"PreFab<sub>ricate</sub> your designs","text":"<p>See the following guides to get started with making your first predictions and corrections of fabrication-induced variations with PreFab:</p> <ol> <li>Making a prediction</li> <li>Making a correction</li> </ol> <p>Performance and usage</p> <p>PreFab models are served via a serverless cloud platform. Please note:</p> <ul> <li>\ud83d\udc22 CPU inference may result in slower performance. Future updates will introduce GPU inference.</li> <li>\ud83e\udd76 The first prediction may take longer due to cold start server loading. Subsequent predictions will be faster.</li> <li>\ud83d\ude0a Be considerate of usage. Start small and limit usage during the initial stages. Thank you!</li> </ul>"},{"location":"#your-thoughts-are-valuable","title":"Your thoughts are valuable","text":"<p>PreFab is a new design tool, still in its early days, that we hope will become useful to the photonics community. We are eager to hear about your experiences with PreFab. Please share your thoughts with us and any issues you may have on GitHub.</p> <p>Happy designing  </p> <ol> <li> <p>For more information, visit our Privacy Policy and Terms of Service.  \u21a9</p> </li> </ol>"},{"location":"models/","title":"Models","text":""},{"location":"models/#overview","title":"Overview","text":"<p>PreFab accommodates unique predictor and corrector models for each photonic foundry, regularly updated based on recent fabrication data.</p> Foundry Process Latest Version Latest Dataset Model Name Model Tag ANT NanoSOI ANF1 (May 6 2023) d9 (Feb 6 2024) ANT_NanoSOI ANF1-d9 ANT SiN ANF1 (May 6 2023) d1 (Jan 31 2024) ANT_SiN ANF1-d1 <p>New models and foundries are to be regularly added. Usage may change. For additional foundry and process models, feel free to contact us.</p>"},{"location":"examples/1_prediction/","title":"Making a prediction","text":"<p>This notebook offers an interactive tutorial on using PreFab to predict the fabrication result of a 500 nm-wide target nanostructure on a silicon-on-insulator (SOI) e-beam lithography process. This tutorial is structured as follows:</p> <ol> <li>Preparing a device image for prediction</li> <li>Executing a prediction</li> <li>Analyzing the prediction and uncertainty</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import prefab as pf\n</code></pre> <p>The first step involves preparing a device for prediction. <code>Device</code> is the base class that represents photonic design geometries in PreFab and can be instantiated by loading an image or GDS layout as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use an image of a small target structure, but feel free to explore other structures available in the <code>devices/</code> directory, or add your own.</p> <p>The image scale should be 1 nm/px. If not, ensure you specify the length of the entire device image (in nanometers) when loading the image.</p> <pre><code>device = pf.read.from_img(\n    img_path=\"../../devices/target_16x128_256x256.png\", img_width_nm=1000\n)\ndevice.plot()\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We proceed with the prediction of the device for a specific fabrication model. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for a library of available models.</p> <p>You can also select if you want a binarized output. The prediction model, by default, produces raw outputs, which includes \"fuzzy\" edges of the structure that may vary between different fabrication runs or even different device instances on the same chip. When binarized, the prediction model outputs the most probable fabrication outcome (i.e., a threshold of 50%). Post-prediction binarization is also an option, as we'll show here.</p> <p>&gt; Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_NanoSOI_ANF1_d9\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot()\nprediction_bin.plot()\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:03&lt;00:00, 30.71%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>Comparing the (binary) prediction with the nominal device, we can observe erosion (or corner rounding, or over-etching) in the 64 nm-wide arms and convex corners of the target geometry. We also see dilation (or under-etching) for the concave corners in the center, as well as the complete filling of the center opening.</p> <pre><code>prediction_bin.plot_compare(ref_device=device)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>To evaluate the quality of the prediction quantitatively, PreFab provides a function to compute the Intersection over Union (IoU) between the prediction and the nominal device. This metric measures the overlap between the two geometries, where 1.0 indicates a perfect match and 0.0 indicates no overlap.</p> <pre><code>print(\n    f\"Prediction IoU: {pf.compare.intersection_over_union(device, prediction_bin):.2f}\"\n)\n</code></pre> <pre>\n<code>Prediction IoU: 0.68\n</code>\n</pre> <p>68% is not great, but the feature size was demanding. Try other values for <code>img_width_nm</code> and see how it affects the results.</p> <p>We can further visualize and understand the prediction by highlighting the \"fuzzy\" edge regions. This is a measure of the uncertainty of the prediction model due to stochastic variance in the fabrication process and the modelling process. From device-to-device, run-to-run, the device edge may lie anywhere in this uncertainty region. Although PreFab cannot correct for uncertainty, visualizing it is valuable in identifying features with high variance.</p> <pre><code>prediction.plot_uncertainty()\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>And that's it! See the next example to learn how to restore this nanostructure using PreFab's correction capabilities.</p>"},{"location":"examples/1_prediction/#making-a-prediction","title":"Making a prediction","text":""},{"location":"examples/1_prediction/#introduction","title":"Introduction","text":""},{"location":"examples/1_prediction/#loading-a-device","title":"Loading a device","text":""},{"location":"examples/1_prediction/#predicting-a-device","title":"Predicting a device","text":""},{"location":"examples/1_prediction/#analyzing-a-prediction","title":"Analyzing a prediction","text":""},{"location":"examples/2_correction/","title":"Making a correction","text":"<p>This notebook offers an interactive tutorial on using PreFab to correct the fabrication result of the same 500 nm-wide target nanostructure used in the previous prediction example. This tutorial is structured as follows:</p> <ol> <li>Preparing a device image for correction</li> <li>Executing a correction</li> <li>Making a prediction of the correction</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import prefab as pf\n</code></pre> <p>The first step involves preparing a device for correction. <code>Device</code> is the base class that represents photonic design geometries in PreFab and can be instantiated by loading an image or GDS layout as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use an image of a small target structure, but feel free to explore other structures available in the <code>devices/</code> directory, or add your own.</p> <p>The image scale should be 1 nm/px. If not, ensure you specify the length of the entire device image (in nanometers) when loading the image.</p> <pre><code>device = pf.read.from_img(\n    img_path=\"../../devices/target_16x128_256x256.png\", img_width_nm=1000\n)\ndevice.plot()\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We proceed with the correction of the device for a specific fabrication model. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for a library of available models.</p> <p>&gt; Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_NanoSOI_ANF1_d9\"\ncorrection = device.correct(model=pf.models[MODEL_NAME])\ncorrection.plot()\n</code></pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 81.13%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>The corrector compensates for expected fabrication errors by adjusting the design. It adds silicon in places where it predicts erosion and removes silicon where it predicts dilation.</p> <pre><code>correction.plot_compare(ref_device=device)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We then predict the nanofabrication outcome for the corrected target structure by using the prediction model again.</p> <p>In the corrected design, the corners are expected to be sharper and the middle opening is better resolved compared to the nominal design. Additionally, the Intersection over Union score is improved from 63% to 91%! This means that the corrected design will more closely match the intended design, leading to better fabrication outcomes and better chips.</p> <pre><code>outcome = correction.predict(model=pf.models[MODEL_NAME])\noutcome_bin = outcome.binarize()\n\noutcome.plot()\noutcome_bin.plot()\noutcome_bin.plot_compare(ref_device=device)\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 35.48%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <pre><code>print(f\"Corrected IoU: {pf.compare.intersection_over_union(device, outcome_bin):.2f}\")\n</code></pre> <pre>\n<code>Corrected IoU: 0.97\n</code>\n</pre> <p>While it may not always be possible to fully restore the original design to 100%, achieving this is our goal. We encourage you to stay up-to-date with our latest models, as we are continually striving to improve.</p>"},{"location":"examples/2_correction/#making-a-correction","title":"Making a correction","text":""},{"location":"examples/2_correction/#introduction","title":"Introduction","text":""},{"location":"examples/2_correction/#loading-a-device","title":"Loading a device","text":""},{"location":"examples/2_correction/#correcting-a-device","title":"Correcting a device","text":""},{"location":"examples/2_correction/#making-a-prediction-of-the-correction","title":"Making a prediction of the correction","text":""},{"location":"reference/compare/","title":"Compare","text":"<p>Provides functions to measure the similarity between devices.</p>"},{"location":"reference/compare/#prefab.compare.dice_coefficient","title":"<code>dice_coefficient(device_a, device_b)</code>","text":"<p>Calculates the Dice coefficient between two binary devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device.</p> required <code>device_b</code> <code>Device</code> <p>The second device.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Dice coefficient between two devices. A value closer to 1 indicates more similarity.</p> Source code in <code>prefab/compare.py</code> <pre><code>def dice_coefficient(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Dice coefficient between two binary devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The Dice coefficient between two devices. A value closer to 1 indicates more\n        similarity.\n    \"\"\"\n    intersection = 2.0 * np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    )\n    size_a = np.sum(device_a.device_array)\n    size_b = np.sum(device_b.device_array)\n    return intersection / (size_a + size_b)\n</code></pre>"},{"location":"reference/compare/#prefab.compare.hamming_distance","title":"<code>hamming_distance(device_a, device_b)</code>","text":"<p>Calculates the Hamming distance between two binary devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device.</p> required <code>device_b</code> <code>Device</code> <p>The second device.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Hamming distance between two devices. A lower value indicates more similarity.</p> Source code in <code>prefab/compare.py</code> <pre><code>def hamming_distance(device_a: Device, device_b: Device) -&gt; int:\n    \"\"\"\n    Calculates the Hamming distance between two binary devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    int\n        The Hamming distance between two devices. A lower value indicates more\n        similarity.\n    \"\"\"\n    return np.sum(device_a.device_array != device_b.device_array)\n</code></pre>"},{"location":"reference/compare/#prefab.compare.intersection_over_union","title":"<code>intersection_over_union(device_a, device_b)</code>","text":"<p>Calculates the Intersection over Union (IoU) between two binary devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device.</p> required <code>device_b</code> <code>Device</code> <p>The second device.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Intersection over Union between two devices. A value closer to 1 indicates more similarity (more overlap).</p> Source code in <code>prefab/compare.py</code> <pre><code>def intersection_over_union(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Intersection over Union (IoU) between two binary devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The Intersection over Union between two devices. A value closer to 1 indicates\n        more similarity (more overlap).\n    \"\"\"\n    return np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    ) / np.sum(np.logical_or(device_a.device_array, device_b.device_array))\n</code></pre>"},{"location":"reference/compare/#prefab.compare.mean_squared_error","title":"<code>mean_squared_error(device_a, device_b)</code>","text":"<p>Calculate the mean squared error (MSE) between two non-binarized devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device.</p> required <code>device_b</code> <code>Device</code> <p>The second device.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean squared error between two devices. A lower value indicates more similarity.</p> Source code in <code>prefab/compare.py</code> <pre><code>def mean_squared_error(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between two non-binarized devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device.\n    device_b : Device\n        The second device.\n\n    Returns\n    -------\n    float\n        The mean squared error between two devices. A lower value indicates more\n        similarity.\n    \"\"\"\n    return np.mean((device_a.device_array - device_b.device_array) ** 2)\n</code></pre>"},{"location":"reference/device/","title":"Device","text":"<p>Provides the Device class for representing photonic devices.</p>"},{"location":"reference/device/#prefab.device.BufferSpec","title":"<code>BufferSpec</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines the specifications for a buffer zone around a device.</p> <p>This class is used to specify the mode and thickness of a buffer zone that is added around the device geometry. The buffer zone can be used for various purposes such as providing extra space for device fabrication processes or for ensuring that the device is isolated from surrounding structures.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict[str, str]</code> <p>A dictionary that defines the buffer mode for each side of the device ('top', 'bottom', 'left', 'right'), where 'constant' is used for isolated structures and 'edge' is utilized for preserving the edge, such as for waveguide connections.</p> required <code>thickness</code> <code>conint(gt=0)</code> <p>The thickness of the buffer zone around the device. Must be greater than 0.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the modes specified in the 'mode' dictionary are not one of the allowed values ('constant', 'edge'). Or if the thickness is not greater than 0.</p> Example <pre><code>import prefab as pf\n\nbuffer_spec = pf.BufferSpec(\n    mode={\n        \"top\": \"constant\",\n        \"bottom\": \"edge\",\n        \"left\": \"constant\",\n        \"right\": \"edge\",\n    },\n    thickness=150,\n)\n</code></pre> Source code in <code>prefab/device.py</code> <pre><code>class BufferSpec(BaseModel):\n    \"\"\"\n    Defines the specifications for a buffer zone around a device.\n\n    This class is used to specify the mode and thickness of a buffer zone that is added\n    around the device geometry. The buffer zone can be used for various purposes such as\n    providing extra space for device fabrication processes or for ensuring that the\n    device is isolated from surrounding structures.\n\n    Parameters\n    ----------\n    mode : dict[str, str]\n        A dictionary that defines the buffer mode for each side of the device\n        ('top', 'bottom', 'left', 'right'), where 'constant' is used for isolated\n        structures and 'edge' is utilized for preserving the edge, such as for waveguide\n        connections.\n    thickness : conint(gt=0)\n        The thickness of the buffer zone around the device. Must be greater than 0.\n\n    Raises\n    ------\n    ValueError\n        If any of the modes specified in the 'mode' dictionary are not one of the\n        allowed values ('constant', 'edge'). Or if the thickness is not greater than 0.\n\n    Example\n    -------\n        import prefab as pf\n\n        buffer_spec = pf.BufferSpec(\n            mode={\n                \"top\": \"constant\",\n                \"bottom\": \"edge\",\n                \"left\": \"constant\",\n                \"right\": \"edge\",\n            },\n            thickness=150,\n        )\n    \"\"\"\n\n    mode: dict[str, str] = Field(\n        default_factory=lambda: {\n            \"top\": \"constant\",\n            \"bottom\": \"constant\",\n            \"left\": \"constant\",\n            \"right\": \"constant\",\n        }\n    )\n    thickness: conint(gt=0) = 128\n\n    @validator(\"mode\", pre=True)\n    def check_mode(cls, v):\n        allowed_modes = [\"constant\", \"edge\"]\n        if not all(mode in allowed_modes for mode in v.values()):\n            raise ValueError(f\"Buffer mode must be one of {allowed_modes}, got '{v}'\")\n        return v\n</code></pre>"},{"location":"reference/device/#prefab.device.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>prefab/device.py</code> <pre><code>class Device(BaseModel):\n    device_array: np.ndarray = Field(...)\n    buffer_spec: BufferSpec = Field(default_factory=BufferSpec)\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        return self.device_array.shape\n\n    def __init__(\n        self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n    ):\n        \"\"\"\n        Represents the planar geometry of a photonic device design that will have its\n        nanofabrication outcome predicted and/or corrected.\n\n        This class is designed to encapsulate the geometric representation of a photonic\n        device, facilitating operations such as padding, normalization, binarization,\n        ternarization, trimming, and blurring. These operations are useful for preparing\n        the device design for prediction or correction. Additionally, the class provides\n        methods for exporting the device representation to various formats, including\n        ndarray, image files, and GDSII files, supporting a range of analysis and\n        fabrication workflows.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            A 2D array representing the planar geometry of the device. This array\n            undergoes various transformations to predict or correct the nanofabrication\n            process.\n        buffer_spec : BufferSpec, optional\n            Defines the parameters for adding a buffer zone around the device geometry.\n            This buffer zone is needed for providing surrounding context for prediction\n            or correction and for ensuring seamless integration with the surrounding\n            circuitry. By default, a generous padding is applied to accommodate isolated\n            structures.\n\n        Attributes\n        ----------\n        shape : tuple[int, int]\n            The shape of the device array.\n\n        Raises\n        ------\n        ValueError\n            If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n            indicating an invalid device geometry.\n        \"\"\"\n        super().__init__(\n            device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n        )\n        self._initial_processing()\n\n    def __call__(self, *args, **kwargs):\n        return self.plot(*args, **kwargs)\n\n    def _initial_processing(self):\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((buffer_thickness, 0), (0, 0)),\n            mode=buffer_mode[\"top\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, buffer_thickness), (0, 0)),\n            mode=buffer_mode[\"bottom\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, 0), (buffer_thickness, 0)),\n            mode=buffer_mode[\"left\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, 0), (0, buffer_thickness)),\n            mode=buffer_mode[\"right\"],\n        )\n\n        self.device_array = np.expand_dims(\n            self.device_array.astype(np.float32), axis=-1\n        )\n\n    @root_validator(pre=True)\n    def check_device_array(cls, values):\n        device_array = values.get(\"device_array\")\n        if not isinstance(device_array, np.ndarray):\n            raise ValueError(\"device_array must be a numpy ndarray.\")\n        if device_array.ndim != 2:\n            raise ValueError(\"device_array must be a 2D array.\")\n        return values\n\n    def is_binary(self) -&gt; bool:\n        \"\"\"\n        Check if the device geometry is binary.\n\n        Returns\n        -------\n        bool\n            True if the device geometry is binary, False otherwise.\n        \"\"\"\n        unique_values = np.unique(self.device_array)\n        return (\n            np.array_equal(unique_values, [0, 1])\n            or np.array_equal(unique_values, [1, 0])\n            or np.array_equal(unique_values, [0])\n            or np.array_equal(unique_values, [1])\n        )\n\n    def _encode_array(self, array):\n        image = Image.fromarray(np.uint8(array * 255))\n        buffered = io.BytesIO()\n        image.save(buffered, format=\"PNG\")\n        encoded_png = base64.b64encode(buffered.getvalue()).decode(\"utf-8\")\n        return encoded_png\n\n    def _decode_array(self, encoded_png):\n        binary_data = base64.b64decode(encoded_png)\n        image = Image.open(io.BytesIO(binary_data))\n        return np.array(image) / 255\n\n    def _predict_array(\n        self,\n        model: Model,\n        model_type: str,\n        binarize: bool,\n    ) -&gt; \"Device\":\n        try:\n            with open(os.path.expanduser(\"~/.prefab.toml\")) as file:\n                content = file.readlines()\n                access_token = None\n                refresh_token = None\n                for line in content:\n                    if \"access_token\" in line:\n                        access_token = line.split(\"=\")[1].strip().strip('\"')\n                    if \"refresh_token\" in line:\n                        refresh_token = line.split(\"=\")[1].strip().strip('\"')\n                        break\n                if not access_token or not refresh_token:\n                    raise ValueError(\"Token not found in the configuration file.\")\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Could not validate user.\\n\"\n                \"Please update prefab using: pip install --upgrade prefab.\\n\"\n                \"Signup/login and generate a new token.\\n\"\n                \"See https://www.prefabphotonics.com/docs/guides/quickstart.\"\n            ) from None\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"X-Refresh-Token\": refresh_token,\n        }\n\n        predict_data = {\n            \"device_array\": self._encode_array(self.device_array[:, :, 0]),\n            \"model\": model.to_json(),\n            \"model_type\": model_type,\n            \"binary\": binarize,\n        }\n        json_data = json.dumps(predict_data)\n\n        endpoint_url = \"https://prefab-photonics--predict-v1.modal.run\"\n\n        with requests.post(\n            endpoint_url, data=json_data, headers=headers, stream=True\n        ) as response:\n            response.raise_for_status()\n            event_type = None\n            model_descriptions = {\"p\": \"Prediction\", \"c\": \"Correction\", \"s\": \"SEMulate\"}\n            progress_bar = tqdm(\n                total=100,\n                desc=f\"{model_descriptions[model_type]}\",\n                unit=\"%\",\n                colour=\"green\",\n                bar_format=\"{l_bar}{bar:30}{r_bar}{bar:-10b}\",\n            )\n\n            for line in response.iter_lines():\n                if line:\n                    decoded_line = line.decode(\"utf-8\").strip()\n                    if decoded_line.startswith(\"event:\"):\n                        event_type = decoded_line.split(\":\")[1].strip()\n                    elif decoded_line.startswith(\"data:\"):\n                        try:\n                            data_content = json.loads(decoded_line.split(\"data: \")[1])\n                            if event_type == \"progress\":\n                                progress = round(100 * data_content[\"progress\"])\n                                progress_bar.update(progress - progress_bar.n)\n                            elif event_type == \"result\":\n                                results = []\n                                for key in sorted(data_content.keys()):\n                                    if key.startswith(\"result\"):\n                                        decoded_image = self._decode_array(\n                                            data_content[key]\n                                        )\n                                        results.append(decoded_image)\n\n                                if results:\n                                    prediction = np.stack(results, axis=-1)\n                                    if binarize:\n                                        prediction = geometry.binarize_hard(prediction)\n                                    progress_bar.close()\n                                    return prediction\n                            elif event_type == \"end\":\n                                print(\"Stream ended.\")\n                                progress_bar.close()\n                                break\n                            elif event_type == \"auth\":\n                                if \"new_refresh_token\" in data_content[\"auth\"]:\n                                    prefab_file_path = os.path.expanduser(\n                                        \"~/.prefab.toml\"\n                                    )\n                                    with open(\n                                        prefab_file_path, \"w\", encoding=\"utf-8\"\n                                    ) as toml_file:\n                                        toml.dump(\n                                            {\n                                                \"access_token\": data_content[\"auth\"][\n                                                    \"new_access_token\"\n                                                ],\n                                                \"refresh_token\": data_content[\"auth\"][\n                                                    \"new_refresh_token\"\n                                                ],\n                                            },\n                                            toml_file,\n                                        )\n                            elif event_type == \"error\":\n                                print(f\"Error: {data_content['error']}\")\n                                progress_bar.close()\n                        except json.JSONDecodeError:\n                            print(\n                                \"Failed to decode JSON:\",\n                                decoded_line.split(\"data: \")[1],\n                            )\n\n    def predict(\n        self,\n        model: Model,\n        binarize: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Predict the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless prediction service, which\n        uses a specified machine learning model to predict the outcome of the\n        nanofabrication process.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for prediction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the prediction\n            is tailored to specific fabrication parameters.\n        binarize : bool, optional\n            If True, the predicted device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic predictions into binary\n            geometries. Defaults to False.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the predicted geometry.\n\n        Raises\n        ------\n        ValueError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        prediction_array = self._predict_array(\n            model=model,\n            model_type=\"p\",\n            binarize=binarize,\n        )\n        return self.model_copy(update={\"device_array\": prediction_array})\n\n    def correct(\n        self,\n        model: Model,\n        binarize: bool = True,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Correct the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless correction service, which\n        uses a specified machine learning model to correct the outcome of the\n        nanofabrication process. The correction aims to adjust the device geometry to\n        compensate for known fabrication errors and improve the accuracy of the final\n        device structure.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for correction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the correction\n            is tailored to specific fabrication parameters.\n        binarize : bool, optional\n            If True, the corrected device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic corrections into binary\n            geometries. Defaults to True.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the corrected geometry.\n\n        Raises\n        ------\n        ValueError\n            If the correction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        correction_array = self._predict_array(\n            model=model,\n            model_type=\"c\",\n            binarize=binarize,\n        )\n        return self.model_copy(update={\"device_array\": correction_array})\n\n    def semulate(\n        self,\n        model: Model,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Simulate the appearance of the device as if viewed under a scanning electron\n        microscope (SEM).\n\n        This method applies a specified machine learning model to transform the device\n        geometry into a style that resembles an SEM image. This can be useful for\n        visualizing how the device might appear under an SEM, which is often used for\n        inspecting the surface and composition of materials at high magnification.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for SEMulation, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the SEMulation\n            is tailored to specific fabrication parameters.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with its geometry transformed to simulate\n            an SEM image style.\n        \"\"\"\n        semulated_array = self._predict_array(\n            model=model,\n            model_type=\"s\",\n        )\n        return self.model_copy(update={\"device_array\": semulated_array})\n\n    def to_ndarray(self) -&gt; np.ndarray:\n        \"\"\"\n        Converts the device geometry to an ndarray.\n\n        This method applies the buffer specifications to crop the device array if\n        necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n        resulting ndarray representing the device geometry.\n\n        Returns\n        -------\n        np.ndarray\n            The ndarray representation of the device geometry, with any applied buffer\n            cropping.\n        \"\"\"\n        device_array = np.copy(self.device_array)\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        crop_top = buffer_thickness if buffer_mode[\"top\"] == \"edge\" else 0\n        crop_bottom = buffer_thickness if buffer_mode[\"bottom\"] == \"edge\" else 0\n        crop_left = buffer_thickness if buffer_mode[\"left\"] == \"edge\" else 0\n        crop_right = buffer_thickness if buffer_mode[\"right\"] == \"edge\" else 0\n\n        ndarray = device_array[\n            crop_top : device_array.shape[0] - crop_bottom,\n            crop_left : device_array.shape[1] - crop_right,\n        ]\n        return np.squeeze(ndarray)\n\n    def to_img(self, img_path: str = \"prefab_device.png\"):\n        \"\"\"\n        Exports the device geometry as an image file.\n\n        This method converts the device geometry to an ndarray using `to_ndarray`,\n        scales the values to the range [0, 255] for image representation, and saves the\n        result as an image file.\n\n        Parameters\n        ----------\n        img_path : str, optional\n            The path where the image file will be saved. If not specified, the image is\n            saved as \"prefab_device.png\" in the current directory.\n        \"\"\"\n        cv2.imwrite(img_path, 255 * self.to_ndarray())\n        print(f\"Saved Device to '{img_path}'\")\n\n    def to_gds(\n        self,\n        gds_path: str = \"prefab_device.gds\",\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n    ):\n        \"\"\"\n        Exports the device geometry as a GDSII file.\n\n        This method converts the device geometry into a format suitable for GDSII files.\n        The conversion involves contour approximation to simplify the geometry while\n        preserving essential features.\n\n        Parameters\n        ----------\n        gds_path : str, optional\n            The path where the GDSII file will be saved. If not specified, the file is\n            saved as \"prefab_device.gds\" in the current directory.\n        cell_name : str, optional\n            The name of the cell within the GDSII file. If not specified, defaults to\n            \"prefab_device\".\n        gds_layer : tuple[int, int], optional\n            The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n        contour_approx_mode : int, optional\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        \"\"\"\n        gdstk_cell = self._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n        )\n        print(f\"Saving GDS to '{gds_path}'...\")\n        gdstk_library = gdstk.Library()\n        gdstk_library.add(gdstk_cell)\n        gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n\n    def to_gdstk(\n        self,\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n    ):\n        \"\"\"\n        Converts the device geometry to a GDSTK cell object.\n\n        This method prepares the device geometry for GDSII file export by converting it\n        into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n        GDSII layout files. The conversion involves contour approximation to simplify\n        the geometry while preserving essential features.\n\n        Parameters\n        ----------\n        cell_name : str, optional\n            The name of the cell to be created. Defaults to \"prefab_device\".\n        gds_layer : tuple[int, int], optional\n            The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n        contour_approx_mode : int, optional\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n\n        Returns\n        -------\n        gdstk.Cell\n            The GDSTK cell object representing the device geometry.\n        \"\"\"\n        print(f\"Creating cell '{cell_name}'...\")\n        gdstk_cell = self._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n        )\n        return gdstk_cell\n\n    def _device_to_gdstk(\n        self,\n        cell_name: str,\n        gds_layer: tuple[int, int],\n        contour_approx_mode: int,\n    ) -&gt; gdstk.Cell:\n        approx_mode_mapping = {\n            1: cv2.CHAIN_APPROX_NONE,\n            2: cv2.CHAIN_APPROX_SIMPLE,\n            3: cv2.CHAIN_APPROX_TC89_L1,\n            4: cv2.CHAIN_APPROX_TC89_KCOS,\n        }\n\n        contours, hierarchy = cv2.findContours(\n            np.flipud(self.to_ndarray()).astype(np.uint8),\n            cv2.RETR_TREE,\n            approx_mode_mapping[contour_approx_mode],\n        )\n\n        hierarchy_polygons = {}\n        for idx, contour in enumerate(contours):\n            level = 0\n            current_idx = idx\n            while hierarchy[0][current_idx][3] != -1:\n                level += 1\n                current_idx = hierarchy[0][current_idx][3]\n\n            if len(contour) &gt; 2:\n                contour = contour / 1000\n                points = [tuple(point) for point in contour.squeeze().tolist()]\n                if level not in hierarchy_polygons:\n                    hierarchy_polygons[level] = []\n                hierarchy_polygons[level].append(points)\n\n        cell = gdstk.Cell(cell_name)\n        processed_polygons = []\n        for level in sorted(hierarchy_polygons.keys()):\n            operation = \"or\" if level % 2 == 0 else \"xor\"\n            polygons_to_process = hierarchy_polygons[level]\n\n            if polygons_to_process:\n                processed_polygons = gdstk.boolean(\n                    polygons_to_process,\n                    processed_polygons,\n                    operation,\n                    layer=gds_layer[0],\n                    datatype=gds_layer[1],\n                )\n        for polygon in processed_polygons:\n            cell.add(polygon)\n\n        return cell\n\n    def _plot_base(\n        self,\n        plot_array: np.ndarray,\n        show_buffer: bool,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]],\n        ax: Optional[Axes],\n        **kwargs,\n    ) -&gt; Axes:\n        if ax is None:\n            _, ax = plt.subplots()\n        ax.set_ylabel(\"y (nm)\")\n        ax.set_xlabel(\"x (nm)\")\n\n        min_x, min_y = (0, 0) if bounds is None else bounds[0]\n        max_x, max_y = plot_array.shape[::-1] if bounds is None else bounds[1]\n        min_x = max(min_x, 0)\n        min_y = max(min_y, 0)\n        max_x = \"end\" if max_x == \"end\" else min(max_x, plot_array.shape[1])\n        max_y = \"end\" if max_y == \"end\" else min(max_y, plot_array.shape[0])\n        max_x = plot_array.shape[1] if max_x == \"end\" else max_x\n        max_y = plot_array.shape[0] if max_y == \"end\" else max_y\n        plot_array = plot_array[\n            plot_array.shape[0] - max_y : plot_array.shape[0] - min_y,\n            min_x:max_x,\n        ]\n        extent = [min_x, max_x, min_y, max_y]\n\n        if not np.ma.is_masked(plot_array):\n            max_size = (1000, 1000)\n            scale_x = min(1, max_size[0] / plot_array.shape[1])\n            scale_y = min(1, max_size[1] / plot_array.shape[0])\n            fx = min(scale_x, scale_y)\n            fy = fx\n\n            plot_array = cv2.resize(\n                plot_array,\n                dsize=(0, 0),\n                fx=fx,\n                fy=fy,\n                interpolation=cv2.INTER_NEAREST,\n            )\n\n        mappable = ax.imshow(\n            plot_array,\n            extent=extent,\n            **kwargs,\n        )\n\n        if show_buffer:\n            self._add_buffer_visualization(ax)\n\n        return mappable, ax\n\n    def plot(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the device geometry.\n\n        This method allows for the visualization of the device geometry. The\n        visualization can be customized with various matplotlib parameters and can be\n        drawn on an existing matplotlib Axes object or create a new one if none is\n        provided.\n\n        Parameters\n        ----------\n        show_buffer : bool, optional\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the device geometry on. If\n            None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the plot. This object can be used for\n            further plot customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            plot_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            plot_array = self.device_array[:, :, level]\n        _, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        return ax\n\n    def plot_contour(\n        self,\n        linewidth: Optional[int] = None,\n        # label: Optional[str] = \"Device contour\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the contour of the device geometry.\n\n        This method plots the contour of the device geometry, emphasizing the edges and\n        boundaries of the device. The contour plot can be customized with various\n        matplotlib parameters, including line width and color. The plot can be drawn on\n        an existing matplotlib Axes object or create a new one if none is provided.\n\n        Parameters\n        ----------\n        linewidth : Optional[int], optional\n            The width of the contour lines. If None, the linewidth is automatically\n            determined based on the size of the device array. Defaults to None.\n        show_buffer : bool, optional\n            If True, the buffer zones around the device will be visualized. By default,\n            it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the device contour on. If None, a\n            new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the contour plot. This can be used for\n            further customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            device_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            device_array = self.device_array[:, :, level]\n\n        kwargs.setdefault(\"cmap\", \"spring\")\n        if linewidth is None:\n            linewidth = device_array.shape[0] // 100\n\n        contours, _ = cv2.findContours(\n            geometry.binarize_hard(device_array).astype(np.uint8),\n            cv2.RETR_CCOMP,\n            cv2.CHAIN_APPROX_SIMPLE,\n        )\n        contour_array = np.zeros_like(device_array, dtype=np.uint8)\n        cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n        contour_array = np.ma.masked_equal(contour_array, 0)\n\n        _, ax = self._plot_base(\n            plot_array=contour_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n        # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n        # ax.legend([legend_proxy], [label], loc=\"upper right\")\n        return ax\n\n    def plot_uncertainty(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the uncertainty in the edge positions of the predicted device.\n\n        This method plots the uncertainty associated with the positions of the edges of\n        the device. The uncertainty is represented as a gradient, with areas of higher\n        uncertainty indicating a greater likelihood of the edge position from run to run\n        (due to inconsistencies in the fabrication process). This visualization can help\n        in identifying areas within the device geometry that may require design\n        adjustments to improve fabrication consistency.\n\n        Parameters\n        ----------\n        show_buffer : bool, optional\n            If True, the buffer zones around the device will also be visualized. By\n            default, it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the uncertainty visualization on.\n            If None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the uncertainty visualization. This\n            can be used for further customization or saving the plot after the method\n            returns.\n        \"\"\"\n        uncertainty_array = self.get_uncertainty()\n\n        if level is None:\n            uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n        else:\n            uncertainty_array = uncertainty_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=uncertainty_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Uncertainty (a.u.)\")\n        return ax\n\n    def plot_compare(\n        self,\n        ref_device: \"Device\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the comparison between the current device geometry and a reference\n        device geometry.\n\n        Positive values (dilation) and negative values (erosion) are visualized with a\n        color map to indicate areas where the current device has expanded or contracted\n        relative to the reference.\n\n        Parameters\n        ----------\n        ref_device : Device\n            The reference device to compare against.\n        show_buffer : bool, optional\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the comparison on. If None, a new\n            figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the comparison plot. This object can\n            be used for further plot customization or saving the plot after the method\n            returns.\n        \"\"\"\n        plot_array = ref_device.device_array - self.device_array\n\n        if level is None:\n            plot_array = geometry.flatten(plot_array)[:, :, 0]\n        else:\n            plot_array = plot_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            cmap=\"jet\",\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n        return ax\n\n    def _add_buffer_visualization(self, ax: Axes):\n        plot_array = self.device_array\n\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_fill = (0, 1, 0, 0.2)\n        buffer_hatch = \"/\"\n\n        mid_rect = Rectangle(\n            (buffer_thickness, buffer_thickness),\n            plot_array.shape[1] - 2 * buffer_thickness,\n            plot_array.shape[0] - 2 * buffer_thickness,\n            facecolor=\"none\",\n            edgecolor=\"black\",\n            linewidth=1,\n        )\n        ax.add_patch(mid_rect)\n\n        top_rect = Rectangle(\n            (0, 0),\n            plot_array.shape[1],\n            buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(top_rect)\n\n        bottom_rect = Rectangle(\n            (0, plot_array.shape[0] - buffer_thickness),\n            plot_array.shape[1],\n            buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(bottom_rect)\n\n        left_rect = Rectangle(\n            (0, buffer_thickness),\n            buffer_thickness,\n            plot_array.shape[0] - 2 * buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(left_rect)\n\n        right_rect = Rectangle(\n            (\n                plot_array.shape[1] - buffer_thickness,\n                buffer_thickness,\n            ),\n            buffer_thickness,\n            plot_array.shape[0] - 2 * buffer_thickness,\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(right_rect)\n\n    def normalize(self) -&gt; \"Device\":\n        \"\"\"\n        Normalize the device geometry.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the normalized geometry.\n        \"\"\"\n        normalized_device_array = geometry.normalize(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": normalized_device_array})\n\n    def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry based on a threshold and a scaling factor.\n\n        Parameters\n        ----------\n        eta : float, optional\n            The threshold value for binarization. Defaults to 0.5.\n        beta : float, optional\n            The scaling factor for the binarization process. A higher value makes the\n            transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize(\n            device_array=self.device_array, eta=eta, beta=beta\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n        \"\"\"\n        Apply a hard threshold to binarize the device geometry. The `binarize` function\n        is generally preferred for most use cases, but it can create numerical artifacts\n        for large beta values.\n\n            Parameters\n            ----------\n            eta : float, optional\n                The threshold value for binarization. Defaults to 0.5.\n\n            Returns\n            -------\n            Device\n                A new instance of the Device with the threshold-binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_hard(\n            device_array=self.device_array, eta=eta\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def binarize_monte_carlo(\n        self,\n        threshold_noise_std: float = 2.0,\n        threshold_blur_std: float = 9.0,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry using a Monte Carlo approach with Gaussian\n        blurring.\n\n        This method applies a dynamic thresholding technique where the threshold value\n        is determined by a base value perturbed by Gaussian-distributed random noise.\n        The threshold is then spatially varied across the device array using Gaussian\n        blurring, simulating a more realistic scenario where the threshold is not\n        uniform across the device.\n\n        Parameters\n        ----------\n        threshold_noise_std : float, optional\n            The standard deviation of the Gaussian distribution used to generate noise\n            for the threshold values. This controls the amount of randomness in the\n            threshold. Defaults to 2.0.\n        threshold_blur_std : float, optional\n            The standard deviation for the Gaussian kernel used in blurring the\n            threshold map. This controls the spatial variation of the threshold across\n            the array. Defaults to 9.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_monte_carlo(\n            device_array=self.device_array,\n            threshold_noise_std=threshold_noise_std,\n            threshold_blur_std=threshold_blur_std,\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n        \"\"\"\n        Ternarize the device geometry based on two thresholds. This function is useful\n        for flattened devices with angled sidewalls (i.e., three segments).\n\n        Parameters\n        ----------\n        eta1 : float, optional\n            The first threshold value for ternarization. Defaults to 1/3.\n        eta2 : float, optional\n            The second threshold value for ternarization. Defaults to 2/3.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the ternarized geometry.\n        \"\"\"\n        ternarized_device_array = geometry.ternarize(\n            device_array=self.device_array, eta1=eta1, eta2=eta2\n        )\n        return self.model_copy(update={\"device_array\": ternarized_device_array})\n\n    def trim(self) -&gt; \"Device\":\n        \"\"\"\n        Trim the device geometry by removing empty space around it.\n\n        Parameters\n        ----------\n        buffer_thickness : int, optional\n            The thickness of the buffer to leave around the empty space. Defaults to 0,\n            which means no buffer is added.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the trimmed geometry.\n        \"\"\"\n        trimmed_device_array = geometry.trim(\n            device_array=self.device_array,\n            buffer_thickness=self.buffer_spec.thickness,\n        )\n        return self.model_copy(update={\"device_array\": trimmed_device_array})\n\n    def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n        \"\"\"\n        Apply Gaussian blur to the device geometry and normalize the result.\n\n        Parameters\n        ----------\n        sigma : float, optional\n            The standard deviation for the Gaussian kernel. This controls the amount of\n            blurring. Defaults to 1.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the blurred and normalized geometry.\n        \"\"\"\n        blurred_device_array = geometry.blur(\n            device_array=self.device_array, sigma=sigma\n        )\n        return self.model_copy(update={\"device_array\": blurred_device_array})\n\n    def rotate(self, angle: float) -&gt; \"Device\":\n        \"\"\"\n        Rotate the device geometry by a given angle.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation in degrees. Positive values mean counter-clockwise\n            rotation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the rotated geometry.\n        \"\"\"\n        rotated_device_array = geometry.rotate(\n            device_array=self.device_array, angle=angle\n        )\n        return self.model_copy(update={\"device_array\": rotated_device_array})\n\n    def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Erode the device geometry by removing small areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for erosion.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the eroded geometry.\n        \"\"\"\n        eroded_device_array = geometry.erode(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": eroded_device_array})\n\n    def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Dilate the device geometry by expanding areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for dilation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the dilated geometry.\n        \"\"\"\n        dilated_device_array = geometry.dilate(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": dilated_device_array})\n\n    def flatten(self) -&gt; \"Device\":\n        \"\"\"\n        Flatten the device geometry by summing the vertical layers and normalizing the\n        result.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            The input array to be flattened.\n\n        Returns\n        -------\n        np.ndarray\n            The flattened array with values scaled between 0 and 1.\n        \"\"\"\n        flattened_device_array = geometry.flatten(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": flattened_device_array})\n\n    def get_uncertainty(self) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the uncertainty in the edge positions of the predicted device.\n\n        This method computes the uncertainty based on the deviation of the device's\n        geometry values from the midpoint (0.5). The uncertainty is defined as the\n        absolute difference from 0.5, scaled and inverted to provide a measure where\n        higher values indicate greater uncertainty.\n\n        Returns\n        -------\n        np.ndarray\n            An array representing the uncertainty in the edge positions of the device,\n            with higher values indicating greater uncertainty.\n        \"\"\"\n        return 1 - 2 * np.abs(0.5 - self.device_array)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.__init__","title":"<code>__init__(device_array, buffer_spec=None)</code>","text":"<p>Represents the planar geometry of a photonic device design that will have its nanofabrication outcome predicted and/or corrected.</p> <p>This class is designed to encapsulate the geometric representation of a photonic device, facilitating operations such as padding, normalization, binarization, ternarization, trimming, and blurring. These operations are useful for preparing the device design for prediction or correction. Additionally, the class provides methods for exporting the device representation to various formats, including ndarray, image files, and GDSII files, supporting a range of analysis and fabrication workflows.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device. This array undergoes various transformations to predict or correct the nanofabrication process.</p> required <code>buffer_spec</code> <code>BufferSpec</code> <p>Defines the parameters for adding a buffer zone around the device geometry. This buffer zone is needed for providing surrounding context for prediction or correction and for ensuring seamless integration with the surrounding circuitry. By default, a generous padding is applied to accommodate isolated structures.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple[int, int]</code> <p>The shape of the device array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided <code>device_array</code> is not a numpy ndarray or is not a 2D array, indicating an invalid device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def __init__(\n    self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n):\n    \"\"\"\n    Represents the planar geometry of a photonic device design that will have its\n    nanofabrication outcome predicted and/or corrected.\n\n    This class is designed to encapsulate the geometric representation of a photonic\n    device, facilitating operations such as padding, normalization, binarization,\n    ternarization, trimming, and blurring. These operations are useful for preparing\n    the device design for prediction or correction. Additionally, the class provides\n    methods for exporting the device representation to various formats, including\n    ndarray, image files, and GDSII files, supporting a range of analysis and\n    fabrication workflows.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array\n        undergoes various transformations to predict or correct the nanofabrication\n        process.\n    buffer_spec : BufferSpec, optional\n        Defines the parameters for adding a buffer zone around the device geometry.\n        This buffer zone is needed for providing surrounding context for prediction\n        or correction and for ensuring seamless integration with the surrounding\n        circuitry. By default, a generous padding is applied to accommodate isolated\n        structures.\n\n    Attributes\n    ----------\n    shape : tuple[int, int]\n        The shape of the device array.\n\n    Raises\n    ------\n    ValueError\n        If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n        indicating an invalid device geometry.\n    \"\"\"\n    super().__init__(\n        device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n    )\n    self._initial_processing()\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize","title":"<code>binarize(eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the device geometry based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float, optional\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize(\n        device_array=self.device_array, eta=eta, beta=beta\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_hard","title":"<code>binarize_hard(eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the device geometry. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <pre><code>Parameters\n</code></pre> <pre><code>eta : float, optional\n    The threshold value for binarization. Defaults to 0.5.\n</code></pre> <pre><code>Returns\n</code></pre> <pre><code>Device\n    A new instance of the Device with the threshold-binarized geometry.\n</code></pre> Source code in <code>prefab/device.py</code> <pre><code>def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n    \"\"\"\n    Apply a hard threshold to binarize the device geometry. The `binarize` function\n    is generally preferred for most use cases, but it can create numerical artifacts\n    for large beta values.\n\n        Parameters\n        ----------\n        eta : float, optional\n            The threshold value for binarization. Defaults to 0.5.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the threshold-binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_hard(\n        device_array=self.device_array, eta=eta\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_monte_carlo","title":"<code>binarize_monte_carlo(threshold_noise_std=2.0, threshold_blur_std=9.0)</code>","text":"<p>Binarize the device geometry using a Monte Carlo approach with Gaussian blurring.</p> <p>This method applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the device array using Gaussian blurring, simulating a more realistic scenario where the threshold is not uniform across the device.</p> <p>Parameters:</p> Name Type Description Default <code>threshold_noise_std</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold. Defaults to 2.0.</p> <code>2.0</code> <code>threshold_blur_std</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array. Defaults to 9.0.</p> <code>9.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_monte_carlo(\n    self,\n    threshold_noise_std: float = 2.0,\n    threshold_blur_std: float = 9.0,\n) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry using a Monte Carlo approach with Gaussian\n    blurring.\n\n    This method applies a dynamic thresholding technique where the threshold value\n    is determined by a base value perturbed by Gaussian-distributed random noise.\n    The threshold is then spatially varied across the device array using Gaussian\n    blurring, simulating a more realistic scenario where the threshold is not\n    uniform across the device.\n\n    Parameters\n    ----------\n    threshold_noise_std : float, optional\n        The standard deviation of the Gaussian distribution used to generate noise\n        for the threshold values. This controls the amount of randomness in the\n        threshold. Defaults to 2.0.\n    threshold_blur_std : float, optional\n        The standard deviation for the Gaussian kernel used in blurring the\n        threshold map. This controls the spatial variation of the threshold across\n        the array. Defaults to 9.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_monte_carlo(\n        device_array=self.device_array,\n        threshold_noise_std=threshold_noise_std,\n        threshold_blur_std=threshold_blur_std,\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.blur","title":"<code>blur(sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the device geometry and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the blurred and normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n    \"\"\"\n    Apply Gaussian blur to the device geometry and normalize the result.\n\n    Parameters\n    ----------\n    sigma : float, optional\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the blurred and normalized geometry.\n    \"\"\"\n    blurred_device_array = geometry.blur(\n        device_array=self.device_array, sigma=sigma\n    )\n    return self.model_copy(update={\"device_array\": blurred_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.correct","title":"<code>correct(model, binarize=True)</code>","text":"<p>Correct the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless correction service, which uses a specified machine learning model to correct the outcome of the nanofabrication process. The correction aims to adjust the device geometry to compensate for known fabrication errors and improve the accuracy of the final device structure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for correction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the correction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the corrected device geometry will be binarized using a threshold method. This is useful for converting probabilistic corrections into binary geometries. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the corrected geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the correction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def correct(\n    self,\n    model: Model,\n    binarize: bool = True,\n) -&gt; \"Device\":\n    \"\"\"\n    Correct the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless correction service, which\n    uses a specified machine learning model to correct the outcome of the\n    nanofabrication process. The correction aims to adjust the device geometry to\n    compensate for known fabrication errors and improve the accuracy of the final\n    device structure.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for correction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the correction\n        is tailored to specific fabrication parameters.\n    binarize : bool, optional\n        If True, the corrected device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic corrections into binary\n        geometries. Defaults to True.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the corrected geometry.\n\n    Raises\n    ------\n    ValueError\n        If the correction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    correction_array = self._predict_array(\n        model=model,\n        model_type=\"c\",\n        binarize=binarize,\n    )\n    return self.model_copy(update={\"device_array\": correction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.dilate","title":"<code>dilate(kernel_size=3)</code>","text":"<p>Dilate the device geometry by expanding areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the dilated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Dilate the device geometry by expanding areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the dilated geometry.\n    \"\"\"\n    dilated_device_array = geometry.dilate(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": dilated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.erode","title":"<code>erode(kernel_size=3)</code>","text":"<p>Erode the device geometry by removing small areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the eroded geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Erode the device geometry by removing small areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the eroded geometry.\n    \"\"\"\n    eroded_device_array = geometry.erode(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": eroded_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.flatten","title":"<code>flatten()</code>","text":"<p>Flatten the device geometry by summing the vertical layers and normalizing the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be flattened.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The flattened array with values scaled between 0 and 1.</p> Source code in <code>prefab/device.py</code> <pre><code>def flatten(self) -&gt; \"Device\":\n    \"\"\"\n    Flatten the device geometry by summing the vertical layers and normalizing the\n    result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be flattened.\n\n    Returns\n    -------\n    np.ndarray\n        The flattened array with values scaled between 0 and 1.\n    \"\"\"\n    flattened_device_array = geometry.flatten(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": flattened_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.get_uncertainty","title":"<code>get_uncertainty()</code>","text":"<p>Calculate the uncertainty in the edge positions of the predicted device.</p> <p>This method computes the uncertainty based on the deviation of the device's geometry values from the midpoint (0.5). The uncertainty is defined as the absolute difference from 0.5, scaled and inverted to provide a measure where higher values indicate greater uncertainty.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing the uncertainty in the edge positions of the device, with higher values indicating greater uncertainty.</p> Source code in <code>prefab/device.py</code> <pre><code>def get_uncertainty(self) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the uncertainty in the edge positions of the predicted device.\n\n    This method computes the uncertainty based on the deviation of the device's\n    geometry values from the midpoint (0.5). The uncertainty is defined as the\n    absolute difference from 0.5, scaled and inverted to provide a measure where\n    higher values indicate greater uncertainty.\n\n    Returns\n    -------\n    np.ndarray\n        An array representing the uncertainty in the edge positions of the device,\n        with higher values indicating greater uncertainty.\n    \"\"\"\n    return 1 - 2 * np.abs(0.5 - self.device_array)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.is_binary","title":"<code>is_binary()</code>","text":"<p>Check if the device geometry is binary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device geometry is binary, False otherwise.</p> Source code in <code>prefab/device.py</code> <pre><code>def is_binary(self) -&gt; bool:\n    \"\"\"\n    Check if the device geometry is binary.\n\n    Returns\n    -------\n    bool\n        True if the device geometry is binary, False otherwise.\n    \"\"\"\n    unique_values = np.unique(self.device_array)\n    return (\n        np.array_equal(unique_values, [0, 1])\n        or np.array_equal(unique_values, [1, 0])\n        or np.array_equal(unique_values, [0])\n        or np.array_equal(unique_values, [1])\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the device geometry.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def normalize(self) -&gt; \"Device\":\n    \"\"\"\n    Normalize the device geometry.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the normalized geometry.\n    \"\"\"\n    normalized_device_array = geometry.normalize(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": normalized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot","title":"<code>plot(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the device geometry.</p> <p>This method allows for the visualization of the device geometry. The visualization can be customized with various matplotlib parameters and can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device geometry on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the device geometry.\n\n    This method allows for the visualization of the device geometry. The\n    visualization can be customized with various matplotlib parameters and can be\n    drawn on an existing matplotlib Axes object or create a new one if none is\n    provided.\n\n    Parameters\n    ----------\n    show_buffer : bool, optional\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the device geometry on. If\n        None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the plot. This object can be used for\n        further plot customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        plot_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        plot_array = self.device_array[:, :, level]\n    _, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_compare","title":"<code>plot_compare(ref_device, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the comparison between the current device geometry and a reference device geometry.</p> <p>Positive values (dilation) and negative values (erosion) are visualized with a color map to indicate areas where the current device has expanded or contracted relative to the reference.</p> <p>Parameters:</p> Name Type Description Default <code>ref_device</code> <code>Device</code> <p>The reference device to compare against.</p> required <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the comparison on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the comparison plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_compare(\n    self,\n    ref_device: \"Device\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the comparison between the current device geometry and a reference\n    device geometry.\n\n    Positive values (dilation) and negative values (erosion) are visualized with a\n    color map to indicate areas where the current device has expanded or contracted\n    relative to the reference.\n\n    Parameters\n    ----------\n    ref_device : Device\n        The reference device to compare against.\n    show_buffer : bool, optional\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the comparison on. If None, a new\n        figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the comparison plot. This object can\n        be used for further plot customization or saving the plot after the method\n        returns.\n    \"\"\"\n    plot_array = ref_device.device_array - self.device_array\n\n    if level is None:\n        plot_array = geometry.flatten(plot_array)[:, :, 0]\n    else:\n        plot_array = plot_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        cmap=\"jet\",\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_contour","title":"<code>plot_contour(linewidth=None, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the contour of the device geometry.</p> <p>This method plots the contour of the device geometry, emphasizing the edges and boundaries of the device. The contour plot can be customized with various matplotlib parameters, including line width and color. The plot can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>linewidth</code> <code>Optional[int]</code> <p>The width of the contour lines. If None, the linewidth is automatically determined based on the size of the device array. Defaults to None.</p> <code>None</code> <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device contour on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the contour plot. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_contour(\n    self,\n    linewidth: Optional[int] = None,\n    # label: Optional[str] = \"Device contour\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the contour of the device geometry.\n\n    This method plots the contour of the device geometry, emphasizing the edges and\n    boundaries of the device. The contour plot can be customized with various\n    matplotlib parameters, including line width and color. The plot can be drawn on\n    an existing matplotlib Axes object or create a new one if none is provided.\n\n    Parameters\n    ----------\n    linewidth : Optional[int], optional\n        The width of the contour lines. If None, the linewidth is automatically\n        determined based on the size of the device array. Defaults to None.\n    show_buffer : bool, optional\n        If True, the buffer zones around the device will be visualized. By default,\n        it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the device contour on. If None, a\n        new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the contour plot. This can be used for\n        further customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        device_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        device_array = self.device_array[:, :, level]\n\n    kwargs.setdefault(\"cmap\", \"spring\")\n    if linewidth is None:\n        linewidth = device_array.shape[0] // 100\n\n    contours, _ = cv2.findContours(\n        geometry.binarize_hard(device_array).astype(np.uint8),\n        cv2.RETR_CCOMP,\n        cv2.CHAIN_APPROX_SIMPLE,\n    )\n    contour_array = np.zeros_like(device_array, dtype=np.uint8)\n    cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n    contour_array = np.ma.masked_equal(contour_array, 0)\n\n    _, ax = self._plot_base(\n        plot_array=contour_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n    # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n    # ax.legend([legend_proxy], [label], loc=\"upper right\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_uncertainty","title":"<code>plot_uncertainty(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the uncertainty in the edge positions of the predicted device.</p> <p>This method plots the uncertainty associated with the positions of the edges of the device. The uncertainty is represented as a gradient, with areas of higher uncertainty indicating a greater likelihood of the edge position from run to run (due to inconsistencies in the fabrication process). This visualization can help in identifying areas within the device geometry that may require design adjustments to improve fabrication consistency.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will also be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the uncertainty visualization on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the uncertainty visualization. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_uncertainty(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the uncertainty in the edge positions of the predicted device.\n\n    This method plots the uncertainty associated with the positions of the edges of\n    the device. The uncertainty is represented as a gradient, with areas of higher\n    uncertainty indicating a greater likelihood of the edge position from run to run\n    (due to inconsistencies in the fabrication process). This visualization can help\n    in identifying areas within the device geometry that may require design\n    adjustments to improve fabrication consistency.\n\n    Parameters\n    ----------\n    show_buffer : bool, optional\n        If True, the buffer zones around the device will also be visualized. By\n        default, it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the uncertainty visualization on.\n        If None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the uncertainty visualization. This\n        can be used for further customization or saving the plot after the method\n        returns.\n    \"\"\"\n    uncertainty_array = self.get_uncertainty()\n\n    if level is None:\n        uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n    else:\n        uncertainty_array = uncertainty_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=uncertainty_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Uncertainty (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.predict","title":"<code>predict(model, binarize=False)</code>","text":"<p>Predict the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the predicted device geometry will be binarized using a threshold method. This is useful for converting probabilistic predictions into binary geometries. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the predicted geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the prediction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def predict(\n    self,\n    model: Model,\n    binarize: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Predict the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless prediction service, which\n    uses a specified machine learning model to predict the outcome of the\n    nanofabrication process.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for prediction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the prediction\n        is tailored to specific fabrication parameters.\n    binarize : bool, optional\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries. Defaults to False.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the predicted geometry.\n\n    Raises\n    ------\n    ValueError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    prediction_array = self._predict_array(\n        model=model,\n        model_type=\"p\",\n        binarize=binarize,\n    )\n    return self.model_copy(update={\"device_array\": prediction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.rotate","title":"<code>rotate(angle)</code>","text":"<p>Rotate the device geometry by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the rotated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def rotate(self, angle: float) -&gt; \"Device\":\n    \"\"\"\n    Rotate the device geometry by a given angle.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the rotated geometry.\n    \"\"\"\n    rotated_device_array = geometry.rotate(\n        device_array=self.device_array, angle=angle\n    )\n    return self.model_copy(update={\"device_array\": rotated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.semulate","title":"<code>semulate(model)</code>","text":"<p>Simulate the appearance of the device as if viewed under a scanning electron microscope (SEM).</p> <p>This method applies a specified machine learning model to transform the device geometry into a style that resembles an SEM image. This can be useful for visualizing how the device might appear under an SEM, which is often used for inspecting the surface and composition of materials at high magnification.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for SEMulation, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the SEMulation is tailored to specific fabrication parameters.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with its geometry transformed to simulate an SEM image style.</p> Source code in <code>prefab/device.py</code> <pre><code>def semulate(\n    self,\n    model: Model,\n) -&gt; \"Device\":\n    \"\"\"\n    Simulate the appearance of the device as if viewed under a scanning electron\n    microscope (SEM).\n\n    This method applies a specified machine learning model to transform the device\n    geometry into a style that resembles an SEM image. This can be useful for\n    visualizing how the device might appear under an SEM, which is often used for\n    inspecting the surface and composition of materials at high magnification.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for SEMulation, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the SEMulation\n        is tailored to specific fabrication parameters.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with its geometry transformed to simulate\n        an SEM image style.\n    \"\"\"\n    semulated_array = self._predict_array(\n        model=model,\n        model_type=\"s\",\n    )\n    return self.model_copy(update={\"device_array\": semulated_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.ternarize","title":"<code>ternarize(eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the device geometry based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the ternarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n    \"\"\"\n    Ternarize the device geometry based on two thresholds. This function is useful\n    for flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    eta1 : float, optional\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float, optional\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the ternarized geometry.\n    \"\"\"\n    ternarized_device_array = geometry.ternarize(\n        device_array=self.device_array, eta1=eta1, eta2=eta2\n    )\n    return self.model_copy(update={\"device_array\": ternarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gds","title":"<code>to_gds(gds_path='prefab_device.gds', cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2)</code>","text":"<p>Exports the device geometry as a GDSII file.</p> <p>This method converts the device geometry into a format suitable for GDSII files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The path where the GDSII file will be saved. If not specified, the file is saved as \"prefab_device.gds\" in the current directory.</p> <code>'prefab_device.gds'</code> <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDSII file. If not specified, defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSII file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> Source code in <code>prefab/device.py</code> <pre><code>def to_gds(\n    self,\n    gds_path: str = \"prefab_device.gds\",\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n):\n    \"\"\"\n    Exports the device geometry as a GDSII file.\n\n    This method converts the device geometry into a format suitable for GDSII files.\n    The conversion involves contour approximation to simplify the geometry while\n    preserving essential features.\n\n    Parameters\n    ----------\n    gds_path : str, optional\n        The path where the GDSII file will be saved. If not specified, the file is\n        saved as \"prefab_device.gds\" in the current directory.\n    cell_name : str, optional\n        The name of the cell within the GDSII file. If not specified, defaults to\n        \"prefab_device\".\n    gds_layer : tuple[int, int], optional\n        The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n    contour_approx_mode : int, optional\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    \"\"\"\n    gdstk_cell = self._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n    )\n    print(f\"Saving GDS to '{gds_path}'...\")\n    gdstk_library = gdstk.Library()\n    gdstk_library.add(gdstk_cell)\n    gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gdstk","title":"<code>to_gdstk(cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2)</code>","text":"<p>Converts the device geometry to a GDSTK cell object.</p> <p>This method prepares the device geometry for GDSII file export by converting it into a GDSTK cell object. GDSTK is a Python module for creating and manipulating GDSII layout files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>The name of the cell to be created. Defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> <p>Returns:</p> Type Description <code>Cell</code> <p>The GDSTK cell object representing the device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdstk(\n    self,\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n):\n    \"\"\"\n    Converts the device geometry to a GDSTK cell object.\n\n    This method prepares the device geometry for GDSII file export by converting it\n    into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n    GDSII layout files. The conversion involves contour approximation to simplify\n    the geometry while preserving essential features.\n\n    Parameters\n    ----------\n    cell_name : str, optional\n        The name of the cell to be created. Defaults to \"prefab_device\".\n    gds_layer : tuple[int, int], optional\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    contour_approx_mode : int, optional\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n\n    Returns\n    -------\n    gdstk.Cell\n        The GDSTK cell object representing the device geometry.\n    \"\"\"\n    print(f\"Creating cell '{cell_name}'...\")\n    gdstk_cell = self._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n    )\n    return gdstk_cell\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_img","title":"<code>to_img(img_path='prefab_device.png')</code>","text":"<p>Exports the device geometry as an image file.</p> <p>This method converts the device geometry to an ndarray using <code>to_ndarray</code>, scales the values to the range [0, 255] for image representation, and saves the result as an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path where the image file will be saved. If not specified, the image is saved as \"prefab_device.png\" in the current directory.</p> <code>'prefab_device.png'</code> Source code in <code>prefab/device.py</code> <pre><code>def to_img(self, img_path: str = \"prefab_device.png\"):\n    \"\"\"\n    Exports the device geometry as an image file.\n\n    This method converts the device geometry to an ndarray using `to_ndarray`,\n    scales the values to the range [0, 255] for image representation, and saves the\n    result as an image file.\n\n    Parameters\n    ----------\n    img_path : str, optional\n        The path where the image file will be saved. If not specified, the image is\n        saved as \"prefab_device.png\" in the current directory.\n    \"\"\"\n    cv2.imwrite(img_path, 255 * self.to_ndarray())\n    print(f\"Saved Device to '{img_path}'\")\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_ndarray","title":"<code>to_ndarray()</code>","text":"<p>Converts the device geometry to an ndarray.</p> <p>This method applies the buffer specifications to crop the device array if necessary, based on the buffer mode ('edge' or 'constant'). It then returns the resulting ndarray representing the device geometry.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ndarray representation of the device geometry, with any applied buffer cropping.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_ndarray(self) -&gt; np.ndarray:\n    \"\"\"\n    Converts the device geometry to an ndarray.\n\n    This method applies the buffer specifications to crop the device array if\n    necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n    resulting ndarray representing the device geometry.\n\n    Returns\n    -------\n    np.ndarray\n        The ndarray representation of the device geometry, with any applied buffer\n        cropping.\n    \"\"\"\n    device_array = np.copy(self.device_array)\n    buffer_thickness = self.buffer_spec.thickness\n    buffer_mode = self.buffer_spec.mode\n\n    crop_top = buffer_thickness if buffer_mode[\"top\"] == \"edge\" else 0\n    crop_bottom = buffer_thickness if buffer_mode[\"bottom\"] == \"edge\" else 0\n    crop_left = buffer_thickness if buffer_mode[\"left\"] == \"edge\" else 0\n    crop_right = buffer_thickness if buffer_mode[\"right\"] == \"edge\" else 0\n\n    ndarray = device_array[\n        crop_top : device_array.shape[0] - crop_bottom,\n        crop_left : device_array.shape[1] - crop_right,\n    ]\n    return np.squeeze(ndarray)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.trim","title":"<code>trim()</code>","text":"<p>Trim the device geometry by removing empty space around it.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_thickness</code> <code>int</code> <p>The thickness of the buffer to leave around the empty space. Defaults to 0, which means no buffer is added.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the trimmed geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def trim(self) -&gt; \"Device\":\n    \"\"\"\n    Trim the device geometry by removing empty space around it.\n\n    Parameters\n    ----------\n    buffer_thickness : int, optional\n        The thickness of the buffer to leave around the empty space. Defaults to 0,\n        which means no buffer is added.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the trimmed geometry.\n    \"\"\"\n    trimmed_device_array = geometry.trim(\n        device_array=self.device_array,\n        buffer_thickness=self.buffer_spec.thickness,\n    )\n    return self.model_copy(update={\"device_array\": trimmed_device_array})\n</code></pre>"},{"location":"reference/geometry/","title":"Geometry","text":"<p>Provides functions for manipulating ndarrays of device geometries.</p>"},{"location":"reference/geometry/#prefab.geometry.binarize","title":"<code>binarize(device_array, eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the input ndarray based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize(\n    device_array: np.ndarray, eta: float = 0.5, beta: float = np.inf\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input ndarray based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float, optional\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements scaled to 0 or 1.\n    \"\"\"\n    return (np.tanh(beta * eta) + np.tanh(beta * (device_array - eta))) / (\n        np.tanh(beta * eta) + np.tanh(beta * (1 - eta))\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_hard","title":"<code>binarize_hard(device_array, eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the input ndarray. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements set to 0 or 1 based on the threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_hard(device_array: np.ndarray, eta: float = 0.5) -&gt; np.ndarray:\n    \"\"\"\n    Apply a hard threshold to binarize the input ndarray. The `binarize` function is\n    generally preferred for most use cases, but it can create numerical artifacts for\n    large beta values.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the threshold.\n    \"\"\"\n    return np.where(device_array &lt; eta, 0.0, 1.0)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_monte_carlo","title":"<code>binarize_monte_carlo(device_array, threshold_noise_std, threshold_blur_std)</code>","text":"<p>Binarize the input ndarray using a Monte Carlo approach with Gaussian blurring.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the array using Gaussian blurring, simulating a potentially more realistic scenario where the threshold is not uniform across the device.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>threshold_noise_std</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold.</p> required <code>threshold_blur_std</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements set to 0 or 1 based on the dynamically generated threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_monte_carlo(\n    device_array: np.ndarray,\n    threshold_noise_std: float,\n    threshold_blur_std: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input ndarray using a Monte Carlo approach with Gaussian blurring.\n\n    This function applies a dynamic thresholding technique where the threshold value is\n    determined by a base value perturbed by Gaussian-distributed random noise. The\n    threshold is then spatially varied across the array using Gaussian blurring,\n    simulating a potentially more realistic scenario where the threshold is not uniform\n    across the device.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    threshold_noise_std : float\n        The standard deviation of the Gaussian distribution used to generate noise for\n        the threshold values. This controls the amount of randomness in the threshold.\n    threshold_blur_std : float\n        The standard deviation for the Gaussian kernel used in blurring the threshold\n        map. This controls the spatial variation of the threshold across the array.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the dynamically\n        generated threshold.\n    \"\"\"\n    device_array = np.squeeze(device_array)\n    base_threshold = np.clip(np.random.normal(loc=0.5, scale=0.5 / 2), 0.4, 0.6)\n    threshold_noise = np.random.normal(\n        loc=0, scale=threshold_noise_std, size=device_array.shape\n    )\n    spatial_threshold = cv2.GaussianBlur(\n        threshold_noise, ksize=(0, 0), sigmaX=threshold_blur_std\n    )\n    dynamic_threshold = base_threshold + spatial_threshold\n    binarized_array = np.where(device_array &lt; dynamic_threshold, 0.0, 1.0)\n    binarized_array = np.expand_dims(binarized_array, axis=-1)\n    return binarized_array\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_sem","title":"<code>binarize_sem(sem_array)</code>","text":"<p>Binarize a grayscale scanning electron microscope (SEM) image.</p> <p>This function applies Otsu's method to automatically determine the optimal threshold value for binarization of a grayscale SEM image.</p> <p>Parameters:</p> Name Type Description Default <code>sem_array</code> <code>ndarray</code> <p>The input SEM image array to be binarized.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized SEM image array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_sem(sem_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Binarize a grayscale scanning electron microscope (SEM) image.\n\n    This function applies Otsu's method to automatically determine the optimal threshold\n    value for binarization of a grayscale SEM image.\n\n    Parameters\n    ----------\n    sem_array : np.ndarray\n        The input SEM image array to be binarized.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized SEM image array with elements scaled to 0 or 1.\n    \"\"\"\n    return cv2.threshold(\n        sem_array.astype(\"uint8\"), 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU\n    )[1]\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.blur","title":"<code>blur(device_array, sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the input ndarray and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be blurred.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The blurred and normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def blur(device_array: np.ndarray, sigma: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Apply Gaussian blur to the input ndarray and normalize the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be blurred.\n    sigma : float, optional\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        The blurred and normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return normalize(cv2.GaussianBlur(device_array, ksize=(0, 0), sigmaX=sigma))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.dilate","title":"<code>dilate(device_array, kernel_size)</code>","text":"<p>Dilate the input ndarray using a specified kernel size.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry to be dilated.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The dilated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def dilate(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Dilate the input ndarray using a specified kernel size.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be dilated.\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    np.ndarray\n        The dilated array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return cv2.dilate(device_array, kernel=kernel)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.erode","title":"<code>erode(device_array, kernel_size)</code>","text":"<p>Erode the input ndarray using a specified kernel size and number of iterations.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry to be eroded.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The eroded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def erode(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Erode the input ndarray using a specified kernel size and number of iterations.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be eroded.\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    np.ndarray\n        The eroded array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return cv2.erode(device_array, kernel=kernel)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.flatten","title":"<code>flatten(device_array)</code>","text":"<p>Flatten the input ndarray by summing the vertical layers and normalizing the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be flattened.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The flattened array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def flatten(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Flatten the input ndarray by summing the vertical layers and normalizing the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be flattened.\n\n    Returns\n    -------\n    np.ndarray\n        The flattened array with values scaled between 0 and 1.\n    \"\"\"\n    return normalize(np.sum(device_array, axis=-1, keepdims=True))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.normalize","title":"<code>normalize(device_array)</code>","text":"<p>Normalize the input ndarray to have values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be normalized.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def normalize(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Normalize the input ndarray to have values between 0 and 1.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be normalized.\n\n    Returns\n    -------\n    np.ndarray\n        The normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return (device_array - np.min(device_array)) / (\n        np.max(device_array) - np.min(device_array)\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.rotate","title":"<code>rotate(device_array, angle)</code>","text":"<p>Rotate the input ndarray by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be rotated.</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rotated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def rotate(device_array: np.ndarray, angle: float) -&gt; np.ndarray:\n    \"\"\"\n    Rotate the input ndarray by a given angle.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be rotated.\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    np.ndarray\n        The rotated array.\n    \"\"\"\n    center = (device_array.shape[1] / 2, device_array.shape[0] / 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center=center, angle=angle, scale=1)\n    return cv2.warpAffine(\n        device_array,\n        M=rotation_matrix,\n        dsize=(device_array.shape[1], device_array.shape[0]),\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.ternarize","title":"<code>ternarize(device_array, eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the input ndarray based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be ternarized.</p> required <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def ternarize(\n    device_array: np.ndarray, eta1: float = 1 / 3, eta2: float = 2 / 3\n) -&gt; np.ndarray:\n    \"\"\"\n    Ternarize the input ndarray based on two thresholds. This function is useful for\n    flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be ternarized.\n    eta1 : float, optional\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float, optional\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    np.ndarray\n        The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.\n    \"\"\"\n    return np.where(device_array &lt; eta1, 0.0, np.where(device_array &gt;= eta2, 1.0, 0.5))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.trim","title":"<code>trim(device_array, buffer_thickness=0)</code>","text":"<p>Trim the input ndarray by removing rows and columns that are completely zero.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be trimmed.</p> required <code>buffer_thickness</code> <code>int</code> <p>The thickness of the buffer to leave around the non-zero elements of the array. Defaults to 0, which means no buffer is added.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The trimmed array, potentially with a buffer around the non-zero elements.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def trim(device_array: np.ndarray, buffer_thickness: int = 0) -&gt; np.ndarray:\n    \"\"\"\n    Trim the input ndarray by removing rows and columns that are completely zero.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be trimmed.\n    buffer_thickness : int, optional\n        The thickness of the buffer to leave around the non-zero elements of the array.\n        Defaults to 0, which means no buffer is added.\n\n    Returns\n    -------\n    np.ndarray\n        The trimmed array, potentially with a buffer around the non-zero elements.\n    \"\"\"\n    nonzero_rows, nonzero_cols = np.nonzero(device_array)\n    row_min = max(nonzero_rows.min() - buffer_thickness, 0)\n    row_max = min(\n        nonzero_rows.max() + buffer_thickness + 1,\n        device_array.shape[0],\n    )\n    col_min = max(nonzero_cols.min() - buffer_thickness, 0)\n    col_max = min(\n        nonzero_cols.max() + buffer_thickness + 1,\n        device_array.shape[1],\n    )\n    return device_array[\n        row_min:row_max,\n        col_min:col_max,\n    ]\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>Models for the PreFab library.</p>"},{"location":"reference/models/#prefab.models.Fab","title":"<code>Fab</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a fabrication process in the PreFab model library.</p> <p>Parameters:</p> Name Type Description Default <code>foundry</code> <code>str</code> <p>The name of the foundry where the fabrication process takes place.</p> required <code>process</code> <code>str</code> <p>The specific process used in the fabrication.</p> required <code>material</code> <code>str</code> <p>The material used in the fabrication process.</p> required <code>technology</code> <code>str</code> <p>The technology used in the fabrication process.</p> required <code>thickness</code> <code>int</code> <p>The thickness of the material used, measured in nanometers.</p> required <code>has_sidewall</code> <code>bool</code> <p>Indicates whether the fabrication has angled sidewalls.</p> required Source code in <code>prefab/models.py</code> <pre><code>class Fab(BaseModel):\n    \"\"\"\n    Represents a fabrication process in the PreFab model library.\n\n    Parameters\n    ----------\n    foundry : str\n        The name of the foundry where the fabrication process takes place.\n    process : str\n        The specific process used in the fabrication.\n    material : str\n        The material used in the fabrication process.\n    technology : str\n        The technology used in the fabrication process.\n    thickness : int\n        The thickness of the material used, measured in nanometers.\n    has_sidewall : bool\n        Indicates whether the fabrication has angled sidewalls.\n    \"\"\"\n\n    foundry: str\n    process: str\n    material: str\n    technology: str\n    thickness: int\n    has_sidewall: bool\n</code></pre>"},{"location":"reference/models/#prefab.models.Model","title":"<code>Model</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a model of a fabrication process including versioning and dataset detail.</p> <p>Attributes:</p> Name Type Description <code>fab</code> <code>Fab</code> <p>An instance of the Fab class representing the fabrication details.</p> <code>version</code> <code>str</code> <p>The version identifier of the model.</p> <code>version_date</code> <code>date</code> <p>The release date of this version of the model.</p> <code>dataset</code> <code>str</code> <p>The identifier for the dataset used in this model.</p> <code>dataset_date</code> <code>date</code> <p>The date when the dataset was last updated or released.</p> <code>tag</code> <code>str</code> <p>An optional tag for additional categorization or notes.</p> <p>Methods:</p> Name Description <code>to_json</code> <p>Serializes the model instance to a JSON formatted string.</p> Source code in <code>prefab/models.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Represents a model of a fabrication process including versioning and dataset detail.\n\n    Attributes\n    ----------\n    fab : Fab\n        An instance of the Fab class representing the fabrication details.\n    version : str\n        The version identifier of the model.\n    version_date : date\n        The release date of this version of the model.\n    dataset : str\n        The identifier for the dataset used in this model.\n    dataset_date : date\n        The date when the dataset was last updated or released.\n    tag : str\n        An optional tag for additional categorization or notes.\n\n    Methods\n    -------\n    to_json()\n        Serializes the model instance to a JSON formatted string.\n    \"\"\"\n\n    fab: Fab\n    version: str\n    version_date: date\n    dataset: str\n    dataset_date: date\n    tag: str\n\n    def to_json(self):\n        return json.dumps(self.dict(), default=str)\n</code></pre>"},{"location":"reference/read/","title":"Read","text":"<p>Provides functions to create Devices from various data sources.</p>"},{"location":"reference/read/#prefab.read.from_gds","title":"<code>from_gds(gds_path, cell_name, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a GDS cell.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The file path to the GDS file.</p> required <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDS file to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the GDS file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>tuple[tuple[int, int], tuple[int, int]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the specified cell from the GDS file, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gds(\n    gds_path: str,\n    cell_name: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a GDS cell.\n\n    Parameters\n    ----------\n    gds_path : str\n        The file path to the GDS file.\n    cell_name : str\n        The name of the cell within the GDS file to be converted into a Device object.\n    gds_layer : tuple[int, int], optional\n        A tuple specifying the layer and datatype to be used from the GDS file. Defaults\n        to (1, 0).\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the specified cell from the GDS file, after\n        processing based on the specified layer.\n    \"\"\"\n    gdstk_library = gdstk.read_gds(gds_path)\n    gdstk_cell = gdstk_library[cell_name]\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_gdstk","title":"<code>from_gdstk(gdstk_cell, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a gdstk cell.</p> <p>Parameters:</p> Name Type Description Default <code>gdstk_cell</code> <code>Cell</code> <p>The gdstk.Cell object to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>tuple[tuple[int, int], tuple[int, int]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the gdstk.Cell, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdstk(\n    gdstk_cell: gdstk.Cell,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a gdstk cell.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object to be converted into a Device object.\n    gds_layer : tuple[int, int], optional\n        A tuple specifying the layer and datatype to be used. Defaults to (1, 0).\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdstk.Cell, after processing based on the\n        specified layer.\n    \"\"\"\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_img","title":"<code>from_img(img_path, img_width_nm=None, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path to the image file to be converted into a Device object.</p> required <code>img_width_nm</code> <code>int</code> <p>The desired width of the device in nanometers. If specified, the image will be resized to this width while maintaining aspect ratio. If None, no resizing is performed.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the image will be binarized (converted to binary values) before conversion to a Device object. This is useful for converting grayscale images into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed image, after optional resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_img(\n    img_path: str, img_width_nm: int = None, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path to the image file to be converted into a Device object.\n    img_width_nm : int, optional\n        The desired width of the device in nanometers. If specified, the image will be\n        resized to this width while maintaining aspect ratio. If None, no resizing is\n        performed.\n    binarize : bool, optional\n        If True, the image will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for converting grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed image, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = cv2.imread(img_path, flags=cv2.IMREAD_GRAYSCALE) / 255\n    if img_width_nm is not None:\n        scale = img_width_nm / device_array.shape[1]\n        device_array = cv2.resize(device_array, dsize=(0, 0), fx=scale, fy=scale)\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_ndarray","title":"<code>from_ndarray(ndarray, resolution=1, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <code>ndarray</code> <p>The input array representing the device layout.</p> required <code>resolution</code> <code>int</code> <p>The resolution of the ndarray in nanometers per pixel, defaulting to 1 nm per pixel. If specified, the input array will be resized based on this resolution to match the desired physical size.</p> <code>1</code> <code>binarize</code> <code>bool</code> <p>If True, the input array will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale images into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the input array, after optional resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_ndarray(\n    ndarray: np.ndarray, resolution: int = 1, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an ndarray.\n\n    Parameters\n    ----------\n    ndarray : np.ndarray\n        The input array representing the device layout.\n    resolution : int, optional\n        The resolution of the ndarray in nanometers per pixel, defaulting to 1 nm per\n        pixel. If specified, the input array will be resized based on this resolution to\n        match the desired physical size.\n    binarize : bool, optional\n        If True, the input array will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the input array, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = ndarray\n    device_array = cv2.resize(device_array, dsize=(0, 0), fx=resolution, fy=resolution)\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_sem","title":"<code>from_sem(sem_path, sem_resolution=None, sem_resolution_key=None, binarize=True, bounds=None, **kwargs)</code>","text":"<p>Create a Device from a scanning electron microscope (SEM) image file.</p> <p>Parameters:</p> Name Type Description Default <code>sem_path</code> <code>str</code> <p>The file path to the SEM image.</p> required <code>sem_resolution</code> <code>float</code> <p>The resolution of the SEM image in nanometers per pixel. If not provided, it will be extracted from the image metadata using the <code>sem_resolution_key</code>.</p> <code>None</code> <code>sem_resolution_key</code> <code>str</code> <p>The key to look for in the SEM image metadata to extract the resolution. Required if <code>sem_resolution</code> is not provided.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the SEM image will be binarized (converted to binary values) before conversion to a Device object. This is needed for processing grayscale images into binary masks. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>tuple[tuple[int, int], tuple[int, int]]</code> <p>A tuple specifying the bounds for cropping the image before conversion, formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed SEM image.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>sem_resolution</code> nor <code>sem_resolution_key</code> is provided.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_sem(\n    sem_path: str,\n    sem_resolution: float = None,\n    sem_resolution_key: str = None,\n    binarize: bool = True,\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a scanning electron microscope (SEM) image file.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution : float, optional\n        The resolution of the SEM image in nanometers per pixel. If not provided, it\n        will be extracted from the image metadata using the `sem_resolution_key`.\n    sem_resolution_key : str, optional\n        The key to look for in the SEM image metadata to extract the resolution.\n        Required if `sem_resolution` is not provided.\n    binarize : bool, optional\n        If True, the SEM image will be binarized (converted to binary values) before\n        conversion to a Device object. This is needed for processing grayscale images\n        into binary masks. Defaults to True.\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the image before conversion,\n        formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is\n        used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed SEM image.\n\n    Raises\n    ------\n    ValueError\n        If neither `sem_resolution` nor `sem_resolution_key` is provided.\n    \"\"\"\n    if sem_resolution is None and sem_resolution_key is not None:\n        sem_resolution = get_sem_resolution(sem_path, sem_resolution_key)\n    elif sem_resolution is None:\n        raise ValueError(\"Either sem_resolution or resolution_key must be provided.\")\n\n    device_array = cv2.imread(sem_path, flags=cv2.IMREAD_GRAYSCALE)\n    if sem_resolution is not None:\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=sem_resolution, fy=sem_resolution\n        )\n    if bounds is not None:\n        device_array = device_array[\n            -bounds[1][1] : -bounds[0][1], bounds[0][0] : bounds[1][0]\n        ]\n    if binarize:\n        device_array = geometry.binarize_sem(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.get_sem_resolution","title":"<code>get_sem_resolution(sem_path, sem_resolution_key)</code>","text":"<p>Extracts the resolution of a scanning electron microscope (SEM) image from its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>sem_path</code> <code>str</code> <p>The file path to the SEM image.</p> required <code>sem_resolution_key</code> <code>str</code> <p>The key to look for in the SEM image metadata to extract the resolution.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the SEM image in nanometers per pixel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the resolution key is not found in the SEM image metadata.</p> Source code in <code>prefab/read.py</code> <pre><code>def get_sem_resolution(sem_path: str, sem_resolution_key: str) -&gt; float:\n    \"\"\"\n    Extracts the resolution of a scanning electron microscope (SEM) image from its\n    metadata.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution_key : str\n        The key to look for in the SEM image metadata to extract the resolution.\n\n    Returns\n    -------\n    float\n        The resolution of the SEM image in nanometers per pixel.\n\n    Raises\n    ------\n    ValueError\n        If the resolution key is not found in the SEM image metadata.\n    \"\"\"\n    with open(sem_path, \"rb\") as file:\n        resolution_key_bytes = sem_resolution_key.encode(\"utf-8\")\n        for line in file:\n            if resolution_key_bytes in line:\n                line_str = line.decode(\"utf-8\")\n                match = re.search(r\"-?\\d+(\\.\\d+)?\", line_str)\n                if match:\n                    value = float(match.group())\n                    if value &gt; 100:\n                        value /= 1000\n                    return value\n    raise ValueError(f\"Resolution key '{sem_resolution_key}' not found in {sem_path}.\")\n</code></pre>"}]}